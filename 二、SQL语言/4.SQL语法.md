### 4.1 词法结构
​		词法结构：https://www.postgresql.org/docs/13/sql-syntax-lexical.html



​		SQL输入是一个 **command** 序列。一个 **command** 由一系列 **token** 组成，以 ; 结束。 输入流的终止也是 command 的结束。哪些 token 在一个 command 中是合法的取决于具体的 command 语法。

​		一个 token 可能是个**关键字(keyword)**、**标识符(identifier)**、**quoted identifier**、**literal(或者 constant)**、特殊的字符符号。token 一般被空白字符分隔(空格、tab、换行)，但是如果没有二义性的话也可以不用空白字符分隔()。

​		例如，下列的SQL是(在句法上)合法的：

```sql
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');
```

​		这是一个由3个 SQL command 组成的序列，一个 command 占一行(虽然一个command占一行不是必须的；一行可以写多个command，一个command也可以被分成多行)。

​		另外，注释(comments) 也可以出现在 SQL 中。注释不是 token，它们在效果上等同于空白字符。

​		SQL 语法在关于哪个 token 确定一个 command、哪个是操作数(operands)、哪个是参数(parameters)的问题上是不完全一致的。开头的一些 token 一般是 command 的名字，所以在刚才讨论的那个例子中，我们可以说，一个 "SELECT"，一个 "UPDATE"，和一个 "INSERT"。但对于 UPDATE ，一定需要一个 SET token 出现在指定的位置上，而对于 INSERT，总是需要一个 VALUES token 才算完整。具体的语法细节可以查看 [Part VI](https://www.postgresql.org/docs/13/reference.html)。

​		

#### 4.1.1 标识符和关键字

​		上面例子中诸如 `SELECT`, `UPDATE` 或 `VALUES` 的 token 被称为 **关键字(keywords)**，这是说，这些 token 在 SQL 语言中具有固定的意义。`MY_TABLE`  和  `A`  这俩 token 被称为 **标识符(identifiers)**。标识符表示 表、列 或者其他数据库对象的名字，具体取决于它们被用于哪种 SQL command 中。因此，标识符又是被简单的叫做 "名字(names)" 。keywords 和 identifiers 具有相同的词法结构，所以，在我们不了解它所属的语言的话，我们不知道一个 token 到底是 keyword 还是 identifier 。完整的 SQL keywords 列表可以在 [Appendix C](https://www.postgresql.org/docs/13/sql-keywords-appendix.html) 中找到。

​		SQL keywords 和 identifiers 必须以一个字符(`a-z,A-Z`)或一个下划线开头(`_`)。后续的字符可以是 字母(`a-z,A-Z`)、下划线(`_`)、数字字符(`0-9`) 或者美元标志(`$`)。要注意的是，SQL 标准并不允许 identifiers 中包含 $(***译者注：允许 $ 是 pg 对 SQL 的扩展***)，使用 $ 会降低你的应用程序的兼容性。SQL 标准不会定义一个 包含数字字符或以下划线开头或以下划线结尾的 keyword，所以具有这种形式的 identifier 是安全的，不用担心会这会与未来的 SQL 标准冲突。

​		pg 使用的 identifier 的长度不超过  `NAMEDATALEN-1` 个字节；超过这个长度的 identifier 允许被输入，但会被截断。默认情况下，`NAMEDATALEN` 是 64，所以，identifier 最长是 63 字节。如果这个限制对你造成困扰，你可以在源码文件 `src/include/pg_config_manual.h` 增大 `NAMEDATALEN` 。(***译者注：这需要你重新编译***)。

​		keywords 和 unquoted identifiers(无引号的标识符) 是大小写**<span style="color:red">不</span>**敏感的。因此，下列两个 SQL command 是等价的：

```sql
UPDATE MY_TABLE SET A = 5;

uPDaTE my_TabLE SeT a = 5;
```

​		一个常用的约定是，将 keywords 大写，将 names 小写，例如：

```sql
UPDATE my_table SET a = 5;
```

​		还有一种 identifier：delimited identifier(有界的标识符) 或者说 quoted identifier(有引号的标识符)。它的形式是，由双引号(`"`) 括起来的一个任意的字符序列。一个 delimited identifier 就是一个 identifier，不可能是一个 keyword。所以 `"select"` 可能表示一个表或一个列的名字叫做 "select"，因此，一个无引号的 select 就是一个 keyword，如果被用在本该是个表名或列名的位置上，就会触发一个语法错误。上面的例子可以被重写为如下形式：

```sql
UPDATE "my_table" SET "a" = 5;
```

 		quoted identifiers 可以包含任何字符，`0` code 除外。(如果需要包含一个双引号，将双引号写两遍)。这允许你构造出那种几乎不可能的表名或列名，例如，名字可以包含空格或者 `&` 符号。但也要受 `NAMEDATALEN` 的限制。

​		将一个 identifier 用引号括起来，也令它变地**大小写敏感**，相对地，没有用引号括起来的 identifier 被视为是小写。例如，标识符 `FOO`、`foo` 和 `"foo"` 在 pg 看来是等价的，但是 `Foo` 和 `"FOO"` 与前面3个例子的值是不等价的。(pg 将 unquoted identifiers 视为小写与 SQL 标准是不兼容的，因为 SQL 标准将 unquoted identifiers 视为大写。因此，根据 SQL 标准来讲，`foo` 和 `"FOO"` 是等价的，而不是 `"foo"`。如果你想写出兼容的应用程序，建议你全使用 quoted identifiers 或者全使用 unquoted identifiers)。

​		quoted identifiers 的另一种变体可以包含以码点(code points)表示的 Unicode 转义字符。这种变体以 `U&` 开头(U大写或小写都是可以的)，后面紧跟着双引号(`U&` 和 `"` 之间不能有空格)，例如，`U&"foo"`。(要注意的是，这个语法给操作符 `&` 带来了歧义。可以在操作符 `&` 两边加上空格来避免这种歧义。) 在引号中，Unicode 字符可以用转义形式来表示，转义形式是：一个反斜杠，后面跟着一个4位的16进制数字；或者一个反斜杠，后面跟着一个 `+` 号，再跟着一个6位的16进制数字。例如，identifier `"data"` 可以被写成：

```sql
U&"d\0061t\+000061"
```

​		下面这个例子，将俄罗斯词语 `"slon"`以古斯拉夫字符写出：

```sql
U&"\0441\043B\043E\043D"
```

​		如果你想用其他字符代替 `\` 来作为转义字符，可以在字符串之后用 `UESCAPE` 子句，例如：

```sql
U&"d!0061t!+000061" UESCAPE '!'
```

​		转义字符可以是任何一个除 ***16进制数字字符(`0-9`, `a-f`, `A-F`)、加号字符(`+`)、单引号字符(`'`)、双引号字符(`"`)、空白字符(空格, tab, 换行符)***之外的的任意单字符。注意，`UESCAPE` 后指定的转义字符是用单引号括起来的，而不是双引号。

​		如果想在 identifier 中包含转义字符的字面值，把它写两次。

​		无论是4位的还是6位的转义都可以被用来指定 UTF-16 码对来组成码点超过 U+FFFF 的字符，但对于6位的转义这是不必要的。(替代对不会被直接存储，会被组成一个单码点。)

​		xxx

​		如果服务器的编码不适 UTF-8，Unicode 码点将会被转换为实际的服务器编码；如果无法转换将会报错。



#### 4.1.2 常量

​		在 pg 中有3种隐式输入的常量：字符串、bit strings 和 数字。常量可以被显式的输入，这可以使表达更加精确，也可以使系统处理更加高效。这两种形式都将在下面的子章节中被讨论。



##### 4.1.2.1 字符串常量

​		SQL 中的字符串常量是一个被单引号括起来的任意字符串，例如 `'This is a string'`。要在一个字符串常量中包含单引号，将它写两次即可。例如 `Dianne''s horse`。注意，这不是双引号，和双引号也是不同的。

​		两个被至少包含一个换行符的空白字符分隔开的字符串常量会被连接在一起，被当作一个字符串常量对待。例如：

```sql
SELECT 'foo'
'bar';
```

​		上面的例子等价于：

```sql
SELECT 'foobar';
```

​		但是：

```sql
SELECT 'foo'      'bar';
```

​		是非法的语法。(这个有些奇异的行为是 SQL 标准规定的；pg 遵循了标准。)



##### 4.1.2.2 带有 C 风格的字符串常量

​		pg 也接受带有转义字符的字符串常量，这是 pg 对 SQL 标准的扩展。一个带有转义字符的字符串常量形式为：以 `E` 开头的(大小写都行)，紧接着就是单引号，例如 `E'foo'`。(当要包含转义字符的字符串跨越多个行，仅仅在第一个单引号的前面带 `E`。) 在一个转义字符串里，反斜杠(`\`) 打头，引出一个类 C 风格的 **反斜杠转义序列**，在这种语法里，反斜杠和紧跟着它的若干个字符表示一个特殊字节的值，下表所示：

| 反斜杠转义序列                   | 解释                         |
| -------------------------------- | ---------------------------- |
| `\b`                             | Backspace                    |
| `\f`                             | form feed                    |
| `\n`                             | 换行                         |
| `\r`                             | 回行首                       |
| `\t`                             | Tab                          |
| `\o, \oo, \ooo (o=0-7)`          | 8进制                        |
| `\xh, \xhh (h=0-9,A-F)`          | 16进制                       |
| `\uxxxx, \Uxxxxxxxx (x=0-9,A-F)` | 16或32 位16进制 Unicode 字符 |

​		除上面表中列出的字符，有其他任何字符跟在反斜杠后，都被解释为字面值。因此，要包含一个反斜杠字符，将它写两次。同时，在一个转义字符串里，也可以用 `\'` 来包含一个单引号。

​		确保你写的字节序列，特别是使用了8进制或12进制转义语法的，对于 pg server 的编码是合法的，是你的责任。一个好的习惯是使用 Unicode 转义字符串或者使用 Unicode 转义语法(在 [Section 4.1.2.3](https://www.postgresql.org/docs/13/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS-UESCAPE))；这时 pg server 会对你的输入做一个检查。

>注意：
>
>​		如果配置参数 `standard_conforming_strings` 是关闭状态，pg server 能识别转义字符串和正常字符串中的反斜杠转义语法。然而，pg 9.1 默认是开启的，这意味着反斜杠转义语法仅仅在转义字符串中被识别。这种行为是更具有SQL标准兼容性的，但可能会将依赖于早期 pg 默认行为的应用程序搞砸。一个变通方案是，设置上述参数为关闭，但最好是不要用反斜杠转义。如果你需要使用反斜杠转义来表达一个字符，在字符串常量前面带个 `E`。
>
>​		另外，`escape_string_warning` 和 `backslash_quote` 也能管理字符串常量中的反斜杠的行为。

​		

##### 4.1.2.3 带有 Unicode 转义字符的字符串常量

​		pg 也支持其他类型的用码点(code points)来指定 Unicode 字符的转义语法。一个 Unicode 转义字符串常量以 `U&` 开头(u大小写都可以)，后面紧跟着单引号，`U&` 与 单引号之间不能有任何空白字符，例如 `U&'foo'`。(注意，这种语法给操作符 `&` 带来了二义性。可以在使用操作符 `&` 时在两边加上一些空格来避免。) 在单引号内，可以用 `\` 后跟4位的16进制数字 或 `\+` 后跟6位的16进制数字表示的码点这两种转义形式来表示 Unicode 字符。 例如，`'data'` 可以写为：

```sql
U&'d\0061t\+000061'
```

​		下面这个例子，将俄罗斯词语 `"slon"`以古斯拉夫字符写出：

```sql
U&'\0441\043B\043E\043D'
```

​		如果你想用其他字符代替 `\` 来作为转义字符，可以在字符串之后用 `UESCAPE` 子句，例如：

```sql
U&'d!0061t!+000061' UESCAPE '!'
```

​		转义字符可以是任何一个除 ***16进制数字字符(`0-9`, `a-f`, `A-F`)、加号字符(`+`)、单引号字符(`'`)、双引号字符(`"`)、空白字符(空格, tab, 换行符)***之外的的任意单字符。

​		如果想在 identifier 中包含转义字符的字面值，把它写两次。

​		xxx

​		如果服务器的编码不适 UTF-8，Unicode 码点将会被转换为实际的服务器编码；如果无法转换将会报错。

​		同时，Unicode 转义语法仅当配置 `standard_conforming_strings` 开启的时候才生效。因为这语法会让客户端感到困惑，可能会把这种 SQL 当作是 SQL注入或者有类似问题的危险SQL。如果这个参数没有开启，这种语法会被报错。



##### 4.1.2.4 Dollar-Quoted 字符串常量

​		虽然SQL标准的字符串常量语法用起来很方便，但当其中包含很多单引号和反斜杠时将变得非常难以理解，因为每个单引号和反斜杠都要被写两次。在这种背景下，pg 为了支持可读性更高的查询语句，提供了一种叫做 "**dollar quoting**" 的语法来写字符串常量。一个 dollar-quoted 字符串常量由：一个 `$` 符号，后跟着一个由零或多个字符构成的 tag，后再跟一个 `$` 符号，再跟着一个任意字符序列，再一个 `$` 符号，将前面的 tag 再重复一遍，最后再是一个 `$` 符号。例如，下面用两种方法写出 `Dianne's horse`：

```sql
$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$
```

​		注意上面的例子，在 dollar-quoted 字符串中，单引号没有使用转义写法。实际上，没有那个字符在 dollar-quoted 字符串中被转义，一切都是字面值。反斜杠也不是特殊字符，`$` 字符也不是，除非它们是 tag 的一部分。

​		在嵌套的 dollar-quoted 字符串中，不同层次的 tag 可以不同。这常被用在定义函数上。例如：

```sql
$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$
```

​		上面的例子中，`$q$[\t\r\n\v\\]$q$` 表示字面值 `[\t\r\n\v\\]`，将会在函数执行的时候被 pg 准确识别。但是，因为这个字符序列并不等于外部 dollar quoting 的终止序列 `$function$`，it is just some more characters within the constant so far as the outer string is concerned.

​		tag 是遵循一些规则的，它是一个不带引号的标识符(unquoted identifier)，但是它不能包含一个 `$` 字符。tag 是打小写敏感的，所以 `$tag$String content$tag$` 是合法的，但 `$TAG$String content$tag$` 是不合法的。

​		一个 dollar-quoted 字符串如果后面跟着一个 keyword 或者 identifier，一定要用空白字符与之分隔开；否则，dollar quoting 的终止序列的前导标识符(preceding identifier)的一部分。

​		dollar quoting 不是SQL标准的一部分，但它通常是写负责字符串字面值的方便的方法，相较于标准的单引号语法。在一个常量中表示字符串常量时，这非常有用，特别是在定义存储过程函数时。使用单引号语法，上面例子中的反斜杠就会被写4次，在分析原始的常量时它被认为是两个，在函数执行时，内部字符串分析时，反斜杠被认为是一个。



##### 4.1.2.5 Bit-String 常量

​		bit-string 常量看起来像前面加了个 `B` (大小写都行)的一般的字符串常量。例如，`B'1001'`。bit-string 常量中仅允许字符 `0` 和 `1`。

​		另外，bit-string 常量也可以用16进制符号来表示，格式是使用一个前缀 `X` (打小写都行)。例如，`X'1FF'`。这种符号跟一个16数字替换为4个二进制数字的 bit-string 常量是等价的。

> 译者注：
>
> 十六进制数字 `1F`，转换为二进制是 `00011111`。即 `X'1F'` 等价于 `B'00011111'`。

​		两种形式的 bit-string 常量都可以写成跨多行的形式，就行一般的字符串常量那样。dollar quoting 不能被应用于 bit-string 常量。



##### 4.1.2.6 数字常量

​		数字常量被接受为如下形式：

***digits***

***digits***.\[***digits***\]\[e\[+-\]***digits***\]

\[***digits***\].***digits***\[e\[+-\]***digits***\]

***digits***e\[+-\]***digits***

​		`digits` 由1或多个十进制数字(0到9)组成。如果是小数的话，小数点前面或后面至少得有一个数字。如果是科学记数法的话，e 后面至少跟着一个数字。常量中不能有空白字符或其他字符。注意，前导的 `+` 或 `-	` 不被认为是常量的一部分，而被认为是一个操作符。

​		下面是一些合法的数字常量的例子：

```sql
42
3.5
4.
.001
5e2
1.925e-3
```

​		一个既不包含小数点又不包含科学记数法法标记(e)的数字常量，如果大小在 `interger(32 bits)`范围内，那它被推断为 `interger` 类型；否则，若如果大小在 `bigint(64 bits)` 范围内，则被推断为 `bigint` 类型；如果两者都不是，它被当作 `numeric` 类型。如果一个数字常量包含小数点或科学记数法标记或两者都包含，则它被推断为 `numeric` 类型。

​		初始就赋予了数据类型的数字常量将会为系统用何种解析算法提供指引。但大部分情况下，数字常量被强制解析为根据上下文判断出的最合适的数据类型。如有必要，你可以通过强制类型转换来让一个数字常量被解析为指定的数据类型。例如，你可以强制让一个数字常量被当作 `real` 类型：

```sql
REAL '1.23'  -- string style
1.23::REAL   -- PostgreSQL (historical) style
```

​		实际上，上述这些只是接下来要讨论的一般强制类型转换语法的一些特殊例子。



##### 4.1.2.7 其他类型的常量

​		一个任意类型的常量，可以用下列的语法输入：

***type*** '***string***'
'***string***'::***type***
CAST ( '***string***' AS ***type*** )

​		字符串常量的文本被传递给 ***type*** 类型的解析函数。解析的结果是一个 indicated 类型的常量。在关于常量是某个数据类型没有二义性的情况下，显式的数据类型转换可以被省略，(例如，当直接把常量赋值给一个列的时候)，在这种情况下，常量被自动强制转换。

​		字符串常量可以用一般的SQL语法，也可以用 dollar-quoting。

​		也可以用一种类似函数调用的语法来实现数据类型强制转换：

***typename*** ( '***string***' )

​		但不是所有数据类型都支持这种函数调用式的写法；具体看 [Section 4.2.9](https://www.postgresql.org/docs/13/sql-expressions.html#SQL-SYNTAX-TYPE-CASTS)。

​		`::` 、 `CAST()`和 函数调用式语法 也可以被用来指定任意表达式的<u>运行时类型(run-time type)</u>，这在 [Section 4.2.9](https://www.postgresql.org/docs/13/sql-expressions.html#SQL-SYNTAX-TYPE-CASTS) 中被讨论。为了避免句法二义性，***type*** '***string***' 语法仅仅被用来指定简单的字面常量的类型。***type*** '***string***' 语法的另一个限制是不能应用于数组类型；使用 `::` 或 `CAST()` 来指定数组常量的类型。

​		`CAST()` 语法和SQL标准是一致的。***type*** '***string***' 语法是 SQL 标准的泛化：SQL 仅为一小部分数据类型应用这种语法，但是 pg 允许它应用于所有的数据类型。`::` 语法是 pg 的历史用法，函数调用式语法也是这样。



#### 4.1.3 操作符

​		一个操作符的名字是由下列字符组成的、长度不超过  `NAMEDATALEN-1`(默认是63)的字符序列：

```sql
+ - * / < > = ~ ! @ # % ^ & | ` ?
```

 		操作符名字还有一些限制：

* `--` 和 `/*` 不能出现在操作符名字中，因为它们会被当作注释的起始标志。

* 一个多字符的操作符名字不能以 `+` 或 `-` 结尾，除非名字中包含至少一个下列字符：

  ```sql
  ~ ! @ # % ^ & | ` ?
  ```

  例如，`@-` 是一个合法的操作符名字，但是 `*-` 是非法的。这个限制使得 pg 可以解析 SQL 兼容的查询而无需在 token 两边包含空格。



​		当使用非 SQL 标准的操作符时，你需要将临近的操作符用空格分开来避免二义性。例如，如果你定义了一个名字为 `@` 的一元左操作符，你不能写出 `X*@Y`；你必须写成 `X* @Y` 来保证 pg 把它当作两个操作符，而非一个。



#### 4.1.4 特殊字符

​		一些非 alphanumeric 字符拥有一些与操作符不同的意义。xxx。这个小节的存在仅仅是告诉你这些字符的存在和总结它们的目的。

* 美元标志 (`$`) 紧跟着数字，被用来表示可选的参数在一个函数定义里或者一个预编译语句(prepared statement)中。在其他上下文中，`$` 可能是 identifier 的一部分或者是一个 dollar-quoted 字符串常量。
* 括号 (`()`) 的通常意义是将表达式组织起来并提升优先级。在一些情况下，`()` 被用于某些特定 SQL  command 的一些固定语法。
* 方括号 (`[]`) 被用于从数组中选择元素。更多关于数组的信息在 [Section 8.15](https://www.postgresql.org/docs/13/arrays.html)。
* 逗号 (`,`) 被用于一些句法结构，用于将列表中的元素分隔开。
* 分号 (`;`) 备用于终止一个 SQL command。它不能出现在 SQL command 的其他位置，在字符串常量中或在带引号的 identifier 中除外。
* 冒号 (`:`) 被用于从数组中选择切片。(详见 [Section 8.15](https://www.postgresql.org/docs/13/arrays.html)) 在具体的 SQL 方言中(例如 Embedded SQL)，冒号被用于当作变量名的前缀。
* 星号 (`*`) 被用于在一些上下文中表示一个 table row 的所有列或者复合值。在作为聚合函数参数的时候，它还有个特殊意义，表示聚合函数不需要任何显式的参数。
* 小数点 (`.`) 被用在数字常量中，还被用来分隔 schema，table 和 column 的名字。



#### 4.1.5 注释



#### 4.1.6 操作符优先级

​		
