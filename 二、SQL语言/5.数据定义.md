

### 5.1 表的基础知识

英文：https://www.postgresql.org/docs/13/ddl-basics.html

​		关系型数据库中的表非常像我们打印在纸上的表格：由行和列构成。列的数量和顺序是固定的，每个列都有个名字。行的数量是变化的 - 这表示某个时刻表中所存储的数据。SQL 并不保证查出来的行的顺序。当读取一个表的时候，行将会以顺序未定义的情况出现，除非显式指定了排序。这在 [Chapter 7](https://www.postgresql.org/docs/13/queries.html) 中被描述。进一步，SQL 也不会为每一行做唯一约束，所以一个表中可能有完全相同的行。这是基于 SQL 的数学模型必然的结果，但这可能不是我们想要的。在后续的章节里，我们会讨论怎么处理这种情况。

​		每个列都有数据类型。数据类型包含了能赋值给列的可能的值的集合，也赋予了存储在列中的数据以语义以便于被用作运算。一个例子，被声明为一个数字类型的列不能接受任意字符串值，而且这个列的存储的值可以被用来进行数学运算。与之形成对比的是，被声明为字符串类型的列能接受几乎所有类型的数据但并不能让它自己用于数学计算，即使其他的操作像字符串粘接是允许的。

​		pg 内置了很多的数据类型，能适应大部分应用程序。用户也可以自定义数据类型。大部分内置数据类型拥有明显的名字和语义，所以我们后续在 [Chapter 8](https://www.postgresql.org/docs/13/datatype.html) 详细解释。最常用的数据类型有 `integer` 对于整数，`numeric` 对于小数，`text` 对于字符串，`date` 对于日期，`time` 对于时间值，`timestamp` 对于同时包含日期和时间的值。

​		要创建一个表，可以用 `CREATE TABLE` 命令。在这个命令中，至少要为新表指定一个名字，列的名字和数据类型。例如：

```sql
CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);
```

​		上述 SQL 创建一个叫 `my_first_table` 的表，有两个列。第一个列 `first_column` 数据类型为 `text`；第二个列 `second_column` 数据类型是 `integer`。表名与列名遵循标识符语法规则(在 [Section 4.1.1](https://www.postgresql.org/docs/13/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS) 中描述)。数据类型的名字也是标识符，但也有一些例外。注意列的列表是用逗号分开的，并且被圆括号括起来。

​		当然，前面的例子太刻意了。正常情况下，你赋予表和列的名字会暗示其存储什么种类的数据。所以更接近现实的 SQL 是：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);
```

 		(`numeric` 类型可以存储小数，典型的应用是存储金钱数量。)

> **Tip**
>
> ​		当你要创建大量互相有联系的表时，对表名和列名使用一种统一的命名模式是非常有用的。例如，使用单数或复数形式的表名，这两种形式都有支持的理论家。

​		一个表包含的列的个数是有上限的。根据列的类型，列的个数在 250 到 1600 之间。然后，定义一个包含很多列的表大概率是不常见的且是有问题的设计。

​		如果某个表不用了，你可以用 `DROP TABLE` 命令删除它。例如：

```sql
DROP TABLE my_first_table;
DROP TABLE products;
```

​		尝试删除一个不存在的表会导致报错。然而，在创建表前进行无条件地删除而忽略报错在 SQL 脚本中是非常普遍的，所以无论这个表是否存在这个脚本都能工作。(如果你喜欢，你可以用 `DROP TABLE IF EXISTS` 来避免报错，但不是SQL标准。)

​		如果你需要修改一个表的结构，看 [Section 5.6](https://www.postgresql.org/docs/13/ddl-alter.html)。

​		使用到目前为止我们讨论的工具，你已经可以创建一个完全有实际意义的表。这个章节的后续部分是关于为表定义添枝加叶，来保证数据的完整性，安全性，或者易用性。如果你急着向表里添加数据你可以跳到 [Chapter 6](https://www.postgresql.org/docs/13/dml.html) 读这个章节的后面部分。