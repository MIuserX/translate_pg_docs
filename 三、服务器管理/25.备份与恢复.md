		就所有数据都是有价值的角度来说，PostgreSQL 数据库应该周期性的备份。这个过程很简单，清晰地理解下层的技术和假设是非常重要的。

​		存在三个原理不同的方式，来备份 PostgreSQL：

* SQL dump
* 文件系统级别备份
* 持续归档



​		每个方式都有自己的长处和缺点；下面的小节中会讨论他们。



## 25.1 SQL dump

​		这个 dump 方法的思想是：生成一个由 SQL 命令组成的文件，当在 pg 服务器上执行时，将会重建一个与 dump 时一致状态的 database。PostgreSQL 提供了工具程序 pg_dump 。这个命令的基本使用方法：

```bash
pg_dump dbname > dumpfile
```

​		如你所见，pg_dump 把结果输出到标准输出。我们将在下面看到这很有帮助。上面的命令创建一个文本文件，pg_dump 可以创建文件以其他的对于对象的重新存储更容易控制和允许并行的格式。

​		pg_dump 是一个常规的 PostgreSQL 客户端程序()。这意味着你可以在任何远程主机上执行备份过程。但要记得，pg_dump 不会以特殊权限操作。具体的，它必须拥有你想备份的所有的表的读权限，所以为了能备份整个 database，你几乎不可不以超级用户来运行它。(如果你没有权限备份整个 database ，但你仍可以使用 `-n schema` 或 `-t table` 来备份你拥有权限的部分。)

​		要指定数据库服务器的地址，使用命令行选项 `-h host` 和 `-p port` 。默认的主机是本地主机或 `PGHOST` 环境变量指定的。与之相似，默认的端口号由环境变量 `PGPORT` 或者内置的默认端口号。（方便地，服务器将会正常拥有内置默认的端口号。）

​		像其他的 PostgreSQL 客户端一样，pg_dump 默认连接与当前系统用户名字一致的数据库，使用的用户名也与当前系统用户名一致。要覆盖这个，使用 `-U` 选项或设置 `PGUSER` 环境变量。记住 pg_dump 连接也适用正常的客户端认证方法（看 [Chapter 20](https://www.postgresql.org/docs/13/client-authentication.html)）。 

​		pg_dump 相对于其他备份方法一个重要的优点是，pg_dump 的输出可以被新版本的 PostgreSQL 所识别，而文件系统级别备份和持续归档只是服务器版本限定的。pg_dump 也是唯一的方法，将数据传送到机器架构不同的地方，例如 32位服务器到 64位服务器。

​		pg_dump 创建的 dump 是具有一致性的，这意思是，这个 dump 是 database 在 pg_dump 开始运行时的一份快照。pg_dump 运行时不会锁住在 database 上的其他操作。(例外是哪些需要 exclusive 锁的操作，例如 `ALTER TABLE` 的大部分形式。)



### 25.1.1 从 dump 中恢复

​		pg_dump 创建的文本文件一般被 psql 读取。重新存储一份 dump 的一般的命令形式是：

```bash
psql dbname < dumpfile
```

​		`dumpfile` 是 pg_dump 命令输出的文件。`dbname` 所指定的 database 不会被创建，所以你必须自己创建它，在执行 psql 命令前（例如，使用 `createdb -T template0 dbname`）。psql 支持与 pg_dump 类似的选项，来指定数据库服务器和数据库用户名。看 [psql](https://www.postgresql.org/docs/13/app-psql.html) 参考页获取更多的信息。非文本文件 dump 被重新存储使用 [pg_restore](https://www.postgresql.org/docs/13/app-pgrestore.html) 工具。

​		在重新存储一份 SQL dump 前，所有这些对象的所有者用户或者被授予了在这些对象的权限的用户也必须事先存在。如果不存在，重新存储的操作将无法创建与原先权限和所有者一致的对象。（有时这是你想要的，但实际上不是这样的。）

​		默认情况下，psql 将会持续执行在碰到一个 SQL 错误时。你可能想要运行 psql 时使用 `ON_ERROR_STOP` 变量被设置来改变这个行为，这时，psql 碰到 SQL 错误时将会退出，返回码为 3：

```
psql
```



## 25.2 文件系统级别备份



## 25.3 持续归档与时间点恢复(Point-in-time Recovery, PITR)

​		PostgreSQL 一直维护着一个 ***write ahead log(WAL)*** 在 `pg_wal/` 子目录下。这个日志记录了对数据库文件的每个变化。这个日志存在的目的主要是防止 crash：如果系统 crash，可以通过 “重放” 自从上次 checkpoint 以来的日志记录将数据库推到一个一致性的状态。然而，这份日志的存在使得使用第三种备份策略变为可能：我们可以将一个文件系统级别的备份和 WAL 文件的备份结合起来。如果需要恢复，我们重新存储文件系统级别备份，然后重放 WAL 备份中的 WAL 文件，将系统推到一个一致性的状态。这个方式相对于前述的方式更加复杂，但它有几个明显的优势：

* 我们不需要



### 25.3.1 设置 WAL 归档

​		在抽象意义上，一个运行的 PostgreSQL 服务器产生一个无限长的 WAL 记录的序列。数据库系统物理地将这些序列分为



### 25.3.2 制作基础备份

​		制作基础备份最简单的方法是使用 [pg_basebackup](https://www.postgresql.org/docs/13/app-pgbasebackup.html) 工具。它可以创建一个基础备份

​		--

​		要使用这个基础备份，你需要保留在文件系统备份生成期间和生成后的记录的所有 WAL 文件。为了帮助你做到这一点，base backup 进程创建了一个 ***backup history file***，这个文件会立刻保存到 WAL 归档区域。这个文件的名字是你的文件系统备份的需要的第一个 WAL 文件的名字。例如，如果开始 WAL 文件是 `0000000100001234000055CD` ，backup history file 的名字将会是类似 `0000000100001234000055CD.007C9330.backup` （）。



### 25.3.4 用持续归档备份恢复

​		好了，最坏的情况发生了，你需要从备份中恢复。下面是步骤：

1. 如果数据库服务器在运行，停止它。
2. 如果磁盘空间足够，拷贝整个数据目录和所有 tablespace 到一个临时位置，以防你后续需要他们。注意这个步骤需要你的磁盘拥有足够的空间来存储当前数据库的拷贝两份。如果你没有足够的空间，你应该至少保存 `pg_wal` 子目录里的内容，因为它可能保存了在系统关闭前还没有归档的日志。
3. 移除数据根目录下的所有的文件和子目录和所有 tablespace 根目录下的所有文件和子目录。
4. 从你的文件系统备份中恢复所有的数据库文件。保证它们被以正确的所有者(数据库系统用户，而不是root！) 和权限来存储。如果你使用了 tablespace，你应该确认 `pg_tblspc/` 的软连接被正确恢复了。
5. 移除 `pg_wal/` 下的所有当前文件；这些来自文件系统备份并且因此可能是绝对的而不是当前的。如果你一点也没有归档 `pg_wal/`，这时重建它以合适的权限，小心保证你重建它用一个软连接，如果你之前已经设置了的话。
6. 如果你还有 WAL 文件未归档在第2步保存的那些，将它们复制到 `pg_wal/` 。(最好是复制它们，而不是移动它们，这样你还拥有未修改的文件，如果发生了问题你还能继续第二次。)
7. 在 `postgresql.conf` 中设置恢复配置（看 [Section 19.5.4](https://www.postgresql.org/docs/13/runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVE-RECOVERY)）并创建文件 `recovery.signal` 在数据目录里。你也可能想要临时地修改 `pg_hba.conf` 来防止原来的用户连接数据库，直到你确认数据恢复成功了。
8. 启动数据库服务器。服务器将会进入恢复模式并读取 WAL 文件如果需要的话。除非恢复被意外的错误终止，服务器可以重启，它将会继续恢复。当恢复过程完成后，服务器会移除 `recovery.signal` 文件(防止后面意外地再次进入恢复模式) 并且开始正常的数据库操作。
9. 检查数据库的内容，确保你恢复到了想要的状态。如果没有，回到第一步。如果一些正常，编辑 pg_hba.conf 允许用户正常连接数据库。



​		这些步骤的关键部分是设置恢复配置，这些配置描述你想怎样恢复、恢复到什么位置。你绝对要指定的是 `restore_command`，这告诉 PG 怎样获取归档的 WAL 文件。像 `archive_command` 那样，这也是个命令行字符串。它可以包含 `%f` ，`%f` 会被需要的 WAL 文件名所替代，还可以包含 `%p`，`%p` 会被 WAL 归档的路径所替换。(路径名是相对于当前目录的，例如，数据库数据目录。) 如果你需要嵌入 `%` ，写成 `%%` 形式。最简单的命令形式像：

```sql
restore_command = 'cp /mnt/server/archivedir/%f %p'
```

 		这个命令将会从 `/mnt/server/archivedir/` 目录中复制归档的 WAL 文件。当然，你可以用一些更复杂的，或许是一个需要挂一个合适的胶带的 shell 脚本。

​		当命令失败时返回一个非零的返回值是非常重要的。当需要的WAL 不在归档目录时，这个命令被调用时应该返回非零。这不是一个错误情况。一个异常情况时，当这个命令被信号终止时（像 SIGTERM，被用来关闭数据库）或者 shell 的一个错误(例如找不到命令)，这时，恢复会被打断，数据库将不会启动。

​		不是所有要求的文件都是 WAL 文件；你也需要以 `.history` 结尾的文件。也要意识到 `%p` 中的名字会和 `%f` 中的不同；不要想着 `%p` 和 `%f` 是可以交换的。

​		在归档目录中找不到 WAL 文件会在 `pg_wal/` 下寻找；这允许使用最近的未归档的 WAL 文件。然而，归档目录下的文件比 `pg_wal/` 下的具有跟高的优先级。

​		正常情况下，恢复会经过所有的 WAL 文件，从而将数据库带到当前时间点（或者尽可能给予可能的 WAL 文件）。因此，一个正常的恢复将会终止于 "file not found" 信息，这个错误消息的具体文本取决于你的 `restore_command` 设置。你也可能在恢复的开始就看到一个错误信息因为一个名字类似 `00000001.history` 的文件。这也是正常的，并不意味着出了问题，在简单的恢复环境下；看 section 25.3.5 的讨论。

​		如果你想恢复到之前的时间点（这是说，刚在二把刀DBA删掉你的主业务表之前的时间点），指定需要的 [stopping point](https://www.postgresql.org/docs/13/runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET)  。你可以指定停止点，就是 "recovery target"，可以是 date/time、命名的重新存储点、或者事务ID。这些停止点中 date/time 和 命名的停止点是有用的，因为没有工具帮你确认使用哪个事务ID。

> **Note**
>
> ​		停止点必须在 basebackup 完成时间点之后，例如，pg_stop_backup 之后。你不能使用一个基础备份恢复到它在进行基础备份过程中的某个时间点。（要恢复到这样一个时间点，你必须使用更靠前的基础备份，然后恢复到那里。）

​		如果恢复发现打断的 WAL 数据，恢复将会卡在那个点，数据库实例不会启动。在这种情况下，恢复过程可以从开始重新运行，指定一个更靠前的停止点，这样恢复可以正常完成。如果恢复因为一个外部原因失败，例如 OS crash或 WAL 突然不能访问了，这时只需重启恢复，恢复就会从失败的地方继续开始。恢复重启工作的原理类似于正常操作中的 checkpoint：数据库周期性地强制将状态输出到磁盘，然后更新 `pg_control` 文件，表示早已处理的 WAL 数据不需要再扫描一次了。