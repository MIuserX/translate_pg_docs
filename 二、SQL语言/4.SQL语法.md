### 4.1 词法结构
​		词法结构：https://www.postgresql.org/docs/13/sql-syntax-lexical.html



​		SQL输入是一个 **command** 序列。一个 **command** 由一系列 **token** 组成，以 ; 结束。 输入流的终止也是 command 的结束。哪些 token 在一个 command 中是合法的取决于具体的 command 语法。

​		一个 token 可能是个**关键字(keyword)**、**标识符(identifier)**、**quoted identifier**、**literal(或者 constant)**、特殊的字符符号。token 一般被空白字符分隔(空格、tab、换行)，但是如果没有二义性的话也可以不用空白字符分隔()。

​		例如，下列的SQL是(在句法上)合法的：

```sql
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');
```

​		这是一个由3个 SQL command 组成的序列，一个 command 占一行(虽然一个command占一行不是必须的；一行可以写多个command，一个command也可以被分成多行)。

​		另外，注释(comments) 也可以出现在 SQL 中。注释不是 token，它们在效果上等同于空白字符。

​		SQL 语法在关于哪个 token 确定一个 command、哪个是操作数(operands)、哪个是参数(parameters)的问题上是不完全一致的。开头的一些 token 一般是 command 的名字，所以在刚才讨论的那个例子中，我们可以说，一个 "SELECT"，一个 "UPDATE"，和一个 "INSERT"。但对于 UPDATE ，一定需要一个 SET token 出现在指定的位置上，而对于 INSERT，总是需要一个 VALUES token 才算完整。具体的语法细节可以查看 [Part VI](https://www.postgresql.org/docs/13/reference.html)。

​		

#### 4.1.1 标识符和关键字

​		上面例子中诸如 `SELECT`, `UPDATE` 或 `VALUES` 的 token 被称为 **关键字(keywords)**，这是说，这些 token 在 SQL 语言中具有固定的意义。`MY_TABLE`  和  `A`  这俩 token 被称为 **标识符(identifiers)**。标识符表示 表、列 或者其他数据库对象的名字，具体取决于它们被用于哪种 SQL command 中。因此，标识符又是被简单的叫做 "名字(names)" 。keywords 和 identifiers 具有相同的词法结构，所以，在我们不了解它所属的语言的话，我们不知道一个 token 到底是 keyword 还是 identifier 。完整的 SQL keywords 列表可以在 [Appendix C](https://www.postgresql.org/docs/13/sql-keywords-appendix.html) 中找到。

​		SQL keywords 和 identifiers 必须以一个字符(`a-z,A-Z`)或一个下划线开头(`_`)。后续的字符可以是 字母(`a-z,A-Z`)、下划线(`_`)、数字字符(`0-9`) 或者美元标志(`$`)。要注意的是，SQL 标准并不允许 identifiers 中包含 $(***译者注：允许 $ 是 pg 对 SQL 的扩展***)，使用 $ 会降低你的应用程序的兼容性。SQL 标准不会定义一个 包含数字字符或以下划线开头或以下划线结尾的 keyword，所以具有这种形式的 identifier 是安全的，不用担心会这会与未来的 SQL 标准冲突。

​		pg 使用的 identifier 的长度不超过  `NAMEDATALEN-1` 个字节；超过这个长度的 identifier 允许被输入，但会被截断。默认情况下，`NAMEDATALEN` 是 64，所以，identifier 最长是 63 字节。如果这个限制对你造成困扰，你可以在源码文件 `src/include/pg_config_manual.h` 增大 `NAMEDATALEN` 。(***译者注：这需要你重新编译***)。

​		keywords 和 unquoted identifiers(无引号的标识符) 是大小写**<span style="color:red">不</span>**敏感的。因此，下列两个 SQL command 是等价的：

```sql
UPDATE MY_TABLE SET A = 5;

uPDaTE my_TabLE SeT a = 5;
```

​		一个常用的约定是，将 keywords 大写，将 names 小写，例如：

```sql
UPDATE my_table SET a = 5;
```

​		还有一种 identifier：delimited identifier(有界的标识符) 或者说 quoted identifier(有引号的标识符)。它的形式是，由双引号(`"`) 括起来的一个任意的字符序列。一个 delimited identifier 就是一个 identifier，不可能是一个 keyword。所以 `"select"` 可能表示一个表或一个列的名字叫做 "select"，因此，一个无引号的 select 就是一个 keyword，如果被用在本该是个表名或列名的位置上，就会触发一个语法错误。上面的例子可以被重写为如下形式：

```sql
UPDATE "my_table" SET "a" = 5;
```

 		quoted identifiers 可以包含任何字符，`0` code 除外。(如果需要包含一个双引号，将双引号写两遍)。这允许你构造出那种几乎不可能的表名或列名，例如，名字可以包含空格或者 `&` 符号。但也要受 `NAMEDATALEN` 的限制。

​		将一个 identifier 用引号括起来，也令它变地**大小写敏感**，相对地，没有用引号括起来的 identifier 被视为是小写。例如，标识符 `FOO`、`foo` 和 `"foo"` 在 pg 看来是等价的，但是 `Foo` 和 `"FOO"` 与前面3个例子的值是不等价的。(pg 将 unquoted identifiers 视为小写与 SQL 标准是不兼容的，因为 SQL 标准将 unquoted identifiers 视为大写。因此，根据 SQL 标准来讲，`foo` 和 `"FOO"` 是等价的，而不是 `"foo"`。如果你想写出兼容的应用程序，建议你全使用 quoted identifiers 或者全使用 unquoted identifiers)。

​		quoted identifiers 的另一种变体可以包含以码点(code points)表示的 Unicode 转义字符。这种变体以 `U&` 开头(U大写或小写都是可以的)，后面紧跟着双引号(`U&` 和 `"` 之间不能有空格)，例如，`U&"foo"`。(要注意的是，这个语法给操作符 `&` 带来了歧义。可以在操作符 `&` 两边加上空格来避免这种歧义。) 在引号中，Unicode 字符可以用转义形式来表示，转义形式是：一个反斜杠，后面跟着一个4位的16进制数字；或者一个反斜杠，后面跟着一个 `+` 号，再跟着一个6位的16进制数字。例如，identifier `"data"` 可以被写成：

```sql
U&"d\0061t\+000061"
```

​		下面这个例子，将俄罗斯词语 `"slon"`以古斯拉夫字符写出：

```sql
U&"\0441\043B\043E\043D"
```

​		如果你想用其他字符代替 `\` 来作为转义字符，可以在字符串之后用 `UESCAPE` 子句，例如：

```sql
U&"d!0061t!+000061" UESCAPE '!'
```

​		转义字符可以是任何一个除 ***16进制数字字符(`0-9`, `a-f`, `A-F`)、加号字符(`+`)、单引号字符(`'`)、双引号字符(`"`)、空白字符(空格, tab, 换行符)***之外的的任意单字符。注意，`UESCAPE` 后指定的转义字符是用单引号括起来的，而不是双引号。

​		如果想在 identifier 中包含转义字符的字面值，把它写两次。

​		无论是4位的还是6位的转义都可以被用来指定 UTF-16 码对来组成码点超过 U+FFFF 的字符，但对于6位的转义这是不必要的。(替代对不会被直接存储，会被组成一个单码点。)

​		xxx

​		如果服务器的编码不适 UTF-8，Unicode 码点将会被转换为实际的服务器编码；如果无法转换将会报错。



#### 4.1.2 常量

​		在 pg 中有3种隐式输入的常量：字符串、bit strings 和 数字。常量可以被显式的输入，这可以使表达更加精确，也可以使系统处理更加高效。这两种形式都将在下面的子章节中被讨论。



##### 4.1.2.1 字符串常量

​		SQL 中的字符串常量是一个被单引号括起来的任意字符串，例如 `'This is a string'`。要在一个字符串常量中包含单引号，将它写两次即可。例如 `Dianne''s horse`。注意，这不是双引号，和双引号也是不同的。

​		两个被至少包含一个换行符的空白字符分隔开的字符串常量会被连接在一起，被当作一个字符串常量对待。例如：

```sql
SELECT 'foo'
'bar';
```

​		上面的例子等价于：

```sql
SELECT 'foobar';
```

​		但是：

```sql
SELECT 'foo'      'bar';
```

​		是非法的语法。(这个有些奇异的行为是 SQL 标准规定的；pg 遵循了标准。)



##### 4.1.2.2 带有 C 风格的字符串常量

​		pg 也接受带有转义字符的字符串常量，这是 pg 对 SQL 标准的扩展。一个带有转义字符的字符串常量形式为：以 `E` 开头的(大小写都行)，紧接着就是单引号，例如 `E'foo'`。(当要包含转义字符的字符串跨越多个行，仅仅在第一个单引号的前面带 `E`。) 在一个转义字符串里，反斜杠(`\`) 打头，引出一个类 C 风格的 **反斜杠转义序列**，在这种语法里，反斜杠和紧跟着它的若干个字符表示一个特殊字节的值，下表所示：

| 反斜杠转义序列                   | 解释                         |
| -------------------------------- | ---------------------------- |
| `\b`                             | Backspace                    |
| `\f`                             | form feed                    |
| `\n`                             | 换行                         |
| `\r`                             | 回行首                       |
| `\t`                             | Tab                          |
| `\o, \oo, \ooo (o=0-7)`          | 8进制                        |
| `\xh, \xhh (h=0-9,A-F)`          | 16进制                       |
| `\uxxxx, \Uxxxxxxxx (x=0-9,A-F)` | 16或32 位16进制 Unicode 字符 |

​		除上面表中列出的字符，有其他任何字符跟在反斜杠后，都被解释为字面值。因此，要包含一个反斜杠字符，将它写两次。同时，在一个转义字符串里，也可以用 `\'` 来包含一个单引号。

​		确保你写的字节序列，特别是使用了8进制或12进制转义语法的，对于 pg server 的编码是合法的，是你的责任。一个好的习惯是使用 Unicode 转义字符串或者使用 Unicode 转义语法(在 [Section 4.1.2.3](https://www.postgresql.org/docs/13/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS-UESCAPE))；这时 pg server 会对你的输入做一个检查。

>注意：
>
>​		如果配置参数 `standard_conforming_strings` 是关闭状态，pg server 能识别转义字符串和正常字符串中的反斜杠转义语法。然而，pg 9.1 默认是开启的，这意味着反斜杠转义语法仅仅在转义字符串中被识别。这种行为是更具有SQL标准兼容性的，但可能会将依赖于早期 pg 默认行为的应用程序搞砸。一个变通方案是，设置上述参数为关闭，但最好是不要用反斜杠转义。如果你需要使用反斜杠转义来表达一个字符，在字符串常量前面带个 `E`。
>
>​		另外，`escape_string_warning` 和 `backslash_quote` 也能管理字符串常量中的反斜杠的行为。

​		

##### 4.1.2.3 带有 Unicode 转义字符的字符串常量

​		pg 也支持其他类型的用码点(code points)来指定 Unicode 字符的转义语法。一个 Unicode 转义字符串常量以 `U&` 开头(u大小写都可以)，后面紧跟着单引号，`U&` 与 单引号之间不能有任何空白字符，例如 `U&'foo'`。(注意，这种语法给操作符 `&` 带来了二义性。可以在使用操作符 `&` 时在两边加上一些空格来避免。) 在单引号内，可以用 `\` 后跟4位的16进制数字 或 `\+` 后跟6位的16进制数字表示的码点这两种转义形式来表示 Unicode 字符。 例如，`'data'` 可以写为：

```sql
U&'d\0061t\+000061'
```

​		下面这个例子，将俄罗斯词语 `"slon"`以古斯拉夫字符写出：

```sql
U&'\0441\043B\043E\043D'
```

​		如果你想用其他字符代替 `\` 来作为转义字符，可以在字符串之后用 `UESCAPE` 子句，例如：

```sql
U&'d!0061t!+000061' UESCAPE '!'
```

​		转义字符可以是任何一个除 ***16进制数字字符(`0-9`, `a-f`, `A-F`)、加号字符(`+`)、单引号字符(`'`)、双引号字符(`"`)、空白字符(空格, tab, 换行符)***之外的的任意单字符。

​		如果想在 identifier 中包含转义字符的字面值，把它写两次。

​		xxx

​		如果服务器的编码不适 UTF-8，Unicode 码点将会被转换为实际的服务器编码；如果无法转换将会报错。

​		同时，Unicode 转义语法仅当配置 `standard_conforming_strings` 开启的时候才生效。因为这语法会让客户端感到困惑，可能会把这种 SQL 当作是 SQL注入或者有类似问题的危险SQL。如果这个参数没有开启，这种语法会被报错。



##### 4.1.2.4 Dollar-Quoted 字符串常量

​		虽然SQL标准的字符串常量语法用起来很方便，但当其中包含很多单引号和反斜杠时将变得非常难以理解，因为每个单引号和反斜杠都要被写两次。在这种背景下，pg 为了支持可读性更高的查询语句，提供了一种叫做 "**dollar quoting**" 的语法来写字符串常量。一个 dollar-quoted 字符串常量由：一个 `$` 符号，后跟着一个由零或多个字符构成的 tag，后再跟一个 `$` 符号，再跟着一个任意字符序列，再一个 `$` 符号，将前面的 tag 再重复一遍，最后再是一个 `$` 符号。例如，下面用两种方法写出 `Dianne's horse`：

```sql
$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$
```

​		注意上面的例子，在 dollar-quoted 字符串中，单引号没有使用转义写法。实际上，没有那个字符在 dollar-quoted 字符串中被转义，一切都是字面值。反斜杠也不是特殊字符，`$` 字符也不是，除非它们是 tag 的一部分。

​		在嵌套的 dollar-quoted 字符串中，不同层次的 tag 可以不同。这常被用在定义函数上。例如：

```sql
$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$
```

​		上面的例子中，`$q$[\t\r\n\v\\]$q$` 表示字面值 `[\t\r\n\v\\]`，将会在函数执行的时候被 pg 准确识别。但是，因为这个字符序列并不等于外部 dollar quoting 的终止序列 `$function$`，it is just some more characters within the constant so far as the outer string is concerned.

​		tag 是遵循一些规则的，它是一个不带引号的标识符(unquoted identifier)，但是它不能包含一个 `$` 字符。tag 是打小写敏感的，所以 `$tag$String content$tag$` 是合法的，但 `$TAG$String content$tag$` 是不合法的。

​		一个 dollar-quoted 字符串如果后面跟着一个 keyword 或者 identifier，一定要用空白字符与之分隔开；否则，dollar quoting 的终止序列的前导标识符(preceding identifier)的一部分。

​		dollar quoting 不是SQL标准的一部分，但它通常是写负责字符串字面值的方便的方法，相较于标准的单引号语法。在一个常量中表示字符串常量时，这非常有用，特别是在定义存储过程函数时。使用单引号语法，上面例子中的反斜杠就会被写4次，在分析原始的常量时它被认为是两个，在函数执行时，内部字符串分析时，反斜杠被认为是一个。



##### 4.1.2.5 Bit-String 常量

​		bit-string 常量看起来像前面加了个 `B` (大小写都行)的一般的字符串常量。例如，`B'1001'`。bit-string 常量中仅允许字符 `0` 和 `1`。

​		另外，bit-string 常量也可以用16进制符号来表示，格式是使用一个前缀 `X` (打小写都行)。例如，`X'1FF'`。这种符号跟一个16数字替换为4个二进制数字的 bit-string 常量是等价的。

> 译者注：
>
> 十六进制数字 `1F`，转换为二进制是 `00011111`。即 `X'1F'` 等价于 `B'00011111'`。

​		两种形式的 bit-string 常量都可以写成跨多行的形式，就行一般的字符串常量那样。dollar quoting 不能被应用于 bit-string 常量。



##### 4.1.2.6 数字常量

​		数字常量被接受为如下形式：

***digits***

***digits***.\[***digits***\]\[e\[+-\]***digits***\]

\[***digits***\].***digits***\[e\[+-\]***digits***\]

***digits***e\[+-\]***digits***

​		`digits` 由1或多个十进制数字(0到9)组成。如果是小数的话，小数点前面或后面至少得有一个数字。如果是科学记数法的话，e 后面至少跟着一个数字。常量中不能有空白字符或其他字符。注意，前导的 `+` 或 `-	` 不被认为是常量的一部分，而被认为是一个操作符。

​		下面是一些合法的数字常量的例子：

```sql
42
3.5
4.
.001
5e2
1.925e-3
```

​		一个既不包含小数点又不包含科学记数法法标记(e)的数字常量，如果大小在 `interger(32 bits)`范围内，那它被推断为 `interger` 类型；否则，若如果大小在 `bigint(64 bits)` 范围内，则被推断为 `bigint` 类型；如果两者都不是，它被当作 `numeric` 类型。如果一个数字常量包含小数点或科学记数法标记或两者都包含，则它被推断为 `numeric` 类型。

​		初始就赋予了数据类型的数字常量将会为系统用何种解析算法提供指引。但大部分情况下，数字常量被强制解析为根据上下文判断出的最合适的数据类型。如有必要，你可以通过强制类型转换来让一个数字常量被解析为指定的数据类型。例如，你可以强制让一个数字常量被当作 `real` 类型：

```sql
REAL '1.23'  -- string style
1.23::REAL   -- PostgreSQL (historical) style
```

​		实际上，上述这些只是接下来要讨论的一般强制类型转换语法的一些特殊例子。



##### 4.1.2.7 其他类型的常量

​		一个任意类型的常量，可以用下列的语法输入：

***type*** '***string***'
'***string***'::***type***
CAST ( '***string***' AS ***type*** )

​		字符串常量的文本被传递给 ***type*** 类型的解析函数。解析的结果是一个 indicated 类型的常量。在关于常量是某个数据类型没有二义性的情况下，显式的数据类型转换可以被省略，(例如，当直接把常量赋值给一个列的时候)，在这种情况下，常量被自动强制转换。

​		字符串常量可以用一般的SQL语法，也可以用 dollar-quoting。

​		也可以用一种类似函数调用的语法来实现数据类型强制转换：

***typename*** ( '***string***' )

​		但不是所有数据类型都支持这种函数调用式的写法；具体看 [Section 4.2.9](https://www.postgresql.org/docs/13/sql-expressions.html#SQL-SYNTAX-TYPE-CASTS)。

​		`::` 、 `CAST()`和 函数调用式语法 也可以被用来指定任意表达式的<u>运行时类型(run-time type)</u>，这在 [Section 4.2.9](https://www.postgresql.org/docs/13/sql-expressions.html#SQL-SYNTAX-TYPE-CASTS) 中被讨论。为了避免句法二义性，***type*** '***string***' 语法仅仅被用来指定简单的字面常量的类型。***type*** '***string***' 语法的另一个限制是不能应用于数组类型；使用 `::` 或 `CAST()` 来指定数组常量的类型。

​		`CAST()` 语法和SQL标准是一致的。***type*** '***string***' 语法是 SQL 标准的泛化：SQL 仅为一小部分数据类型应用这种语法，但是 pg 允许它应用于所有的数据类型。`::` 语法是 pg 的历史用法，函数调用式语法也是这样。



#### 4.1.3 操作符

​		一个操作符的名字是由下列字符组成的、长度不超过  `NAMEDATALEN-1`(默认是63)的字符序列：

```sql
+ - * / < > = ~ ! @ # % ^ & | ` ?
```

 		操作符名字还有一些限制：

* `--` 和 `/*` 不能出现在操作符名字中，因为它们会被当作注释的起始标志。

* 一个多字符的操作符名字不能以 `+` 或 `-` 结尾，除非名字中包含至少一个下列字符：

  ```sql
  ~ ! @ # % ^ & | ` ?
  ```

  例如，`@-` 是一个合法的操作符名字，但是 `*-` 是非法的。这个限制使得 pg 可以解析 SQL 兼容的查询而无需在 token 两边包含空格。



​		当使用非 SQL 标准的操作符时，你需要将临近的操作符用空格分开来避免二义性。例如，如果你定义了一个名字为 `@` 的一元左操作符，你不能写出 `X*@Y`；你必须写成 `X* @Y` 来保证 pg 把它当作两个操作符，而非一个。



#### 4.1.4 特殊字符

​		一些非 alphanumeric 字符拥有一些与操作符不同的意义。xxx。这个小节的存在仅仅是告诉你这些字符的存在和总结它们的目的。

* 美元标志 (`$`) 紧跟着数字，被用来表示可选的参数在一个函数定义里或者一个预编译语句(prepared statement)中。在其他上下文中，`$` 可能是 identifier 的一部分或者是一个 dollar-quoted 字符串常量。
* 括号 (`()`) 的通常意义是将表达式组织起来并提升优先级。在一些情况下，`()` 被用于某些特定 SQL  command 的一些固定语法。
* 方括号 (`[]`) 被用于从数组中选择元素。更多关于数组的信息在 [Section 8.15](https://www.postgresql.org/docs/13/arrays.html)。
* 逗号 (`,`) 被用于一些句法结构，用于将列表中的元素分隔开。
* 分号 (`;`) 备用于终止一个 SQL command。它不能出现在 SQL command 的其他位置，在字符串常量中或在带引号的 identifier 中除外。
* 冒号 (`:`) 被用于从数组中选择切片。(详见 [Section 8.15](https://www.postgresql.org/docs/13/arrays.html)) 在具体的 SQL 方言中(例如 Embedded SQL)，冒号被用于当作变量名的前缀。
* 星号 (`*`) 被用于在一些上下文中表示一个 table row 的所有列或者复合值。在作为聚合函数参数的时候，它还有个特殊意义，表示聚合函数不需要任何显式的参数。
* 小数点 (`.`) 被用在数字常量中，还被用来分隔 schema，table 和 column 的名字。



#### 4.1.5 注释

​		注释是一个以双横线开头的一直到行尾的字符序列。例如：

```sql
-- This is a standard SQL comment
```

​		另一种方法是 C 风格的注释：

```c
/* multiline comment
 * with nesting: /* nested block comment */
 */
```

​		C 风格的注释以 `/*` 开头，以 `*/` 结束。xxx

​		注释会从输入流中移除在做更深入的语法分析之前，会被替换为空白字符。



#### 4.1.6 操作符优先级

​		下表展示了 pg 中操作符的优先级和关联性。大部分操作符有相同的优先级，并且是左关联的。操作符的优先级和关联性是硬编码在解析器中的。如果你想要一个包好了多个操作符的表达式按照非优先级规则显示地那样分析，你可以用括号。

（下表的操作符优先级依次由高到低）

| 操作符                          | 关联性 | 描述                           |
| ------------------------------- | ------ | ------------------------------ |
| `.`                             | left   | 表名或列名的分隔符             |
| `::`                            | left   | pg风格的数据类型转换           |
| `[ ]`                           | left   | 数组元素选择符                 |
| `+ -`                           | right  | 正负号                         |
| `^`                             | left   |                                |
| `* / %`                         | left   | 乘号，除号，取余               |
| `+ -`                           | left   | 加号，减号                     |
| `(any other operator)`          | left   | 其他原生的或用户自定义的操作符 |
| `BETWEEN IN LIKE ILIKE SIMILAR` |        | 范围，，字符匹配               |
| `< > = <= >= <>`                |        | 比较操作符                     |
| `IS ISNULL NOTNULL`             |        |                                |
| `NOT`                           | right  | 逻辑否                         |
| `AND`                           | left   | 逻辑与                         |
| `OR`                            | left   | 逻辑或                         |

​		注意，操作符优先级规则也被应用在用户自定义的与上述操作符具有相同名字的操作符上。例如，如果你为某些用户自定义数据类型定义了一个 "`+`" 操作符，它将拥有和内置的 "`+`" 操作符拥有相同的优先级，无论你的操走符做了什么。

​		如果一个带有 schema 前缀的操作符名字被使用在 `OPERATOR` 语法中，例如：

```sql
SELECT 3 OPERATOR(pg_catalog.+) 4;
```

 		`OPERATOR` 结构将拥有与上表中 `(any other operator)`操作符一样的优先级。无论哪个操作符出现在 `OPERATOR` 结构中，都将如此。

> **Note**
>
> ​		9.5 之前的 pg 使用了与上表稍微不同的优先级规则。具体的，`<= >=` 和 `<>` 被当作通用操作符；`IS` 测试曾经拥有更高的优先级；`NOT BETWEEN` 和相关的结构的运行都是不兼容的，在一些场景下，被当作拥有 `NOT` 的优先级而不是 `BETWEEN`。这些规则已经被改变了，为了更好的与SQL标准兼容，也为了减少对于逻辑相等操作的前后矛盾的处理方式。在大部分情况下，这些改动不会造成行为的变化，当碰见 "no such operator" 的错误时使用括号解决问题。然而，在有些场景下，SQL 的行为发生了改变，但却不会报告一个语法分析错误。如果你很关心是否有某些东西被默默地改变了，你可以打开配置项 `operator_precedence_warning` ，观察是否有警告日志被记下来。





### 4.2 值表达式(value expressions)

https://www.postgresql.org/docs/13/sql-expressions.html



​		值表达式被用于各种上下文中，例如 `SELECT` 的 select list，`INSERT` 和 `UPDATE` 的新值，很多 SQL commands 的查询条件中。值表达式的结果有时被叫做 **标量(scalar)**，这用于把它和表表达式(table expression，实际就是个表)区分开。因此，值表达式也被叫做标量表达式(或直接叫表达式)。表达式的语法允许值的计算xxx。

​		值表达式有如下类型：

* 一个常量或字面值
* 一个列引用(column reference)
* 一个可选的参数引用，在函数定义里或预编译语句
* 一个下标表达式(subscripted expression)
* 一个域选择表达式(field selection expression)
* 一个操作符调用(operator invocation)
* 一个函数调用(function call)
* 一个聚合表达式(aggregate expression)
* 一个窗口函数调用(window function call)
* 一个数据类型转换(type cast)
* 一个排序规则表达式(collation expression)
* 一个标量子查询(scalar subquery)
* 一个数组构造器(array constructor)
* 一个行构造器(row constructor)
* 位于括号里的另一个值表达式(用于组织子表达式和覆盖优先级)



​		还有些对上表的补充，还有很多不遵循一般语法的但可以被归入表达式的结构。这些结构拥有函数或操作符的语义，在 [Chapter 9](https://www.postgresql.org/docs/13/functions.html) 被讨论。其中一个例子是 `IS NULL` 子句。



#### 4.2.1 列引用(column references)

​		一个列可以被以以下形式来引用：

```sql
correlation.columnname
```

​		`correlation` 是一个表名(可能还带有一个 schema 前缀)，或者是一个表的别名(在 `FROM` 子句里定义的)。在列名是唯一的情况下， `correlation.` 可以被省略。(see also [Chapter 7](https://www.postgresql.org/docs/13/queries.html)) 



#### 4.2.2 可选参数(positional parameters)

​		一个可选参数引用表示某个值是由 SQL 语句外部提供的。形式参数被用于函数定义或预编译语句中。一些客户端也支持分离时的 SQL 语句与参数，形式参数也被用来指代外部的数据值。形式参数引用形式是：

```sql
$number
```

​		例如，定一个函数 `dept`：

```sql
CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;
```

​		上述例子中，`$1` 指代函数的第一个实际参数当函数被调用的时候。



#### 4.2.3 下标

​		如果一个表达式从数组类型获取一个值，数组中某个元素可以用下列写法来表示：

```sql
expression[subscript]
```

​		同时指定多个临近的数组元素(一个“数组切片”)可以用下列写法：

```sql
expression[lower_subscript:upper_subscript]
```

​		(上面的例子中，`[ ]` 表示字面意思) 每个 `subscript` 自身就是表达式，它将会被四舍五入为一个整数。

​		一般，数组表达式必须用括号括起来，但括号是可以省略的，当要使用下标的表达式是个列引用或形式参数。同时，当数组是多维数组时，可以将下标表达式连接来写，例如：

```sql
mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]
```

​		上述例子中，最后一个例子要求必须用圆扣号。要了解更多关于数组的知识，查看 [Section 8.15](https://www.postgresql.org/docs/13/arrays.html)。



#### 4.2.4 域选择

​		当一个表达式从一个复合类型(行类型)中获取值时，行中的某个列可以用下列写法引用：

```sql
expression.fieldname
```

​		一般，***expression*** 必须被用圆扣号括起来，但括号是可以省略的，当要被从中选择的表达式是个表引用或者位置参数。例如：

```sql
mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3
```

​		(因此，一个带前缀的列引用实际上是域选择语法的一个特殊例子。) 一个重要又特殊的例子是从一个是复合类型的列中提取值：

```sql
(compositecol).somefield
(mytable.compositecol).somefield
```

​		上述例子中，圆括号是必须的。`compositecol` 是个列名，`mytable` 是个表名。

​		你可以从一个复合类型中获取所有的域，通过写 `.*`：

```sql
(compositecol).*
```

​		具体的句法会因具体的上下文而有所不同。详情查看 [Section 8.16.5](https://www.postgresql.org/docs/13/rowtypes.html#ROWTYPES-USAGE)。



#### 4.2.5 操作符调用

​		调用操作符有 3 种语法：

***expression operator expression*** (二元操作符 binary inlix operator)

***operator expression*** (一元前缀操作符 unary prefix operator)

***expression operator*** (一元后缀操作符 unary postfix operator)

​		***operator*** token 遵循 [Section 4.1.3](https://www.postgresql.org/docs/13/sql-syntax-lexical.html#SQL-SYNTAX-OPERATORS) 的语法规则，或者是关键字 `AND`, `OR`, `NOT`, 或者是带前缀的操作符形式：

```sql
OPERATOR(schema.operatorname)
```

​		某个具体的操作符存在与否或是一元还是二元操走符取决于系统或用于是如何定义的。[Chapter 9](https://www.postgresql.org/docs/13/functions.html) 描述了内置操作符。



#### 4.2.6 函数调用

​		函数调用的语法是：函数名字(可能带着一个 schema 前缀)，接着一个用圆括号括起来的实参列表：

```sql
function_name ([expression [, expression ... ]] )
```

​		例如，下面的函数调用是求 2 的平方根：

```sql
sqrt(2)
```

​		内置函数列表在 [Chapter 9](https://www.postgresql.org/docs/13/functions.html) 。用户可以自定义函数。

​		在一个用户之间不互相信任的数据库中执行查询时，写函数调用时请遵循安全防御规范 [Section 10.3](https://www.postgresql.org/docs/13/typeconv-func.html)

 。

​		参数可以有名字，也可以没名字。详见 [Section 4.3](https://www.postgresql.org/docs/13/sql-syntax-calling-funcs.html) 。

> **Note**
>
> ​		如果一个函数仅仅有一个参数，且这个参数是复合类型的，这叫做 **使用了域选择语法**，相反，域选择也可以被写为函数式风格。这是说，句法 `col(table)` 与 `table.col` 是可互换的。这种行为不是 SQL标准，仅仅是 pg 提供的，因为这允许使用函数来模仿 "计算的域(computed fields)"。详情请看 [Section 8.16.5](https://www.postgresql.org/docs/13/rowtypes.html#ROWTYPES-USAGE) 。



#### 4.2.7 聚合表达式

​		聚合表达式是指：使用聚合函数计算查询所找到的行。一个聚合函数将多个输入行计算后产生一个输出值，像求和或求平均值。聚合表达式有如下几种：

```
aggregate_name ( expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]

aggregate_name (ALL expression [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]

aggregate_name (DISTINCT expression  [ , ... ] [ order_by_clause ] ) [ FILTER ( WHERE filter_clause ) ]

aggregate_name ( * ) [ FILTER ( WHERE filter_clause ) ]

aggregate_name ( [ expression [ , ... ] ] ) WITHIN GROUP ( order_by_clause ) [ FILTER ( WHERE filter_clause ) ]
```



​		***aggregate_name*** 是一个事先定义的聚合(可能带着一个 schema 前缀)，***expression*** 是任何值表达式且自身不包含一个聚合表达式或一个窗口函数调用。不像非窗口聚合调用，这个操走不会把多个输入行计算后输出一个结果行 - 每个行在查询结果中都会存在。然后，窗口函数访问了所有与当前行同组的行。窗口函数调用语法如下：

```sql
function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER window_name

function_name ([expression [, expression ... ]]) [ FILTER ( WHERE filter_clause ) ] OVER window_definition

function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER window_name

function_name ( * ) [ FILTER ( WHERE filter_clause ) ] OVER window_definition
```

​		***window_definition*** 的语法如下：

```
[ existing_window_name ]

[ PARTITION BY expression [, ... ] ]

[ ORDER BY expression [ ASC | DESC | USING operator ] [ NULLS { FIRST | LAST } ] [, ...] ]

[ frame_clause ]
```

​		可选的 ***frame_clause*** 语法如下：

{ RANGE | ROWS | GROUPS } ***frame_start*** [ ***frame_exclusion*** ]

{ RANGE | ROWS | GROUPS } BETWEEN ***frame_start*** AND ***frame_end*** [ ***frame_exclution*** ]

​		***frame_start*** 或 ***frame_end*** 可以是下列之一：

```sql
UNBOUNDED PRECEDING
offset PRECEDING
CURRENT ROW
offset FOLLOWING
UNBOUNDED FOLLOWING
```

​		***frame_exclusion*** 可以是下列之一：

```sql
EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS
```

​		***expression*** 可以是任何自身不包含窗口函数调用的值表达式。

​		***window_name*** 是一个在 `WINDOW` 子句中定义的窗口的名字的引用。另一种方法，可以写一个完整的 ***window_definition*** ，用圆括号括起来；可以查看 [SELECT](https://www.postgresql.org/docs/13/sql-select.html) 查看细节。`OVER wname` 与 `OVER (wname ...)` 是不等价的；后一种形式一位置对窗口定义的复制与修改，而且会被拒绝当被引用的窗口条件中包含一个 frame 子句。

​		`PARTITION BY` 子句将查询的行分成几个分区(partitions)，这些分区被窗口函数分别处理。`PARTITION BY` 工作方式与查询级别的 `GROUP BY` 子句相似，但 `PARTITION BY` 子句的表达式只能是表达式，而不能是输出列的列名或数字。没有 `PARTITION BY` 子句，所有行被当作一个分区来处理。`ORDER BY` 子句决定了一个分区中的行，被窗口函数处理的顺序。`ORDER BY` 工作方式与查询级别的 `ORDER BY` 类似，同样地，不能使用输出列的列名或数字做表达式。没有 `ORDER BY` ，行被按任意顺序处理。

​		`frame_clause` 指定构成 ***窗口(window frame)*** 的行的集合，窗口中的行是当前分区的一个子集，窗口是那些工作在窗口而不是分区的窗口函数而生的。窗口中的行包括那些取决于当前行。窗口可以被指定为 `RANGE`，`ROWS` 或 `GROUPS` 模式；无论哪种模式下，都是从 `frame_start` 到 `frame_end`。如果 `frame_end` 被省略了，终点默认是 `CURRENT ROW`。

​		`UNBOUNDED PRECEDING` 的 `frame_start` 意味着这个窗口开始于所在分区的第一个行，与此类似，`UNBOUNDED PRECEDING` 的 `frame_end` 意味着这个窗口终止于所在分区的最后一行。

​		在 `RANGE` 和 `GROUPS` 模式，`CURRENT ROW` 的 `frame_start` 意味着这个窗口开始于当前行的第一相等行（指窗口的 `ORDER BY` 子句排序出的与当前行想等的第一个行），`frame_end` 意味着这个窗口终止于当前行的最后相等行。在 `ROWS` 模式，`CURRENT ROW` 仅仅指当前行。

​		在 `offset PRECEDING` 和 `offset FOLLOWING` 窗口选项中，`offset` 必须是个不包含任何变量、聚合函数、窗口函数 的表达式。`offset` 的意义取决于窗口模式：

* 在 `ROWS` 模式，`offset` 必须获取一个 非NULL的非负整数，并且这个选项意味着这个窗口开始或终止于指定数量的行，在当前行之前或之后。
* 在 `GROUPS` 模式，`offset` 也必须获取一个 非NULL的非负整数，并且这个选项意味着这个窗口开始或终止于指定数量多的结对组，在当前行的 peer group 之前或之后，peer group 是一组在 `ORDER BY` 子句下与当前行相等的行的集合。(在窗口定义中必须使用 `ORDER BY` 子句在 `GROUPS` 模式下。)
* 在 `RANGE` 模式，这些选项需要 `ORDER BY` 子句指定确切的一列。`offset` 指定当前行与那个列的最大差值，。`offset` 表达式的数据类型依赖于排序列的数据类型。对于数字类型的排序列，它和排序列是同样的数据类型，但对于 datetime 类型的排序列，它是 `interval` 类型。例如，排序列的类型是 `date` 或 `timestamp` ，可以写为 `RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING`。`offset` 仍需要是非NULL和非负的，但是 "非负" 依赖于它的数据类型。



​		在任何模式下，到窗口末尾的距离受限于到分区末尾的距离，接近分区末尾的行含有的行可能比其他位置的行更少。

​		注意在 `ROWS` 和 `GROUPS` 模式下，`0 PRECEDING` 和 `0 FOLLOWING` 与 `CURRENT ROW` 是等价的。



​		