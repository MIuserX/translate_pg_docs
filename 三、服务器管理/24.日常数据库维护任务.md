

​		pg，像任何其他的数据库软件一样，要求执行一些维护任务来达到最佳性能。这里讨论的任务是必须的，但它们是自然重复的，并且可以自动地使用标准工具，像 crontab 脚本或 Windows 计划任务。部署合适的脚本是 DBA 的职责，并检查它们是否执行成功。

​		一个明显的维护任务是定期创建数据备份。没有最近的备份的情况下，在发生灾难之后你没有任何恢复的机会(磁盘损坏，失火，错误地删除了关键的表，等等)。pg 中可用的备份与恢复机制在 Chapter 25 讨论。

​		另一个主要的维护任务是定期的 “vacuuming”。这个活动被在 Section 24.1 中讨论。与之相近的是更新被查询规划器使用的统计信息，在 Section 24.1.3 中讨论。

​		另一个可能需要周期性执行的任务是日志文件管理。这在 Section 24.3 中被讨论。

​		[check_postgres](https://bucardo.org/check_postgres/) 被用来监控数据库的健康状态，并且报告非寻常的条件。check_postgres 与 Nagios 和 MRTG 交互，但也可以被单独运行。

​		pg 相较于一些其他的数据库系统，需要维护的程度是较低的。尽管如此，对于这些任务的合适的行动将会对系统更快乐和更具生产性的体验是日常重要的。



## 24.1 定期任务 vacuuming（start:1800)

​		pg 要求进行定期的 ***vacuuming*** 维护。对于大多数实例，由 ***autovacuum daemon*** 来执行 vacuuming 就足够了，这在 Section 24.16 中被描述。你可能需要调整 autovacuuming 参数，可以在你的环境下获取到最好的结果。一些 DBA 想要补充或以人工管理的 VACUUM 命令替换 daemon 的活动，典型的方法是使用任务表、crontab 、或者计划任务脚本。要合适地设置人工管理的 vacuuming，理解接下来的小节中讨论的内容是非常重要的。依赖于 autovacuuming 的 DBA 可能仍旧会希望略去这部分内容，来帮助他们理解和调整 autovacuuming。



### 24.1.1 vacuuming 基础

​		pg 的 [VACUUM](https://www.postgresql.org/docs/13/sql-vacuum.html) 命令处理每一个表在一般的基础之上，如下几个理由：

1. 恢复或重用磁盘空间被已更新或已删除的行。
2. 更新被 pg 查询规划器使用的数据统计信息。
3. 更新可视性地图，这会加速 [index-only 扫描](https://www.postgresql.org/docs/13/indexes-index-only-scans.html)。
4. 防止因为事务ID回卷或 multixact ID 回卷丢失非常老的数据。



​		这些原因的每一个都要求以各种各样的频率和作用域来执行 `VACUUM` 操作，在下面的小节中讨论。

​		存在两种 `VACUUM` 的变体：标准 `VACUUM` 和 `VACUUM FULL` 。`VACUUM FULL` 可以回收更多磁盘空间但运行的更慢。同时，`VACUUM` 的标准形式可以和其他生产操作一起并行模式运行。(像 `SELECT, INSERT, UPDATE, DELETE` 这些命令将会继续正常完成功能，尽管你将不能用 `ALTER TABLE` 命令修改表的定义，当它被进行 vacuum 操作时。) `VACUUM FULL` 要求表上的 exclusive 锁，因此不能与表的其他操作并行执行。因此，DBA 一般应该努力使用标准 `VACUUM` 并避免使用 `VACUUM FULL`。

​		`VACUUM` 创造了大量的 I/O 流量，这些流量会造成其他会话的性能低下。存在可以被调整的配置参数，减少后台 vacuuming 的性能影响 - 看 Section 19.4.4 。 

 

### 24.1.2 恢复磁盘空间

​		在 pg 中， `UPDATE` 或 `DELETE` 一个行不会立刻删除行的老版本。对于多版本并发控制(MVCC, 看 Chapter 13)的好处，这个方式是必须的：行版本一定不能被删除，当它仍旧对于其他事务潜在上是可见的。但最后，过时的或被删除的行版本不再对任何事务可见。它占据的磁盘空间必须被回收再利用，避免无限的磁盘空间的增长。可以执行 `VACUUM` 来避免这个。

​		标准形式的 `VACUUM` 删除表中死亡的行版本和索引，并标记空间为可重用。然而，并不会把磁盘空间归还给操作系统，除过特殊情况：当表尾部的一个或多个页完全空了并且很容易获得表的 exclusive 锁。与此相反，`VACUUM FULL` 活跃地影响表，它会写一个完整的新版本的表文件，没有任何死亡空间。这最小化了表的大小，但会花费较长的时间。它也需要额外的磁盘空间，来存放表的新拷贝，直到操作完成。

​		定期 vacuuming 任务的一般目标是足够频繁的做标准 `VACUUM` 避免使用 `VACUUM FULL`。autovacuum daemon 尝试以这样的方式工作，实际上，将不会使用 `VACUUM FULL`。在这个方式上，思路不是将表保持在他们的最小的大小，而是维护磁盘空间稳定的使用：每个表占的空间等于它最大的大小加上更多的空间在 vacuuming 之间耗尽空间。虽然，`VACUUM FULL` 可以被用来将表缩小到它的最小大小并将磁盘空间归还给操作系统，如果未来这个表要再次增长，这个问题不存在其他点了。因此，适度频率的标准 `VACUUM` 运行是一个比运行 `VACUUM FULL` 的更好的方式，对于维护更新较重的表。

​		一些 DBA 喜欢自己计划 vacuuming 时间表，例如在夜里负载低的时候做所有的工作。根据固定的时间表做 vacuuming 的困难是如果一个表在更新活动中出现了一个尖峰，它可能会膨胀到必须需要 `VACUUM FULL` 的来回收空间。使用 autovacuum daemon 减轻这个问题，因为 daemon 动态地按排 vacuuming 根据更新活动。完全禁止 daemon 是不明智的，除非工作负载非常清楚。一个折中的方案是设置 daemon 的参数，这样它只会对不寻常的重的更新活动做出反应，因此不要让事情失去控制，当时间表的 `VACUUM` 被期待做大部分工作当负载是典型的时候。

​		对于那些不用 autovacuum的，一个典型的方法是在时间表上规划一个 database 范围的 `VACUUM` 一天一次，在使用量不高的时候，补充上对于重更新的表的更频繁的 vacuuming 是必要的。（一些更新非常重的实例，每几分钟 vacuum 一次那些最忙的表。）如果一个集群中有多个 database，不要忘记 `VACUUM` 每一个；程序 [vacuumdb](https://www.postgresql.org/docs/13/app-vacuumdb.html) 可能是有帮助的。

> **Tip**
>
> ​		当一个表因为大量的更新或删除活动，而包含大量死亡的行版本时，简单的 `VACUUM` 可能无法满足要求。如果你有这么一张表，并且你需要回收它占用的额外的磁盘空间，你将需要使用 `VACUUM FULL`，或者 [CLUSTER](https://www.postgresql.org/docs/13/sql-cluster.html) ，或者表重写命令 `ALTER TABLE` 的变体之一。这些命令重写一份完整的表的新拷贝并建立索引。所有这些选项要求 exclusive 锁。注意，他们也临时使用额外的大小大约等于表大小的磁盘空间，因为老的表和索引不能被释放，直到新的拷贝完成。

> **Tip**
>
> ​		如果有个表的所有记录都被定期删除，考虑一下用 [TRUNCATE](https://www.postgresql.org/docs/13/sql-truncate.html) ，而不是用 `DELETE` 后又用 `VACUUM`。`TRUNCATE` 可以删除表所有的内容，不需要用一系列 `VACUUM` 或一个 `VACUUM FULL` 来回收现在没用的磁盘空间。缺点是严格的 MVCC 语义被违反了。



### 24.1.3 更新规划器的统计信息

​		pg 的查询规划器依赖于关于表内容的统计信息，目的是生成更好的查询计划。这些统计信息被 [ANALYZE](https://www.postgresql.org/docs/13/sql-analyze.html) 命令收集，这个命令可以单独调用，也可以作为 `VACUUM` 的一个选项使用。拥有合理精确的统计信息是非常重要的，否则查询计划没有多少选择余地会造成数据库性能降低。

​		如果允许 autovacuum daemon，将会自动调用 `ANALYZE` 命令，无论什么时候表内容被大量改变的时候。然而，DBA 可能偏爱依赖于人工定制的 `ANALYZE` 操作，特别是当知道一个表上的更新活动不会影响 “感兴趣的” 列上的统计信息的时候。daemon 将 `ANALYZE` 严格的规划，根据更新或插入的行数；它不知道是否这是否会导致有意义的统计信息变化。

​		正如 vacuuming 为了回收磁盘空间，对于重更新的表，统计信息的频繁更新比不频繁更新的表更有用。就算对于重更新的表，如果数据分布的统计没有发生多大改变，可能也是不需要更新统计信息的。一个简单的规则是：列的最小值和最大值改变了多少。例如，一个 `timestamp` 类型的列，包含行更新的时间，将会有一个一直增大的最大值，因为行被插入或更新；这样一个列可能比存储了页面 URL 的列需要更频繁的统计信息更新。URL 列可能经常更新，但它的值的统计分布可能相对改变的缓慢。

​		可以在特定的表上运行 `ANALYZE` 或在一个表的特性列上运行，所以复杂性存在，更新一些统计信息比你的应用程序要求的更频繁。然而，在实践上，analyze 整个 database 是最好的，因为这是个很快的操作。`ANALYZE` 使用了一个统计性的任意抽样对表的一些行，而不是读取每个行。

> **Tip**
>
> ​		虽然单列的 `ANALYZE` 频率的调整可能不是非常有用，你可能发现更值得做 `ANALYZE` 收集的统计信息的细节层次的单列调整。`WHERE` 子句中重度使用并且拥有更不整齐的数据分布的列可能比其他列更需要更细粒度的数据柱状图。看 `ALTER TABLE SET STATISTICS`，或者改变 database 范围的默认值，使用 [default_statistics_target](https://www.postgresql.org/docs/13/runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET) 配置参数。

> **Tip**
>
> ​		autovacuum daemon 不会对 foreign table 发起 `ANALYZE` ，因为决定多久一次 `ANALYZE` 是有用的是没意义的。如果你的查询因为要做合适的查询计划而要求 foreign table 的统计信息，在这些表上以合适的时间表运行人工管理的 `ANALYZE` 命令是个好主意。



### 24.1.4 更新可见性地图

​		vacuum 为每个表维护 [visibility map](https://www.postgresql.org/docs/13/storage-vm.html) 来保持对 哪个页仅存储了对于其他所有的活跃事务都可见的元组 的跟踪(和所有的未来的事务，直到这个页被再次改变)。这有两个目的。第一，vacuum 自己会跳过这样的页在下次运行的时候，因为没有可以清理的。

​		第二，它允许 pg 仅使用索引来应答某些查询，而不用引用下层的表。因为 pg 的索引不包含元组可见性的信息，一个正常的索引扫描对于每个匹配的索引入口获取其堆元组，检查它对于当前事务是否可见。另一方面，一个 [index-only scan](https://www.postgresql.org/docs/13/indexes-index-only-scans.html) ，首先检查可见性地图。如果这个页上的所有元组都是可见的，堆获取可以被跳过。这在大数据集合上是非常有用的，这里可见性地图可以避免磁盘访问。可见性地图远比堆小多了，所以它可以被简单地缓存起来，即使堆非常大。



### 24.1.5 防止事务ID回卷失败

​		pg 的 [MVCC](https://www.postgresql.org/docs/13/mvcc-intro.html) 事务语义依赖能比较事务 ID (XID) 数字：一个行版本插入事务 XID 大于当前事务 ID ，对当前事务来说，这个行版本是 “未来的数据”，并且是不可见的。但事务 ID 有限制(32 bits)，一个运行很长时间的集群(超过四十亿个事务) 将会遭遇***事务ID回卷***：XID 计数器环回到零，突然，所有过去的事务变成了在未来的事务 - 这意味着他们的数据变得不可见。简而言之，灾难性的数据丢失。(实际上，数据仍旧在那里，但你没法读取它，这就是个无用的安慰。) 为了避免这样，至少每20亿事务，vacuum 每个 database 中的每个表一次是必须的。

​		



### 24.1.6 autovacuum daemon











