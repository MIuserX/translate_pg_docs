

### 5.1 表的基础知识

英文：https://www.postgresql.org/docs/13/ddl-basics.html

​		关系型数据库中的表非常像我们打印在纸上的表格：由行和列构成。列的数量和顺序是固定的，每个列都有个名字。行的数量是变化的 - 这表示某个时刻表中所存储的数据。SQL 并不保证查出来的行的顺序。当读取一个表的时候，行将会以顺序未定义的情况出现，除非显式指定了排序。这在 [Chapter 7](https://www.postgresql.org/docs/13/queries.html) 中被描述。进一步，SQL 也不会为每一行做唯一约束，所以一个表中可能有完全相同的行。这是基于 SQL 的数学模型必然的结果，但这可能不是我们想要的。在后续的章节里，我们会讨论怎么处理这种情况。

​		每个列都有数据类型。数据类型包含了能赋值给列的可能的值的集合，也赋予了存储在列中的数据以语义以便于被用作运算。一个例子，被声明为一个数字类型的列不能接受任意字符串值，而且这个列的存储的值可以被用来进行数学运算。与之形成对比的是，被声明为字符串类型的列能接受几乎所有类型的数据但并不能让它自己用于数学计算，即使其他的操作像字符串粘接是允许的。

​		pg 内置了很多的数据类型，能适应大部分应用程序。用户也可以自定义数据类型。大部分内置数据类型拥有明显的名字和语义，所以我们后续在 [Chapter 8](https://www.postgresql.org/docs/13/datatype.html) 详细解释。最常用的数据类型有 `integer` 对于整数，`numeric` 对于小数，`text` 对于字符串，`date` 对于日期，`time` 对于时间值，`timestamp` 对于同时包含日期和时间的值。

​		要创建一个表，可以用 `CREATE TABLE` 命令。在这个命令中，至少要为新表指定一个名字，列的名字和数据类型。例如：

```sql
CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);
```

​		上述 SQL 创建一个叫 `my_first_table` 的表，有两个列。第一个列 `first_column` 数据类型为 `text`；第二个列 `second_column` 数据类型是 `integer`。表名与列名遵循标识符语法规则(在 [Section 4.1.1](https://www.postgresql.org/docs/13/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS) 中描述)。数据类型的名字也是标识符，但也有一些例外。注意列的列表是用逗号分开的，并且被圆括号括起来。

​		当然，前面的例子太刻意了。正常情况下，你赋予表和列的名字会暗示其存储什么种类的数据。所以更接近现实的 SQL 是：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);
```

 		(`numeric` 类型可以存储小数，典型的应用是存储金钱数量。)

> **Tip**
>
> ​		当你要创建大量互相有联系的表时，对表名和列名使用一种统一的命名模式是非常有用的。例如，使用单数或复数形式的表名，这两种形式都有支持的理论家。

​		一个表包含的列的个数是有上限的。根据列的类型，列的个数在 250 到 1600 之间。然后，定义一个包含很多列的表大概率是不常见的且是有问题的设计。

​		如果某个表不用了，你可以用 `DROP TABLE` 命令删除它。例如：

```sql
DROP TABLE my_first_table;
DROP TABLE products;
```

​		尝试删除一个不存在的表会导致报错。然而，在创建表前进行无条件地删除而忽略报错在 SQL 脚本中是非常普遍的，所以无论这个表是否存在这个脚本都能工作。(如果你喜欢，你可以用 `DROP TABLE IF EXISTS` 来避免报错，但不是SQL标准。)

​		如果你需要修改一个表的结构，看 [Section 5.6](https://www.postgresql.org/docs/13/ddl-alter.html)。

​		使用到目前为止我们讨论的工具，你已经可以创建一个完全有实际意义的表。这个章节的后续部分是关于为表定义添枝加叶，来保证数据的完整性，安全性，或者易用性。如果你急着向表里添加数据你可以跳到 [Chapter 6](https://www.postgresql.org/docs/13/dml.html) 读这个章节的后面部分。



### 5.2 默认值

英文：https://www.postgresql.org/docs/13/ddl-default.html

​		列可以被赋予默认值。当创建一个新行时，如果有些列没有被指定值，那么就会使用默认值。数据操纵语句也可以显式的使用将列设置为默认值，而无需知道列的默认值具体时什么。(关于数据操作的细节在 [Chapter 6](https://www.postgresql.org/docs/13/dml.html) 。)

​		如果没有显式的指定默认值，默认值是 NULL。这个规则大部分时间是有意义的，因为 NULL 可以被解读为未知的数据。

​		在一个表定义中，默认值被写在列的数据类型后面。例如：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric DEFAULT 9.99
);
```

​		默认值可以是一个表达式，这个表达式将会在创建行的时候求值(而不是建表的时候)。一个关于 `timestamp` 的常见默认值是 `CURRENT_TIMESTAMP` ，当插入行的时候被设置。另一个常见的例子是为每个行生成一个 “序列号”。在 pg 中，典型的做法是：

```sql
CREATE TABLE products (
    product_no integer DEFAULT nextval('products_product_no_seq'),
    ...
);
```

​		`nextval()` 函数会应用 ***序列号对象***([Section 9.7 中描述](https://www.postgresql.org/docs/13/functions-sequence.html)) 的合适的值。这种管理方法是如此广泛地使用，所以有个特殊的缩写：

```sql
CREATE TABLE products (
    product_no SERIAL,
    ...
);
```

​		`SERIAL` 被在 [Section 8.1.4](https://www.postgresql.org/docs/13/datatype-numeric.html#DATATYPE-SERIAL) 中讨论。



### 5.3 generated columns

英文：https://www.postgresql.org/docs/13/ddl-generated-columns.html

​		generated column 是一种特殊的列，它可以用其他列计算得来。因此，这是表的视图列而生的。有两种 generated column：stored 和 virtual。一个 stored generated column 在它被写入的时候(insert 或 update) 进行计算，并且占用存储空间就好像它是一个真正的列。一个 virtual generated column 不占用存储空间，当它被读取的时候才会被计算。因此，一个 virtual generated column 和视图很相似，一个 stored generated column 和物化视图非常相似(除过，它会自动更新)。pg 目前只实现了 stored generated column 。

​		要创建一个 generated column ，在 `CREATE TABLE` 子句中使用 `GENERATED ALWAYS AS` 子句，例如：

```sql
CREATE TABLE people (
    ...,
    height_cm numeric,
    height_in numeric GENERATED ALWAYS AS (height_cm / 2.54) STORED
);
```

​		关键字 `STORED` 必须被使用来指定 generated column 的类型。欲了解更多细节看 [CREATE TABLE](https://www.postgresql.org/docs/13/sql-createtable.html)。

​		generated column 不能直接写。在 `INSERT` 和 `UPDATE` 命令中，不能为 generated column 指定值，但是默认值关键字 `DEFAULT` 可以使用。

​		思考一下一个带默认值的列与一个 generated column 的不同点。对于列的默认值，当插入行的时候没指定值的时候会被计算；一个 generated column 在更新行的时候自动更新，而且不能被覆盖。列的默认值不太可能会引用表中的其他列；一个 generation 表达式一般会引用表中的其他列。列的默认值可以使用不稳定的函数，例如 `random()` ，或者使用表示当前时间的函数；这在 generated column 中是不允许的。

​		下面是一些关于定义 generated column 和 表引用generated column 的限制：

* generation 表达式只能使用稳定的函数，不能用子查询，不能引用当前行之外的任何东西。
* generation 表达式不能引用另一个 generated column。
* generation 表达式不能引用系统列，除过 `tableoid`。
* generated column 不能有默认值和唯一约束。
* generated column 不能是 partition key 的一部分。
* 外部表不能有 generated column。详情看 [CREATE FOREIGN TABLE](https://www.postgresql.org/docs/13/sql-createforeigntable.html)。
* 对于继承：
  * 如果父列是一个 generated column，子列也必须是使用相同表达式的 generated column。在子列定义中，xxx，因为会从父列中复制。
  * 在多继承情况中，如果一个父列是 generated column，所有的父列必须是使用相同表达式的 generated column。
  * 如果父列不是 generated column，子列可以是 generated column 也可以不是。



​		其他一些关于使用 generated column 的要考虑点：

* generated column 的访问权限与它的基础列是相互独立的。所以，我们可以管理，让一个特定的角色可以读取 generated column 而不能读取它的基础列。
* 从概念上讲，generated column 在 `BEFORE` 触发器运行之后才会更新。因此，在 `BEFORE` 触发器中修改基础列的值将会影响到 generated column。但实际上恰恰相反，在 `BEFORE` 触发器中不允许访问  generated column。



### 5.4 约束

英文：https://www.postgresql.org/docs/13/ddl-constraints.html

​		数据类型是一种限制数据种类的方式。然而大部分应用程序提供的约束都太过粗略。例如，一个存储产品价格的列应该只接受正数。但没有一种标准类型是只接受正数的。另一个问题是如果你想一个列的数据被其他列或其他行约束。例如，在一个产品信息表里，对于每个产品应该只有一行。

​		为了这个目的，SQL 允许你在列或表上定义约束。约束使你能给表的数据施以更多的控制。如果用户想要向一个列中存储违反其约束的值，会收到一个报错。即使违反约束的值来源于默认值，这个规则依然生效。



#### 5.4.1 check 约束

​		一个 check 约束是最一般的约束类型。这允许你为某个列指定一个布尔表达式，这个列的值必须遵循这个布尔表达式。例如，要求价格必须为正数，你可以：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0)
);
```

​		如你所见，约束定义在数据类型后面，就像默认值定义一样。默认值与约束的顺序可以颠倒。一个 check 约束的定义由 `CHECK` 关键字后跟着圆括号括起来的表达式。chech 约束的表达式应该引用被约束的列，否则约束表达式没有意义。

​		你以可以给约束一个独立的名字。这可以让报错信息更加清晰，并且你可以通过这个名字来也引用约束当你需要修改它的时候。语法如下：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CONSTRAINT positive_price CHECK (price > 0)
);
```

​		因此，指定一个有名字的约束时，使用关键字 `CONSTRAINT` ，后跟着一个标识符，再跟着约束定义。(如果你不移这种方式指定约束的名字，系统将会自己给个名。)

​		check 约束也可以引用多个列。你要存储一个一般价格和打折后的价格，并且想要保证打折价格低于一般价格：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
```

​		上面例子中，前两个约束看起来非常相似。第三个约束使用了一个新语法。他没有与任何一个具体的列关联起来，而是作为一个独立的元素列在逗号分隔的列列表里。列定义与约束定义可以混合在一起。

​		我们说前两个约束是列级约束，然而第三个约束是表级约束，因为它没有被关联到任何一个列上。列级约束也可以被写为表级约束，但反过来则不行，因为列级约束被假定为只会引用它关联的列。(pg 不强制这个规则，但如果你想表定义语句也能适应于其他数据库系统，最好遵循这个约束。) 上面的例子也可以被写为：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
```

​		或者甚至：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0 AND price > discounted_price)
);
```

​		使用哪种，是个人便好的问题。

​		也可以用向列级约束赋予名字同样的方式向表级约束赋予名字：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0),
    CONSTRAINT valid_discount CHECK (price > discounted_price)
);
```

​		应该注意的是，check 约束当表达式被求值为 true 或 null 时才会被认为符合约束。因为如果有一个操作数是 null ，大部分表达式就会被求值为 null，所以 check 约束不会禁止被约束的列为 null 。为了保证一个列不包含 null 值，可以使下个小节将要描述的 not-null 约束。

> **Note**
>
> ​		pg 不支持 xxx。有时违反了这个规则的约束在简单的测试中能生效，但这不能保证数据不会到达某个使得 check 表达式为 false 的状态(由于被引用的其他行的子序列改变)。这将会导致数据库 dump 和重载错误。重载将会错误，尽管整个数据库对于约束是一致的，因为在某种顺序下的没有加载的数据将会符合约束。如果可能，使用 `UNIQUE`, `EXCLUDE`, `FOREIGN KEY` 约束来表达跨行和跨表的限制。
>
> ​		如果你想要的是一次性检查在其他行的背景下在插入行的时候，而不是一个持续维护的一致性保证，一个自定义 [触发器](https://www.postgresql.org/docs/13/triggers.html) 可以被用来满足需要。(这个方法会防止 dump/reload 问题，因为 pg_dump 不会重新安装触发器，直到重载数据之后，所以 check 约束不会在 dump/reload 期间被强制执行。)

> **Note**
>
> ​		pg 假设 check 约束的条件是不可变的，这是说，当输入的行一定时，输出的结果也是一定的。这个假设证明仅在插入行或更新行的时候检查 check 约束的合法性。(上面这些关于不引用其他表数据的警告实际上是这个限制的一个特殊例子。)
>
> ​		打破这个假设的常见例子是在 check 表达式中引用用户自定义函数，然后改变自定义函数的行为。pg 不会禁止这种行为，但当表里已有的行违反了 check 约束时不会有通知。这会造成数据库 dump 并且 reload 失败。处理这种变化，推荐的方法是先 drop 约束(使用 `ALTER TABLE`) ，调整函数的定义，然后重新添加约束，从而使数据库重新检查表达的所有行是否满足约束。



#### 5.4.2 Not-Null 约束

​		not-null 约束指定列一定不能为 null 值。语法的例子：

```sql
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric
);
```

​		not-null 约束经常为写为列级约束。not-null 约束与创建这样一个 check 约束：`CHECK (column_name IS NOT NULL)` 在功能上是等价的，但在 pg 里，显式地创建一个 not-null 约束是更高效的。缺点是你不能为用这种方法创建的约束给予一个显式的名字。

​		当然，一个列可能有多个约束。只需要一个接一个的写着就行：

```sql
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price > 0)
);
```

​		写约束的顺序是无关紧要的。约束被执行的顺序不是必要指定的。

​		`NOT NULL` 约束有个相反的：`NULL` 约束。这不是说列值必须为 null 值，这没什么意义。而是说，这会使用默认的行为，即允许列值为 null 值。`NULL` 约束不在当前的 SQL 标准里，在可移植的程序不应该使用这个。(这被 pg 支持只是为了兼容其他数据库系统。) 然后，一些用户喜欢这个特性，因为这使得在一个脚本文件中切换约束变得容易。例如，你可以：

```sql
CREATE TABLE products (
    product_no integer NULL,
    name text NULL,
    price numeric NULL
);
```

​		然后在想要的地方输入 `NOT` 关键字。

> **Tip**
>
> ​		在大部分数据库设计中，大部分列应该是 not null 的。



#### 5.4.3 唯一约束

​		唯一约束保证某个列或某几个列的组合的取值在整个表中是唯一的。语法是：

```sql
CREATE TABLE products (
    product_no integer UNIQUE,
    name text,
    price numeric
);
```

​		上述例子写为列级约束，同时：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    UNIQUE (product_no)
);
```

​		是写为表级约束。

​		为了给某几个列定义一个唯一约束，将之写为表级约束：

```sql
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    UNIQUE (a, c)
);
```

​		这指定了 a, c 列的值组合在整个表内是唯一的，而单个一个列的值不是唯一的。

​		你可以为唯一约束赋予一个名字，使用一般的方法：

```sql
CREATE TABLE products (
    product_no integer CONSTRAINT must_be_different UNIQUE,
    name text,
    price numeric
);
```

​		添加一个唯一约束会自动创建一个 唯一B-tree索引。一个只覆盖某些行的唯一限制不能被写为唯一约束，但它可以创建一个 [partial index](https://www.postgresql.org/docs/13/indexes-partial.html) 来执行约束。

​		一般，当一个表里有超过一行的在唯一约束里的列值是相等的，就违反了唯一约束。然后，两个 null 值不被认为违反。这意味着，只要唯一约束里的列有一个值是 null，那么就存在重复行的可能。这个行为是符合 SQL 标准的，但有些其他数据库系统并不遵循这个规则。所以开发可移植的应用程序时应该注意这一点。



#### 5.4.4 主键

​		主键约束意味着，一个列或一个列组合，在整个表的范围内，可以被用作行的唯一标识符。这要求值必须唯一且非 null。所以，下面两个表定义接受同样的数据：

```sql
CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);

-- 

CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
```

​		主键可以跨越超过一个列；语法和唯一约束相似：

```sql
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    PRIMARY KEY (a, c)
);
```

​		添加主键将会自动创建一个 唯一B-tree索引，还会强制列  `NOT NULL`。

​		一个表最多只能有一个主键。(表可以有多个唯一约束或not-null约束，功能上几乎相同，但主键只能有一个。) 关系数据理论要求每个表必须有个主键。pg 不强制这个规则，但最好遵循它。

​		主键对于文档和应用程序都是有用的。例如，一个允许修改数据的 GUI 应用程序，可能需要知道表的主键，以便于唯一的定位每个行。数据库有很多方式来使用主键；例如，主键可以定义外键应用的默认列。



#### 5.4.5 外健

​		外键约束指定，一个列或一个列组合的值必须匹配另一个表中行的值。我们说这维护了两个关系表的 ***引用完整性***。

​		假设你有一个产品表：

```sql
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
```

​		我们再假设，有个存储这些产品的订单的表。我们想保证订单表只包含存在的产品的订单。所以我们定义一个外键约束在订单表上，来引用产品表：

```sql
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products (product_no),
    quantity integer
);
```

​		现在就无法创建 product_no 不在产品表里的订单了。

​		这种情况下，我们讲订单表是 **引用表** ，产品表是 **被引用表**。与此类似，也有 **引用列** 和 **被引用列** 之说。

​		你可以将上述 SQL 做些简化：

```sql
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products,
    quantity integer
);
```

​		因为在缺省情况下，被引用表的主键中的列将被当作引用列。

​		外键也可以约束或引用一个列组。通常，这需要写成表级约束。下面是个例子：

```sql
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);
```

​		当然，约束列的数量和类型要与被引用列的数量和类型相同。

​		通常，你可以为外键赋予一个名字。

​		一个表可以拥有超过一个外键。这用来实现表之间多对多的关系。假设你有产品和订单表，但现在你想在一个订单里包含多个产品（上面关于产品表和订单表中的例子是没法做到这个的）。你可以使用如下的表结构：

```sql
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
```

​		注意上述的第三个表里，主键和外键是重合的。

​		我们知道外键禁止创建没有与任何产品关联的订单。但如果一个产品被移除之后，之前创建的引用这个产品的订单会怎么样呢？SQL 允许你处理这样的情况。直观上，我们有以下几个方法：

* 禁止删除一个被引用的产品
* 删除一个被引用的产品时，同时删除与之相关的订单
* 其他



​		为了讲清楚这个问题，让我们实现这样一个多对多关系的例子：当要删除一个被引用的产品时，禁止这样做。当要删除一个订单时，订单相关联的项被也被删除：

```sql
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products ON DELETE RESTRICT,
    order_id integer REFERENCES orders ON DELETE CASCADE,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
```

​		restrict 和 cascade 删除是两种最常见的选项。`RESTRICT` 防止被引用行被删除。`NO ACTION` 意思是当被引用行已被删除，而引用行还存在，当检查约束的时候，将会报错；如果你不指定删除方式，这是默认行为。(这两种方式的最大区别是：`NO ACTION` 允许在事务中将约束检查推迟到后面，而 `RESTRICT` 不是这样。) `CASCADE` 指定当被引用行被删除时，引用它的行和会被自动删除。还有其他两个选项：`SET NULL` 和 `SET DEFAULT` 。这俩方法会让引用列被设置为 null 值或默认值，当被引用行被删除的时候。注意，这些方法不会阻止你遵循其他任何约束。例如，如果指定了 `SET DEFAULT` ，但默认值不遵循约束，这个操作就会失败。

​		与 `ON DELETE` 类比的还有 `ON UPDATE` ，当被引用列改变的时候(被 update)。可能的动作是相同的。在这种情况下，`CASCADE` 意思是将被引用的新值复制给引用列。

​		正常情况下，引用行在任何一个引用列是 null 值时无需遵循外键约束。如果 `MATCH NULL` 被添加到外键声明中，引用行只有在所有引用列是 null 值时可以不遵循约束(所以，null值和非null值混合的，一定会导致 `MATCH NULL` 约束失败)。如果你想避免引用行逃脱约束，将引用列声明为 `NOT NULL`。

​		外键引用的列必须是主键或者带有唯一约束。这意味着被引用列常常是带有索引的(主键和唯一约束的B-tree索引)；所以检查引用行是否拥有一个匹配是非常高效的。从被引用表删除一个被引用行或者更新被引用列，将会在引用表上进行一次扫描，扫描那些相关的行，所以为引用列建立索引是个好主意。因为这不是必须的，并且有很多种方法创建索引，外键约束的声明不会自动为引用列创建索引。

​		更多关于更新和删除数据的知识在 [Chapter 6](https://www.postgresql.org/docs/13/dml.html) 。外键约束的语法可以看 [CREATE TABLE](https://www.postgresql.org/docs/13/sql-createtable.html)。



#### 5.4.6 exclusion 约束

​		exclusion 约束保证，如果两个行进行比较，使用指定的列或表达式，使用指定的操作符，至少一个操走符将会返回 false 或 null。语法是：

```sql
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &&)
);
```

​		看 [CREATE TABLE ... CONSTRAINT ... EXCLUDE](https://www.postgresql.org/docs/13/sql-createtable.html#SQL-CREATETABLE-EXCLUDE) 获取更多细节。

​		添加一个 exclusion 约束将自动创建一个约束指定的类型的索引。



### 5.5 系统列

英文：https://www.postgresql.org/docs/13/ddl-system-columns.html

​		每个表都有几个系统列，这是系统隐式定义的。因此，这些列的名字不能被用户自定义列所使用。(注意，这些限制与列名是否是关键字是两回事；将名字用双引号括起来并不能让你逃脱这个限制。) 实际上你可以不在意这些列的存在，只要知道它们存在就行了。

##### tableoid

​		包含这个行的表的 OID。这个列是为 xxx 而准备的，因为没有这个，分辨一个行来自哪个表是有难度的。tableoid 可以用来与 pg_class 表的 oid 列做 JOIN 来获取表的名字。

##### xmin

​		插入这个 row version 的事务的标识(transaction ID)。(row version 是行的一个状态；update 一个行会导致创建一个这个行的新版本，即row version，这两个行在逻辑上是一个行，在物理上有多行，每个行表示某个时刻的版本。) 

##### cmin

​		事务中插入该 row version 的命令的标识(从0开始)。

##### xmax

​		删除这个 row version 的事务的标识(transaction ID)，为零表示未删除的 row version。在一个可见的行中，这一列可能是非零。这通常意味着删除事务还未提交，或者一个删除的尝试被回滚了。

##### cmax

​		事务中删除该 row version 的命令的标识，或者为零。

##### ctid

​		该 row version 在表中的物理位置。注意，虽然可以用 ctid 快速定位 row version，一个 row version 的 ctid 会在它被更新或者被 `VACUUM ALL` 删除的时候发生变化。因此，不能作为一个永久的行标识。应该用主键来标识一个逻辑行。



​		事务标识是一个32 bit的值。在一个长期运行的数据库实例中，事务 ID 可能会环绕。这不是一个需要特殊维护的致命问题；更多细节看 [Chapter 24](https://www.postgresql.org/docs/13/maintenance.html) 。然后，在长期运行中(指超过10亿事务)依赖事务 ID 的唯一性，是不明智的。

​		命令标识也是一个32 bit的值。这是一个硬限制，即一个事务内最多允许，2的32次方(40亿)个命令。在实践中，这个限制不太可能被达到 - 注意，这是计算 SQL 命令的数量，不是处理的行的个数。同时，只有实际行对数据造成更改的SQL命令才会占用一个命令标识。



### 5.6 修改表结构

英文：https://www.postgresql.org/docs/13/ddl-alter.html



​		当你创建一个表后，发现你搞错了一些事情，或者应用程序的需求发生了变化，你可以删除表，然后再重建。但这不是一个方便的选择，当表里已经有数据的时候，或者表已经被其他数据库对象所引用(例如一个外键约束)。 因此，pg 提供了一个命令族对已存在的表进行修改。注意，这在概念上与修改表数据是不同的：这里我们感兴趣的是修改表定义，或者说修改表结构。

​		你可以：

* 添加列
* 删除列
* 添加约束
* 删除约束
* 修改列的默认值
* 修改列的数据类型
* 重命名列
* 重命名表



​		所有的这些动作都使用 [ALTER TABLE](https://www.postgresql.org/docs/13/sql-altertable.html) 命令，它的参考页面上的信息比这里更加丰富。



#### 5.6.1 添加列

​		要添加一个列，使用类似下面的命令：

```sql
ALTER TABLE products ADD COLUMN description text;
```

​		新加的列会被赋予默认值(如果没用 `DEFAULT` 子句指定，就赋予 null 值。)

> **Tip**
>
> ​		从 pg11 开始，添加一个带有常量默认值的的列，不再意味着在执行 `ALTER TABLE` 语句时会更新表中所有已存在的行的该列为默认值。取而代之的是，下次访问某个行的时候，默认值会被返回，并且当表被重写的时候默认值会被赋予列，这使得即使对于大表，`ALTER TABLE` 也会执行很快。
>
> ​		然而，当默认值不是固定不变的值时(例如，clock_timestamp())，每个行都需要被更新为执行 ` ALTER TABLE` 语句时的时间。为了避免潜在的长时间的更新操作，特别是无论如何你都想赋予列最非默认值，更好的方法是添加不带默认值的列，然后用 `UPDATE` 来插入正确的值，然后再给列添加默认值。

​		你也可以在添加列的时候为它添加约束，使用常见的语法：

```sql
ALTER TABLE products ADD COLUMN description text CHECK (description <> '');
```

​		实际上，所有在 `CREATE TABLE` 中给列声明使用的东西都可以用在这里。记住，默热值必须遵循给定的约束，否则操作会失败。你也可以在给列赋予了合适的值之后再添加约束(接下来会讨论)。



#### 5.6.2 删除列

​		要删除一个列，使用类似下面的命令：

```sql
ALTER TABLE products DROP COLUMN description;
```

​		无论什么数据都会随着列消失。与之相关的约束也会被删除。然而，如果待删除的列被一个其他的表的外键引用，pg 不会沉默地删除这个约束。你可以加上 `CASCADE` 关键字来删除一切依赖于待删除列的对象：

```sql
ALTER TABLE products DROP COLUMN description CASCADE;
```

​		更多细节看 [Section 5.14](https://www.postgresql.org/docs/13/ddl-depend.html)。



#### 5.6.3 添加约束

​		要添加一个约束，需要使用添加约束的语法。例如：

```sql
ALTER TABLE products ADD CHECK (name <> '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
```

​		要添加一个 not-null 约束，这不能被写为一个表级约束，使用下列语法：

```sql
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
```

​		约束将会被立刻检查，所以在约束被添加前，表数据必须遵循约束。



#### 5.6.4 删除约束

​		要删除一个约束你需要知道约束的名字。如果你已经给约束赋予了名字，这个操作会很简单。否则，系统会为约束赋予一个自动生成的名字，你需要找出这个名字。命令行工具 psql 的 `\d tablename` 命令可以帮你；其他接口可能也可以查看表的细节。所以，删除约束的命令为：

```sql
ALTER TABLE products DROP CONSTRAINT some_name;
```

​		(如果你正在处理一个像 `$2` 这样的自动生成的约束名时，你需要将它用双引号括起来，来保证这是个合法的标识符。)

​		如果你想删除一个有其他对象依赖的约束，你需要在删除列的时候加上 `CASCADE` 。一个例子是：某个外键约束依赖了被引用列的唯一约束或主键。

​		上述方法对所有类型的约束都有效，除过 not-null 约束。要删除 not-null 约束，使用：

```sql
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
```

​		(撤销那些没有名字的 not-null 约束。)



#### 5.6.5 改变列的默认值

​		要为列设置一个新的默认值，使用类似下面的命令：

```sql
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
```

​		注意，这不会影响任何已经存在的行，这仅仅只对后续的 `INSERT` 命令生效。

​		要删除一个列的默认值，使用：

```sql
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
```

​		这与将列的默认值设置为 null 的效果是一样的。结果是，删除一个用户未定义的默认值不会报错，因为隐式的默认值是 null。

