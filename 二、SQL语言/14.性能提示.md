



## 14.1 使用 `EXPLAIN`

​		pg 为每个查询创建一个查询计划。选择正确的计划来匹配查询结构和数据的性质对于性能是非常重要的，所以系统包含了一个复杂的 ***规划器*** ，它会尝试选择一个好的查询计划。你可以使用 `EXPLAIN` 命令来查看规划器为每个查询创建的查询计划。阅读查询计划是一门艺术，这要求管理员有一些经验，这个小节尝试讨论基础知识。

​		这个小节的例子在回归测试数据库执行 `VACUUM ANALYZE` 之后是苍白无力的，使用了 9.3 开发源。如果你自己尝试，应该会得到相似的结果，但估算的代价和行数大概会有一些轻微的差别，因为 `ANALYZE`的统计信息是任意的而不 是确切的，而且估算的代价依赖一些平台特定的因素。

​		例子中的 `EXPLAIN` 使用了默认的 “文本” 输出格式，文本格式简洁又易读。如果你想将 EXPALIN 的输出给其他程序做进一步的分析，使用一种机器可读的格式（XML,JSON,YAML）。



### 14.1.1 EXPLAIN 基础知识

​		查询计划的结构是一个由 **计划节点** 构成的树。树的底层节点是扫描节点：他们从表里返回原始的行。对于不同的表访问方法，存在多种不同的扫描节点：顺序扫描、索引扫描、bitmap 索引扫描。也存在不是表的数据源，例如 `VALUES` 子句和 在 `FROM` 子句中的 set-returning 函数，这些拥有自己的扫描类型。如果查询要求 join, aggregation, sorting 或其他对原始的行的操作，这时将会有额外的节点，在扫描节点之上，来执行这些操作。再次，可能存在多种可能的方法来做这些操作，所以不同的节点也可能出现在这里。EXPLAIN 的输出，对于每个节点，都会有一行，展示规划器为查询节点规划的基础的节点类型加代价估算。额外的行可能会出现，是节点的总结行，来展示节点额外的属性。首行（最顶层节点的总结行）拥有估算的总执行代价对这个计划；是这个数字，规划器尝试去最小化。

​		这里又一些琐碎的例子，仅仅展示一下 EXPALIN 的输出的模样：

```sql
EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)
```

​		因为这个查询没有 `WHERE` 子句，它必须扫描表的所有记录，所以规划起选择了使用简单的顺序扫描计划。括号中提到的数字，由左向右依次是：

* 估算的最低代价。这是输出阶段开始之前消耗的时间，例如，去做排序的时间。
* 估算的总消耗。这个假设计划几点都执行完，i.e. 所有可得的行都被获取。实践中，一个节点的父节可能会停止，读取可得行的一部分（看下面 `LIMIT` 的例子）。
* 估算的这个查询节点可能返回的行数。再次，节点被假设被完成运行。
* 估算的这个查询节点可能返回的行的平均宽度(以字节为单位)。



​		代价被以任意的单元来估算，取决于规划器的代价参数（看 Section 19.7.2）。传统的实践是以磁盘页的获取代价为单元的；这是说，[seq_page_cost](https://www.postgresql.org/docs/13/runtime-config-query.html#GUC-SEQ-PAGE-COST) 被方便地设置为 `1.0` 并且其他代价参数都依据这个来设置。这个小节中的例子被运行以默认的代价参数。

​		理解，一个上层节点包含它的所有下层节点的代价，是重要的。意识到，代价仅仅反映规划器关心的因素。具体来说，代价没有考虑将结果传输给客户端花费的时间，这可能是个重要的因素，在真实花费的时间中；但是规划器忽略它，因为它不会因为它改变计划（每个正确的计划将会输出同样的结果集，我们相信）。

​		`rows` 值有一点