

## 13.1 介绍 



## 13.2 事务隔离级别



## 13.3 显式锁

​		pg 提供各种各样的锁来控制对数据的访问。这些锁可以被用于应用程序控制的锁机制，在哪些 MVCC 没有明确定义行为的场景中。同时，大多数 pg 命令会自动申请合适的锁来保证所引用的表没有被以互相矛盾的方式删除或者修改，当执行命令的时候。(例如，`TRUNCATE` 不能与其他操纵同一个表的操作并发的安全的执行，所以它获取一个在目标表上的 exclusive lock 来强制保证这一点。)

​		要列出一个当前服务器所有的锁，使用 [pg_lock](https://www.postgresql.org/docs/13/view-pg-locks.html) 系统视图。

​		要了解更多关于监控锁的状态的管理子系统，看 [Chapter 27](https://www.postgresql.org/docs/13/monitoring.html) 。



### 13.3.1 表级锁

​		下面的表列出 pg 中的表级锁，及其被自动使用的上下文。你也可以使用命令 [LOCK](https://www.postgresql.org/docs/13/sql-lock.html) 显式地获取任何一个这些锁。记住，下列的都是表级锁，甚至名字包含单词 “row”；锁的命名具有历史原因。在某种程度上，名字反应了每种锁的典型用途 - 但语义上都是相同的。锁之间唯一真实的不同点是，锁具有的与之冲突的锁的集合不同(看 Table 13.2)。两个事务不能同时在一个表上获取互相冲突的锁。(然而，一个事务不会和它自己冲突。 例如，它可能在同一表表上要求 `ACCESS EXCLUSIVE` 锁，之后要求 `ACCESS SHARE` 锁。）非冲突锁可以被多个事务并发持有。特别注意，有些锁是自冲突的（例如，`ACCESS EXCLUSIVE` 不能同时被超过一个事务持有），而其他锁不是自冲突的（例如，一个 `ACCESS SHARE` 锁可以被多个事务持有）。

**表级锁**

* `ACCESS SHARE`

  只与 `ACCESS EXCLUSIVE` 冲突。

  `SELECT` 命令要求这个锁在所引用的表上。一般，任何一个只读一个表而不修改它的查询将会要求这个锁。

* `ROW SHARE`

  与 `EXCLUSIVE` 和  `ACCESS EXCLUSIVE` 冲突。

  `SELECT FOR UPDATE` 和 `SELECT FOR SHARE` 命令在目标表上要求这种锁（除过任何其他被引用但没有被 `FOR UPDAET / FOR SHARE` 的表上的 `ACCESS EXCLUSIVE`）。

* `ROW EXCLUSIVE`

  与 `SHARE`，`SHARE ROW EXCLUSIVE`，` EXCLUSIVE` 和 `ACCESS EXCLUSIVE` 冲突。

  命令 `UPDATE`、`DELETE` 和 `INSERT` 在目标表上要求这个锁（除过在任何其他被引用的表上的 `ACCESS SHARE` 锁）。一般，这个锁会被任何修改表数据的命令要求。

* `SHARE UPDATE EXCLUSIVE` 

  与 `SHARE UPDATE EXCLUSIVE`, `SHARE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE` 和 `ACCESS EXCLUSIVE` 冲突。这个模式保护表避免发生并发的 shema 变化并且运行 `VACUUM`。

* `SHARE`

  与 `ROW EXCLUSIVE`, `SHARE UPDATE EXCLUSIVE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE` 和`ACCESS EXCLUSIVE` 冲突。这个锁保护表不会被并发修改。

  被不带 `CONCURRENTLY` 的 `CREATE INDEX` 需要。

* `SHARE ROW EXCLUSIVE`

  与 `ROW EXCLUSIVE`, `SHARE UPDATE EXCLUSIVE`, `SHARE`, `SHARE ROW EXCLUSIVE`, `EXCLUSIVE` 和 `ACCESS EXCLUSIVE` 冲突。这个锁保护表不会被并发修改，并且是自xx的，所以一个时刻只有一个会话可以持有这个锁。

  `CREATE TRIGGER` 和 `ALTER TABLE` 的一些形式需要这个锁。

* `EXCLUSIVE`

  这个锁仅允许 `ACCESS SHARE` 锁，例如，仅从可以用一个持有这个锁的事务的表中读取。



### 13.3.2 行级锁





### 13.3.3 页级锁

​		除过表级锁和行级锁，页级的 share/exclusive 锁被用来控制 读取/写入 表的页面，在共享的缓存池中。这些锁在一个行被获取或更新后立即被释放。应用程序开发者正常情况下不需要关心叶级锁，但是为了叙述完整，它们在这被提到。



### 13.3.4 死锁

​		使用显式锁会增加死锁的可能性，在死锁中，两个事务(或多个)事务互相持有对方想要的锁。例如，如果事务 1 要求一个表 A 上的 exclusive 锁并且想要获取表 B 上的 exclusive 锁，而事务 2 早已持有表 B 上的 exclusive 锁，



### 13.3.5 意向锁



