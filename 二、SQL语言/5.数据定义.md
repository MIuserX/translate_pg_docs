

### 5.1 表的基础知识

英文：https://www.postgresql.org/docs/13/ddl-basics.html

​		关系型数据库中的表非常像我们打印在纸上的表格：由行和列构成。列的数量和顺序是固定的，每个列都有个名字。行的数量是变化的 - 这表示某个时刻表中所存储的数据。SQL 并不保证查出来的行的顺序。当读取一个表的时候，行将会以顺序未定义的情况出现，除非显式指定了排序。这在 [Chapter 7](https://www.postgresql.org/docs/13/queries.html) 中被描述。进一步，SQL 也不会为每一行做唯一约束，所以一个表中可能有完全相同的行。这是基于 SQL 的数学模型必然的结果，但这可能不是我们想要的。在后续的章节里，我们会讨论怎么处理这种情况。

​		每个列都有数据类型。数据类型包含了能赋值给列的可能的值的集合，也赋予了存储在列中的数据以语义以便于被用作运算。一个例子，被声明为一个数字类型的列不能接受任意字符串值，而且这个列的存储的值可以被用来进行数学运算。与之形成对比的是，被声明为字符串类型的列能接受几乎所有类型的数据但并不能让它自己用于数学计算，即使其他的操作像字符串粘接是允许的。

​		pg 内置了很多的数据类型，能适应大部分应用程序。用户也可以自定义数据类型。大部分内置数据类型拥有明显的名字和语义，所以我们后续在 [Chapter 8](https://www.postgresql.org/docs/13/datatype.html) 详细解释。最常用的数据类型有 `integer` 对于整数，`numeric` 对于小数，`text` 对于字符串，`date` 对于日期，`time` 对于时间值，`timestamp` 对于同时包含日期和时间的值。

​		要创建一个表，可以用 `CREATE TABLE` 命令。在这个命令中，至少要为新表指定一个名字，列的名字和数据类型。例如：

```sql
CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);
```

​		上述 SQL 创建一个叫 `my_first_table` 的表，有两个列。第一个列 `first_column` 数据类型为 `text`；第二个列 `second_column` 数据类型是 `integer`。表名与列名遵循标识符语法规则(在 [Section 4.1.1](https://www.postgresql.org/docs/13/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS) 中描述)。数据类型的名字也是标识符，但也有一些例外。注意列的列表是用逗号分开的，并且被圆括号括起来。

​		当然，前面的例子太刻意了。正常情况下，你赋予表和列的名字会暗示其存储什么种类的数据。所以更接近现实的 SQL 是：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);
```

 		(`numeric` 类型可以存储小数，典型的应用是存储金钱数量。)

> **Tip**
>
> ​		当你要创建大量互相有联系的表时，对表名和列名使用一种统一的命名模式是非常有用的。例如，使用单数或复数形式的表名，这两种形式都有支持的理论家。

​		一个表包含的列的个数是有上限的。根据列的类型，列的个数在 250 到 1600 之间。然后，定义一个包含很多列的表大概率是不常见的且是有问题的设计。

​		如果某个表不用了，你可以用 `DROP TABLE` 命令删除它。例如：

```sql
DROP TABLE my_first_table;
DROP TABLE products;
```

​		尝试删除一个不存在的表会导致报错。然而，在创建表前进行无条件地删除而忽略报错在 SQL 脚本中是非常普遍的，所以无论这个表是否存在这个脚本都能工作。(如果你喜欢，你可以用 `DROP TABLE IF EXISTS` 来避免报错，但不是SQL标准。)

​		如果你需要修改一个表的结构，看 [Section 5.6](https://www.postgresql.org/docs/13/ddl-alter.html)。

​		使用到目前为止我们讨论的工具，你已经可以创建一个完全有实际意义的表。这个章节的后续部分是关于为表定义添枝加叶，来保证数据的完整性，安全性，或者易用性。如果你急着向表里添加数据你可以跳到 [Chapter 6](https://www.postgresql.org/docs/13/dml.html) 读这个章节的后面部分。



### 5.2 默认值

英文：https://www.postgresql.org/docs/13/ddl-default.html

​		列可以被赋予默认值。当创建一个新行时，如果有些列没有被指定值，那么就会使用默认值。数据操纵语句也可以显式的使用将列设置为默认值，而无需知道列的默认值具体时什么。(关于数据操作的细节在 [Chapter 6](https://www.postgresql.org/docs/13/dml.html) 。)

​		如果没有显式的指定默认值，默认值是 NULL。这个规则大部分时间是有意义的，因为 NULL 可以被解读为未知的数据。

​		在一个表定义中，默认值被写在列的数据类型后面。例如：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric DEFAULT 9.99
);
```

​		默认值可以是一个表达式，这个表达式将会在创建行的时候求值(而不是建表的时候)。一个关于 `timestamp` 的常见默认值是 `CURRENT_TIMESTAMP` ，当插入行的时候被设置。另一个常见的例子是为每个行生成一个 “序列号”。在 pg 中，典型的做法是：

```sql
CREATE TABLE products (
    product_no integer DEFAULT nextval('products_product_no_seq'),
    ...
);
```

​		`nextval()` 函数会应用 ***序列号对象***([Section 9.7 中描述](https://www.postgresql.org/docs/13/functions-sequence.html)) 的合适的值。这种管理方法是如此广泛地使用，所以有个特殊的缩写：

```sql
CREATE TABLE products (
    product_no SERIAL,
    ...
);
```

​		`SERIAL` 被在 [Section 8.1.4](https://www.postgresql.org/docs/13/datatype-numeric.html#DATATYPE-SERIAL) 中讨论。



### 5.3 generated columns

英文：https://www.postgresql.org/docs/13/ddl-generated-columns.html

​		generated column 是一种特殊的列，它可以用其他列计算得来。因此，这是表的视图列而生的。有两种 generated column：stored 和 virtual。一个 stored generated column 在它被写入的时候(insert 或 update) 进行计算，并且占用存储空间就好像它是一个真正的列。一个 virtual generated column 不占用存储空间，当它被读取的时候才会被计算。因此，一个 virtual generated column 和视图很相似，一个 stored generated column 和物化视图非常相似(除过，它会自动更新)。pg 目前只实现了 stored generated column 。

​		要创建一个 generated column ，在 `CREATE TABLE` 子句中使用 `GENERATED ALWAYS AS` 子句，例如：

```sql
CREATE TABLE people (
    ...,
    height_cm numeric,
    height_in numeric GENERATED ALWAYS AS (height_cm / 2.54) STORED
);
```

​		关键字 `STORED` 必须被使用来指定 generated column 的类型。欲了解更多细节看 [CREATE TABLE](https://www.postgresql.org/docs/13/sql-createtable.html)。

​		generated column 不能直接写。在 `INSERT` 和 `UPDATE` 命令中，不能为 generated column 指定值，但是默认值关键字 `DEFAULT` 可以使用。

​		思考一下一个带默认值的列与一个 generated column 的不同点。对于列的默认值，当插入行的时候没指定值的时候会被计算；一个 generated column 在更新行的时候自动更新，而且不能被覆盖。列的默认值不太可能会引用表中的其他列；一个 generation 表达式一般会引用表中的其他列。列的默认值可以使用不稳定的函数，例如 `random()` ，或者使用表示当前时间的函数；这在 generated column 中是不允许的。

​		下面是一些关于定义 generated column 和 表引用generated column 的限制：

* generation 表达式只能使用稳定的函数，不能用子查询，不能引用当前行之外的任何东西。
* generation 表达式不能引用另一个 generated column。
* generation 表达式不能引用系统列，除过 `tableoid`。
* generated column 不能有默认值和唯一约束。
* generated column 不能是 partition key 的一部分。
* 外部表不能有 generated column。详情看 [CREATE FOREIGN TABLE](https://www.postgresql.org/docs/13/sql-createforeigntable.html)。
* 对于继承：
  * 如果父列是一个 generated column，子列也必须是使用相同表达式的 generated column。在子列定义中，xxx，因为会从父列中复制。
  * 在多继承情况中，如果一个父列是 generated column，所有的父列必须是使用相同表达式的 generated column。
  * 如果父列不是 generated column，子列可以是 generated column 也可以不是。



​		其他一些关于使用 generated column 的要考虑点：

* generated column 的访问权限与它的基础列是相互独立的。所以，我们可以管理，让一个特定的角色可以读取 generated column 而不能读取它的基础列。
* 从概念上讲，generated column 在 `BEFORE` 触发器运行之后才会更新。因此，在 `BEFORE` 触发器中修改基础列的值将会影响到 generated column。但实际上恰恰相反，在 `BEFORE` 触发器中不允许访问  generated column。



### 5.4 约束

英文：https://www.postgresql.org/docs/13/ddl-constraints.html

​		数据类型是一种限制数据种类的方式。然而大部分应用程序提供的约束都太过粗略。例如，一个存储产品价格的列应该只接受正数。但没有一种标准类型是只接受正数的。另一个问题是如果你想一个列的数据被其他列或其他行约束。例如，在一个产品信息表里，对于每个产品应该只有一行。

​		为了这个目的，SQL 允许你在列或表上定义约束。约束使你能给表的数据施以更多的控制。如果用户想要向一个列中存储违反其约束的值，会收到一个报错。即使违反约束的值来源于默认值，这个规则依然生效。



#### 5.4.1 check 约束

​		一个 check 约束是最一般的约束类型。这允许你为某个列指定一个布尔表达式，这个列的值必须遵循这个布尔表达式。例如，要求价格必须为正数，你可以：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0)
);
```

​		如你所见，约束定义在数据类型后面，就像默认值定义一样。默认值与约束的顺序可以颠倒。一个 check 约束的定义由 `CHECK` 关键字后跟着圆括号括起来的表达式。chech 约束的表达式应该引用被约束的列，否则约束表达式没有意义。

​		你以可以给约束一个独立的名字。这可以让报错信息更加清晰，并且你可以通过这个名字来也引用约束当你需要修改它的时候。语法如下：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CONSTRAINT positive_price CHECK (price > 0)
);
```

​		因此，指定一个有名字的约束时，使用关键字 `CONSTRAINT` ，后跟着一个标识符，再跟着约束定义。(如果你不移这种方式指定约束的名字，系统将会自己给个名。)

​		check 约束也可以引用多个列。你要存储一个一般价格和打折后的价格，并且想要保证打折价格低于一般价格：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
```

​		上面例子中，前两个约束看起来非常相似。第三个约束使用了一个新语法。他没有与任何一个具体的列关联起来，而是作为一个独立的元素列在逗号分隔的列列表里。列定义与约束定义可以混合在一起。

​		我们说前两个约束是列级约束，然而第三个约束是表级约束，因为它没有被关联到任何一个列上。列级约束也可以被写为表级约束，但反过来则不行，因为列级约束被假定为只会引用它关联的列。(pg 不强制这个规则，但如果你想表定义语句也能适应于其他数据库系统，最好遵循这个约束。) 上面的例子也可以被写为：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
```

​		或者甚至：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0 AND price > discounted_price)
);
```

​		使用哪种，是个人便好的问题。

​		也可以用向列级约束赋予名字同样的方式向表级约束赋予名字：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0),
    CONSTRAINT valid_discount CHECK (price > discounted_price)
);
```

​		应该注意的是，check 约束当表达式被求值为 true 或 null 时才会被认为符合约束。因为如果有一个操作数是 null ，大部分表达式就会被求值为 null，所以 check 约束不会禁止被约束的列为 null 。为了保证一个列不包含 null 值，可以使下个小节将要描述的 not-null 约束。

> **Note**
>
> ​		pg 不支持 xxx。有时违反了这个规则的约束在简单的测试中能生效，但这不能保证数据不会到达某个使得 check 表达式为 false 的状态(由于被引用的其他行的子序列改变)。这将会导致数据库 dump 和重载错误。重载将会错误，尽管整个数据库对于约束是一致的，因为在某种顺序下的没有加载的数据将会符合约束。如果可能，使用 `UNIQUE`, `EXCLUDE`, `FOREIGN KEY` 约束来表达跨行和跨表的限制。
>
> ​		如果你想要的是一次性检查在其他行的背景下在插入行的时候，而不是一个持续维护的一致性保证，一个自定义 [触发器](https://www.postgresql.org/docs/13/triggers.html) 可以被用来满足需要。(这个方法会防止 dump/reload 问题，因为 pg_dump 不会重新安装触发器，直到重载数据之后，所以 check 约束不会在 dump/reload 期间被强制执行。)





#### 5.4.2 Not-Null 约束



#### 5.4.3 唯一约束



#### 5.4.4 主键



#### 5.4.5 外健



#### 5.4.6 exclusion 约束





