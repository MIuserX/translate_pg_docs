## 7.1 概述(4700)

​		从数据库获取数据的过程和命令被叫做 ***查询***。SQL 中 [SELECT](https://www.postgresql.org/docs/13/sql-select.html) 被用来指定查询。SELECT 的通用语法是：

```sql
[WITH with_queries] SELECT select_list FROM table_expression [sort_specification]
```

​		接下里的小节描述的 select list、表表达式、排序方法 的细节。`WITH` 查询被最后阐述，因为这是高级特性。

​		一个简单的查询具有以下形式：

```sql
SELECT * FROM table1;
```

​		假定存在一个表 `table1`，上面的命令将会获取 `table1` 的所有行的用户自定义列。(获取数据的方法依赖于客户端程序。例如，psql程序将会将会在屏幕上显示 ASCII 风格的表，客户端库将会提供函数来从查询结果中提取单个值。) select list 指定 `*` 意味着表的所有列。select list 也可以只是表的列一个子集，或者利用列计算的表达式。例如，如果表 `table1` 拥有列 `a, b, c` 你可以写下面的查询：

```sql
SELECT a, b + c FROM table1;
```

 		(假定 `b, c` 是数字类型)，看 [Section 7.3](https://www.postgresql.org/docs/13/queries-select-lists.html) 更多细节。

​		`FROM table1` 是一个简单的表表达式：这只从一个表读取。一般，表表达式可以是由基本表、join、子查询组成的复杂形式。你也可以完全省略表表达式，将 SELECT 作为一个计算器：

```sql
SELECT 3 * 4;
```

​		这对于 select list 中的表达式返回各种各样的结果时更有用。例如，你可以调用函数：

```sql
SELECT random();
```



## 7.2 表表达式

​		一个表表达式计算出一个表。表表达式包含一个可能带 `WHERE` 子句、`GROUP BY` 子句、`HAVING` 子句的 `FROM` 子句。简单的表表达式仅仅引用一个表，也就是所谓的基础表，更复杂的表达式能以各种方式修改或连接基础表。

​		表表达式中可选的 `WHERE`、`GROUP BY`、`HAVING` 子句指定了对来自 `FROM` 子句中的表所进行的一系列转换操作。所有的这些转换操作产生了一个虚拟表，这个虚拟表的行被传递给 select list，用来计算查询的最终输出。



### 7.2.1 FROM 子句

​		[FROM](https://www.postgresql.org/docs/13/sql-select.html#SQL-FROM) 子句源自一个表，这个表来自于一个或多个其他的表，由一个给定的以逗号分隔的表引用列表。

```sql
FROM table_reference [, table_reference [, ...]]
```

​		一个表引用(table_reference)可以是一个表名(可能带有 schema 前缀)，可能是个派生表(例如子查询)，可能是个 JOIN 结构，可能是前述类型结合成的复杂表达式。如果超过一个的表引用被写在 `FROM` 子句中，这些表被顺序 JOIN(这是说，是这些表的行的笛卡尔积。看后面的描述)。`FROM list` 的结果是一个虚拟的中间表，这个表被传递给 `WHERE`、`GROUP BY`、`HAVING` 子句，最终产生表表达式的最终结果。

​		当一个表引用表示一个继承结构的父表时，这个表引用不仅产生父表的行，而会产生包括它的所有子代的表的行，除非表名前些了 `ONLY` 关键字。然而，表引用仅产生所指定的表的列，任何子表中添加的列将别忽略。

​		除过在表名前加 `ONLY`，你也可以在表名后面加 `*` 显式地指定子代表被包括进去。现在已经没有理由使用这种语法了，因为子代表被包含进去已经是默认行为了。然而，还支持这个语法为了兼容老版本。



#### 7.2.1.1 Joined Tables

​		一个 join table 是派生自两个其他(真实的或派生的)表，根据特定的 join 类型的规则。inner、outer、cross-join 三种 join 类型。join table 的一般语法是：

```sql
T1 join_type T2 [ join_condition ]
```

​		所有类型的 join 都可以串成链，或者嵌套：`T1` 和 `T2` 中的一个或多个都可以是 join table。可以在 join 子句中用圆括号来控制 join 顺序。如果没有圆括号，join 按照从左往右的顺序。

##### cross join

```sql
T1 CROSS JOIN T2
```

​		对于 `T1` 和 `T2` 的每个行都存在可能的连接(笛卡尔积)，join 后的表的行包含 `T1` 的所有列拼接上 `T2` 的所有列。如果两个表分别有 N 行和 M 行，join 后的表有 N * M 行。

​		`FROM T1 CROSS JOIN T2` 等价于 `FROM T1 INNER JOIN ON TRUE` 。也等价于 `FROM T1, T2`。

> **Note**
>
> ​		最后一种形式在 join 的表超过两个时就不一定等价了，因为 JOIN 比逗号绑定地更轻量级。例如，`FROM T1 CROSS JOIN T2 INTER JOIN T3 ON condition` 与 `FROM T1, T2 INNER JOIN T3 ON condition` 不同，因为第一种形式中 `condition` 可以引用 `T2` 但第二种不行。



##### qualified joins

```sql
T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 ON boolean_expression
T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 USING ( join column list )
T1 NATURAL { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2
```

 		在所有的形式中，`INNER` 和 `OUTER` 都是可选的。`INNER` 是默认的，`LEFT, RIGHT, FULL` 应用于 `outer join`。

​		join 条件(join condition) 被用 `ON` 子句或 `USING` 子句，或者隐式的 `NATURAL` 。join 条件决定两个源表的那些行被认为是匹配的，细节在下面解释。

​		可能的 join 类型有：

* **inner join**

  对于 `T1` 的每个行 `R1`，在 `T2` 中寻找满足 join 条件的行 `R2`，每个 `R2` 在 join 结果中都存在一行。

* **left outer join**

  首先，执行 inner join。然后，对于 `T1` 中的不能 join 上  `T2`  中任何一行的行，将其加入到 inner join 的结果中，`T2` 的列取 null 值。这样，对于 `T1` 中的每一行，至少在 join 结果中出现一次。

* **right outer join**

  首先，执行 inner join。然后，对于 `T2` 中的不能 join 上 `T1` 中任何一行的行，将其加入到 inner join 的结果中，`T1` 的列取 null 值。这样，对于 `T2` 中的每一行，至少在 join 结果中出现一次。

* **full outer join**

  首先，执行 inner join。然后，对于 `T1` 中的不能 join 上  `T2`  中任何一行的行，将其加入到 inner join 的结果中，`T2` 的列取 null 值。同样，对于 `T2` 中的不能 join 上 `T1` 中任何一行的行，将其加入到 inner join 的结果中，`T1` 的列取 null 值。



​		`ON` 子句是 join 条件最普遍的形式：后面跟着一个跟 `where` 子句一样的布尔表达式。当布尔表达式为 true 的时候，`T1` 和 `T2` 中的行对是匹配的。

​		`USING` 子句是一种简写形式，在这种场景下，join 两边的表在 join 条件中使用同名的列。后面跟着一个逗号分隔的列名列表，这会形成包含每个列相等判断的 join 条件。例如，`T1` 和 `T2` join 使用 `USING (a, b)` ，会产生 `ON T1.a = T2.a AND T1.b = T2.b`。

​		更进一步，`JOIN USING` 的输出省略了冗余列：没有必要将同样的列打印多次，因为它们拥有相等的值 。`JOIN ON` 会打印所有列，`T1` 的所有列跟着 `T2` 的所有列，而 `JOIN USING` ，对于每个列出的列，只会输出一次(按照列出的顺序)，后面再打印 `T1` 中剩下的列，最后打印 `T2` 中剩下的列。

​		最后，`NATURAL` 是 `USING` 形式的缩写：这会将两个输入表的所有列写在 `USING` 后面。使用 `USING` ，这些列在输出中仅出现一次。如果两个输入表没有相同的列名，`NATURAL JOIN` 会像 `JOIN ... ON TRUE`  一样运算，产生一个笛卡尔积。

> **Note**
>
> ​		`USING` 比 `NATURAL` 更加安全，因为如果列发生变化， `USING` 只受指定的列的影响，而 `NATURAL` 受所有列的影响。



​		To put this together，假设我们有两个表：

`t1`

```sql
 num | name
-----+------
   1 | a
   2 | b
   3 | c
```

`t2`

```sql
 num | value
-----+-------
   1 | xxx
   3 | yyy
   5 | zzz
```

​		然后，我们能得到不同形式的 join 结果：

```sql
=> SELECT * FROM t1 CROSS JOIN t2;
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

=> SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)

=> SELECT * FROM t1 INNER JOIN t2 USING (num);
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

=> SELECT * FROM t1 NATURAL INNER JOIN t2;
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

=> SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

=> SELECT * FROM t1 LEFT JOIN t2 USING (num);
 num | name | value
-----+------+-------
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

=> SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

=> SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)
```

​		`ON` 指定的 join 条件。例如：

```sql
=> SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)
```

​		注意，把约束条件放在 `WHERE` 子句里会产生不同的结果：

```sql
=> SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
(1 row)
```

​		这是因为放在 `ON` 子句里的约束被在 join 之前处理，而放在 `WHERE` 子句里的约束被在 join 之后处理。对于 inner join 两者等价，但在 outer join 里，不一样。



#### 7.2.1.2 表和列的别名

​		可以给表和复杂的表引用一个别名，这样在查询的后面部分便可以使用别名来引用派生表。这被叫做表别名。

​		要使用表别名，这样写：

```sql
FROM table_reference AS alias
```

​		或

```sql
FROM table_reference alias
```

​		`AS` 关键字是可选的。`alias` 可以是任何标识符。

​		表别名的一个典型应用是给表名太长的表赋予一个短名字，来保持 join 子句的可读性。例如：

```sql
SELECT * 
FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;
```

​		别名变成了表引用的新名字... - 在查询的任何地方都不能再使用原来的名字来引用表。因此，这是不合法的：

```sql
SELECT * FROM my_table AS m WHERE my_table.a > 5;    -- wrong
```

​		传统意义上，表别名主要是为了方便，但表自身做 join 的时候，别名是必须的。例如：

```sql
SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;
```

​		另外，当表引用是个子查询时，必须使用别名(看 [Section 7.2.1.3](https://www.postgresql.org/docs/13/queries-table-expressions.html#QUERIES-SUBQUERIES))。

​		圆括号被用来解决二义性的问题。在下面的例子中，第一个语句将别名 `b` 赋予 join 的第二个表，第二个语句将 `b` 赋予 join 的结果：

```sql
SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...
```

​		表别名的另一种形式给予 表、表的列 一个临时名字：

```sql
FROM table_reference [AS] alias ( column1 [, column2 [, ...]] )
```

​		这个语法对于表自身 join 和子查询特别有用。

​		当别名被应用于 `JOIN` 子句的输出时，这个别名隐藏了 `JOIN` 子句内部的原本的名字。例如：

```sql
SELECT a.* FROM my_table AS a JOIN your_table AS b ON ...
```

​		是一个合法的 SQL。但是：

```sql
SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c
```

​		是非法的，表别名 `a` 是在别名 `c` 之外是不可见的。



#### 7.2.1.3 子查询

​		指定了派生表的子查询必须用圆扣号括起来，并且必须被赋予一个别名(看 [Section 7.2.1.2](https://www.postgresql.org/docs/13/queries-table-expressions.html#QUERIES-TABLE-ALIASES))。例如：

```sql
FROM (SELECT * FROM table1) AS alias_name
```

​		这个例子与 `FROM table1 AS alias_name` 是等价的。更有趣的例子，这些例子不能变换为朴素的 join 形式，当子查询调用了 `group by` 或 聚合函数的时候，会出现。

​		一个子查询也可以是 `VALUES` 列表：

```sql
FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS names(first, last)
```

​		再说一次，表别名是必须的。为 `VALUES` 列表的列赋予别名是可选的，但是一个好的实践。更多信息看 [Section 7.7](https://www.postgresql.org/docs/13/queries-values.html) 。



#### 7.2.1.4 表函数

​		表函数是一类返回一个行的集合的函数，由任何基础数据类型(标量数据类型)或复合数据类型(表的行)。它们被像表、视图、子查询那样使用在 `FROM` 子句中。表函数返回的列可以被包括在 `SELECT`、`JOIN` 或 `WHERE` 子句中，以一种与 表、视图、子查询 同样的方式。

​		表函数也可能被联合使用在 `ROWS FROM` 语法中，结果在并行列中被返回。在这种情况下，结果行的数量是函数结果的最大数量，带着更小的结果用 null 值来填补，去匹配。

```sql
function_call [WITH ORDINALITY] [[AS] table_alias [(column_alias [, ... ])]]
ROWS FROM( function_call [, ... ] ) [WITH ORDINALITY] [[AS] table_alias [(column_alias [, ... ])]]
```



​		如果 `WITH ORDINALITY` 子句被调用，一个额外的列会被添加到结果列，类型是 bigint。这个列为结果行编号，从 1 开始。(这是 SQL 标准语法 `UNNEST ... WITH ORDINALITY` 的一般化形式。) 默认情况下，序数列名是 `ordinality`，但可以用 `AS` 子句赋予一个不同的列名。

​		特殊的表函数 `UNNEST` 可以被任何数量的数组参数调用，它返回相应数量列，就好像被每个参数独立调用然后使用 `ROWS FROM` 结构联合起来。

```sql
UNNEST( array_expression [, ... ] ) [WITH ORDINALITY] [[AS] table_alias [(column_alias [, ... ])]]
```

​		如果没指定 `table_alias` ，函数名被用作表名；在 `ROWS FROM` 结构的场景中，第一个函数的名字被使用。

​		如果没有提供列的别名，对于一个返回基础数据类型的函数，列名和函数名一致。对于一个返回复合数据类型的函数，结果列获取数据类型的单独的属性。

​		一些例子：

```sql
CREATE TABLE foo (fooid int, foosubid int, fooname text);

CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;

SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);

SELECT * FROM vw_getfoo;
```

​		在一些场景下定义可以根据被调用的方式返回不同列的表函数是非常有用的。为了支持这个功能，表函数可以被定义为返回伪类型 `record`，并且没有出参数。当查询中使用了这样一个函数，期望的行结构必须在查询自身中指定，这是系统可以知道怎么分析并执行查询。这个语法看起来像：

```sql
function_call [AS] alias (column_definition [, ... ])

function_call AS [alias] (column_definition [, ... ])

ROWS FROM( ... function_call AS (column_definition [, ... ]) [, ... ] )
```

​			当不使用 `ROWS FROM()` 语法时，`column_defination` 列表替代了可以被关联到 `FROM` 的列别名列表，`column_defination` 中的名字作为列别名。当使用 `ROWS FROM()` 语法时，一个 `column_defination` 列表可以被分别关联到每个成员函数，或者只有一个成员函数且没有 `NO ORDINALLY` 子句，一个 `column_defination` 列表可以写出来代替后面的列别名列表。



​		考虑这个例子：

```sql
SELECT *
    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
```

​		函数 [dblink](https://www.postgresql.org/docs/13/contrib-dblink-function.html) (模块 [dblink](https://www.postgresql.org/docs/13/dblink.html) 的一部分)执行一个远程查询。它被声明为返回 `record` ，因为它可能被应用于任何类型的查询。实际的列要被在调用语句中指出，让分析器知道，例如，`*` 会被扩展成的内容。

​		使用 `ROWS FROM` 的例子：

```sql
SELECT *
FROM ROWS FROM
    (
        json_to_recordset('[{"a":40,"b":"foo"},{"a":"100","b":"bar"}]')
            AS (a INTEGER, b TEXT),
        generate_series(1, 3)
    ) AS x (p, q, s)
ORDER BY p;

  p  |  q  | s
-----+-----+---
  40 | foo | 1
 100 | bar | 2
     |     | 3
```

​		它把两个函数 join 成一个单个的 from 对象。`json_to_recordset()` 被解构，返回两个列，第一个 `integer` 和第二个 `text`。`generate_series()` 的结果被直接应用。`ORDER BY` 子句将列值按照 integer 排序。



#### 7.2.1.5 平级子查询

​		出现在 `FROM` 中的子查询可以被优先于通过使用关键字 `LATERAL` 。这允许它们引用前面的 `FROM` 提供的列。()

​		出现在 `FROM` 中的表函数，也可以被关键字 `LATERAL` 提高优先级，但是对于函数，这个关键字时可选的；在任何情况下，函数的参数可以包含对对面的 `FROM` 提供的列的引用。

​		一个 `LATERAL` 项可以出现在 `FROM` 列表的顶层，或者在一个 `JOIN` 树中。在后一种情况下，它可以引用左边的 JOIN 的任何项目。

​		当一个 `FROM` 项包含 `LATERAL` 交叉引用，求值的进行过程如下：对于提供了交叉引用列的 `FROM` 项的每一行，或者提供列的多个 `FROM` 项的行的集合，`LATERAL` 项被使用那和列或那个列集合求值。结果行被执行 join 就像这些行的来源行那样。对于每行或每个行的集合都被执行一遍。

​		一个 `LATERAL` 的小例子：

```sql
SELECT * 
FROM 
   foo, 
   LATERAL (
     SELECT * 
     FROM bar 
     WHERE bar.id = foo.bar_id
   ) ss;
```

​		这不是特别有用，因为它跟下面这种更方便的形式结果一样：

```sql
SELECT * 
FROM foo, bar 
WHERE bar.id = foo.bar_id;
```

​		`LATERAL` 主要用于，当交叉引用列对于计算被 join 的行是必须的情况下。一个普遍的用法是为 set-returning 函数提供给一个参数值。例如，假定 `vertices(polygon)` 返回多边形的定点结合，我们可以确认 close-together 的顶点存储一个像这样的表中：

```sql
SELECT p1.id, p2.id, v1, v2
FROM polygons p1, polygons p2,
     LATERAL vertices(p1.poly) v1,
     LATERAL vertices(p2.poly) v2
WHERE (v1 <-> v2) < 10 AND p1.id != p2.id;
```

​		这个查询也可以为写为：

```sql
SELECT p1.id, p2.id, v1, v2
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2
WHERE (v1 <-> v2) < 10 AND p1.id != p2.id;
```

​		或者以其他几种等价的规划。(如前面提到的那样，`LATERAL` 关键字在这个例子中不是必须的，但我们用它来使说明更加清晰。)

​		经常特殊处理 `LEFT JOIN` 到 `LATERAL` 子查询，因此原始行将会出现在结果中，即使 `LATERAL` 子查询给他们返回了零行。例如，如果 `get_product_names()` 返回了厂商产生的产品名字，但表里的一些厂商当前没有产品，我们会找出哪些，用下列语句：

```sql
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;
```







