## 7.1 概述(7000)

​		从数据库获取数据的过程和命令被叫做 ***查询***。SQL 中 [SELECT](https://www.postgresql.org/docs/13/sql-select.html) 被用来指定查询。SELECT 的通用语法是：

```sql
[WITH with_queries] SELECT select_list FROM table_expression [sort_specification]
```

​		接下里的小节描述的 select list、表表达式、排序方法 的细节。`WITH` 查询被最后阐述，因为这是高级特性。

​		一个简单的查询具有以下形式：

```sql
SELECT * FROM table1;
```

​		假定存在一个表 `table1`，上面的命令将会获取 `table1` 的所有行的用户自定义列。(获取数据的方法依赖于客户端程序。例如，psql程序将会将会在屏幕上显示 ASCII 风格的表，客户端库将会提供函数来从查询结果中提取单个值。) select list 指定 `*` 意味着表的所有列。select list 也可以只是表的列一个子集，或者利用列计算的表达式。例如，如果表 `table1` 拥有列 `a, b, c` 你可以写下面的查询：

```sql
SELECT a, b + c FROM table1;
```

 		(假定 `b, c` 是数字类型)，看 [Section 7.3](https://www.postgresql.org/docs/13/queries-select-lists.html) 更多细节。

​		`FROM table1` 是一个简单的表表达式：这只从一个表读取。一般，表表达式可以是由基本表、join、子查询组成的复杂形式。你也可以完全省略表表达式，将 SELECT 作为一个计算器：

```sql
SELECT 3 * 4;
```

​		这对于 select list 中的表达式返回各种各样的结果时更有用。例如，你可以调用函数：

```sql
SELECT random();
```



## 7.2 表表达式

​		一个表表达式计算出一个表。表表达式包含一个可能带 `WHERE` 子句、`GROUP BY` 子句、`HAVING` 子句的 `FROM` 子句。简单的表表达式仅仅引用一个表，也就是所谓的基础表，更复杂的表达式能以各种方式修改或连接基础表。

​		表表达式中可选的 `WHERE`、`GROUP BY`、`HAVING` 子句指定了对来自 `FROM` 子句中的表所进行的一系列转换操作。所有的这些转换操作产生了一个虚拟表，这个虚拟表的行被传递给 select list，用来计算查询的最终输出。



### 7.2.1 FROM 子句

​		[FROM](https://www.postgresql.org/docs/13/sql-select.html#SQL-FROM) 子句源自一个表，这个表来自于一个或多个其他的表，由一个给定的以逗号分隔的表引用列表。

```sql
FROM table_reference [, table_reference [, ...]]
```

​		一个表引用(table_reference)可以是一个表名(可能带有 schema 前缀)，可能是个派生表(例如子查询)，可能是个 JOIN 结构，可能是前述类型结合成的复杂表达式。如果超过一个的表引用被写在 `FROM` 子句中，这些表被顺序 JOIN(这是说，是这些表的行的笛卡尔积。看后面的描述)。`FROM list` 的结果是一个虚拟的中间表，这个表被传递给 `WHERE`、`GROUP BY`、`HAVING` 子句，最终产生表表达式的最终结果。

​		当一个表引用表示一个继承结构的父表时，这个表引用不仅产生父表的行，而会产生包括它的所有子代的表的行，除非表名前些了 `ONLY` 关键字。然而，表引用仅产生所指定的表的列，任何子表中添加的列将别忽略。

​		除过在表名前加 `ONLY`，你也可以在表名后面加 `*` 显式地指定子代表被包括进去。现在已经没有理由使用这种语法了，因为子代表被包含进去已经是默认行为了。然而，还支持这个语法为了兼容老版本。



#### 7.2.1.1 Joined Tables

​		一个 join table 是派生自两个其他(真实的或派生的)表，根据特定的 join 类型的规则。inner、outer、cross-join 三种 join 类型。join table 的一般语法是：

```sql
T1 join_type T2 [ join_condition ]
```

​		所有类型的 join 都可以串成链，或者嵌套：`T1` 和 `T2` 中的一个或多个都可以是 join table。可以在 join 子句中用圆括号来控制 join 顺序。如果没有圆括号，join 按照从左往右的顺序。

##### cross join

```sql
T1 CROSS JOIN T2
```

​		对于 `T1` 和 `T2` 的每个行都存在可能的连接(笛卡尔积)，join 后的表的行包含 `T1` 的所有列拼接上 `T2` 的所有列。如果两个表分别有 N 行和 M 行，join 后的表有 N * M 行。

​		`FROM T1 CROSS JOIN T2` 等价于 `FROM T1 INNER JOIN ON TRUE` 。也等价于 `FROM T1, T2`。

> **Note**
>
> ​		最后一种形式在 join 的表超过两个时就不一定等价了，因为 JOIN 比逗号绑定地更轻量级。例如，`FROM T1 CROSS JOIN T2 INTER JOIN T3 ON condition` 与 `FROM T1, T2 INNER JOIN T3 ON condition` 不同，因为第一种形式中 `condition` 可以引用 `T2` 但第二种不行。



##### qualified joins

```sql
T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 ON boolean_expression
T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 USING ( join column list )
T1 NATURAL { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2
```

 		在所有的形式中，`INNER` 和 `OUTER` 都是可选的。`INNER` 是默认的，`LEFT, RIGHT, FULL` 应用于 `outer join`。

​		join 条件(join condition) 被用 `ON` 子句或 `USING` 子句，或者隐式的 `NATURAL` 。join 条件决定两个源表的那些行被认为是匹配的，细节在下面解释。

​		可能的 join 类型有：

* **inner join**

  对于 `T1` 的每个行 `R1`，在 `T2` 中寻找满足 join 条件的行 `R2`，每个 `R2` 在 join 结果中都存在一行。

* **left outer join**

  首先，执行 inner join。然后，对于 `T1` 中的不能 join 上  `T2`  中任何一行的行，将其加入到 inner join 的结果中，`T2` 的列取 null 值。这样，对于 `T1` 中的每一行，至少在 join 结果中出现一次。

* **right outer join**

  首先，执行 inner join。然后，对于 `T2` 中的不能 join 上 `T1` 中任何一行的行，将其加入到 inner join 的结果中，`T1` 的列取 null 值。这样，对于 `T2` 中的每一行，至少在 join 结果中出现一次。

* **full outer join**

  首先，执行 inner join。然后，对于 `T1` 中的不能 join 上  `T2`  中任何一行的行，将其加入到 inner join 的结果中，`T2` 的列取 null 值。同样，对于 `T2` 中的不能 join 上 `T1` 中任何一行的行，将其加入到 inner join 的结果中，`T1` 的列取 null 值。



​		`ON` 子句是 join 条件最普遍的形式：后面跟着一个跟 `where` 子句一样的布尔表达式。当布尔表达式为 true 的时候，`T1` 和 `T2` 中的行对是匹配的。

​		`USING` 子句是一种简写形式，在这种场景下，join 两边的表在 join 条件中使用同名的列。后面跟着一个逗号分隔的列名列表，这会形成包含每个列相等判断的 join 条件。例如，`T1` 和 `T2` join 使用 `USING (a, b)` ，会产生 `ON T1.a = T2.a AND T1.b = T2.b`。

​		更进一步，`JOIN USING` 的输出省略了冗余列：没有必要将同样的列打印多次，因为它们拥有相等的值 。`JOIN ON` 会打印所有列，`T1` 的所有列跟着 `T2` 的所有列，而 `JOIN USING` ，对于每个列出的列，只会输出一次(按照列出的顺序)，后面再打印 `T1` 中剩下的列，最后打印 `T2` 中剩下的列。

​		最后，`NATURAL` 是 `USING` 形式的缩写：这会将两个输入表的所有列写在 `USING` 后面。使用 `USING` ，这些列在输出中仅出现一次。如果两个输入表没有相同的列名，`NATURAL JOIN` 会像 `JOIN ... ON TRUE`  一样运算，产生一个笛卡尔积。

> **Note**
>
> ​		`USING` 比 `NATURAL` 更加安全，因为如果列发生变化， `USING` 只受指定的列的影响，而 `NATURAL` 受所有列的影响。



​		To put this together，假设我们有两个表：

`t1`

```sql
 num | name
-----+------
   1 | a
   2 | b
   3 | c
```

`t2`

```sql
 num | value
-----+-------
   1 | xxx
   3 | yyy
   5 | zzz
```

​		然后，我们能得到不同形式的 join 结果：

```sql
=> SELECT * FROM t1 CROSS JOIN t2;
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

=> SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)

=> SELECT * FROM t1 INNER JOIN t2 USING (num);
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

=> SELECT * FROM t1 NATURAL INNER JOIN t2;
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

=> SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

=> SELECT * FROM t1 LEFT JOIN t2 USING (num);
 num | name | value
-----+------+-------
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

=> SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

=> SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)
```

​		`ON` 指定的 join 条件。例如：

```sql
=> SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)
```

​		注意，把约束条件放在 `WHERE` 子句里会产生不同的结果：

```sql
=> SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
(1 row)
```

​		这是因为放在 `ON` 子句里的约束被在 join 之前处理，而放在 `WHERE` 子句里的约束被在 join 之后处理。对于 inner join 两者等价，但在 outer join 里，不一样。



#### 7.2.1.2 表和列的别名

​		可以给表和复杂的表引用一个别名，这样在查询的后面部分便可以使用别名来引用派生表。这被叫做表别名。

​		要使用表别名，这样写：

```sql
FROM table_reference AS alias
```

​		或

```sql
FROM table_reference alias
```

​		`AS` 关键字是可选的。`alias` 可以是任何标识符。

​		表别名的一个典型应用是给表名太长的表赋予一个短名字，来保持 join 子句的可读性。例如：

```sql
SELECT * 
FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;
```

​		别名变成了表引用的新名字... - 在查询的任何地方都不能再使用原来的名字来引用表。因此，这是不合法的：

```sql
SELECT * FROM my_table AS m WHERE my_table.a > 5;    -- wrong
```

​		传统意义上，表别名主要是为了方便，但表自身做 join 的时候，别名是必须的。例如：

```sql
SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;
```

​		另外，当表引用是个子查询时，必须使用别名(看 [Section 7.2.1.3](https://www.postgresql.org/docs/13/queries-table-expressions.html#QUERIES-SUBQUERIES))。

​		圆括号被用来解决二义性的问题。在下面的例子中，第一个语句将别名 `b` 赋予 join 的第二个表，第二个语句将 `b` 赋予 join 的结果：

```sql
SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...
```

​		表别名的另一种形式给予 表、表的列 一个临时名字：

```sql
FROM table_reference [AS] alias ( column1 [, column2 [, ...]] )
```

​		这个语法对于表自身 join 和子查询特别有用。

​		当别名被应用于 `JOIN` 子句的输出时，这个别名隐藏了 `JOIN` 子句内部的原本的名字。例如：

```sql
SELECT a.* FROM my_table AS a JOIN your_table AS b ON ...
```

​		是一个合法的 SQL。但是：

```sql
SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c
```

​		是非法的，表别名 `a` 是在别名 `c` 之外是不可见的。



#### 7.2.1.3 子查询

​		指定了派生表的子查询必须用圆扣号括起来，并且必须被赋予一个别名(看 [Section 7.2.1.2](https://www.postgresql.org/docs/13/queries-table-expressions.html#QUERIES-TABLE-ALIASES))。例如：

```sql
FROM (SELECT * FROM table1) AS alias_name
```

​		这个例子与 `FROM table1 AS alias_name` 是等价的。更有趣的例子，这些例子不能变换为朴素的 join 形式，当子查询调用了 `group by` 或 聚合函数的时候，会出现。

​		一个子查询也可以是 `VALUES` 列表：

```sql
FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS names(first, last)
```

​		再说一次，表别名是必须的。为 `VALUES` 列表的列赋予别名是可选的，但是一个好的实践。更多信息看 [Section 7.7](https://www.postgresql.org/docs/13/queries-values.html) 。



#### 7.2.1.4 表函数

​		表函数是一类返回一个行的集合的函数，由任何基础数据类型(标量数据类型)或复合数据类型(表的行)。它们被像表、视图、子查询那样使用在 `FROM` 子句中。表函数返回的列可以被包括在 `SELECT`、`JOIN` 或 `WHERE` 子句中，以一种与 表、视图、子查询 同样的方式。

​		表函数也可能被联合使用在 `ROWS FROM` 语法中，结果在并行列中被返回。在这种情况下，结果行的数量是函数结果的最大数量，带着更小的结果用 null 值来填补，去匹配。

```sql
function_call [WITH ORDINALITY] [[AS] table_alias [(column_alias [, ... ])]]
ROWS FROM( function_call [, ... ] ) [WITH ORDINALITY] [[AS] table_alias [(column_alias [, ... ])]]
```



​		如果 `WITH ORDINALITY` 子句被调用，一个额外的列会被添加到结果列，类型是 bigint。这个列为结果行编号，从 1 开始。(这是 SQL 标准语法 `UNNEST ... WITH ORDINALITY` 的一般化形式。) 默认情况下，序数列名是 `ordinality`，但可以用 `AS` 子句赋予一个不同的列名。

​		特殊的表函数 `UNNEST` 可以被任何数量的数组参数调用，它返回相应数量列，就好像被每个参数独立调用然后使用 `ROWS FROM` 结构联合起来。

```sql
UNNEST( array_expression [, ... ] ) [WITH ORDINALITY] [[AS] table_alias [(column_alias [, ... ])]]
```

​		如果没指定 `table_alias` ，函数名被用作表名；在 `ROWS FROM` 结构的场景中，第一个函数的名字被使用。

​		如果没有提供列的别名，对于一个返回基础数据类型的函数，列名和函数名一致。对于一个返回复合数据类型的函数，结果列获取数据类型的单独的属性。

​		一些例子：

```sql
CREATE TABLE foo (fooid int, foosubid int, fooname text);

CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;

SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);

SELECT * FROM vw_getfoo;
```

​		在一些场景下定义可以根据被调用的方式返回不同列的表函数是非常有用的。为了支持这个功能，表函数可以被定义为返回伪类型 `record`，并且没有出参数。当查询中使用了这样一个函数，期望的行结构必须在查询自身中指定，这是系统可以知道怎么分析并执行查询。这个语法看起来像：

```sql
function_call [AS] alias (column_definition [, ... ])

function_call AS [alias] (column_definition [, ... ])

ROWS FROM( ... function_call AS (column_definition [, ... ]) [, ... ] )
```

​			当不使用 `ROWS FROM()` 语法时，`column_defination` 列表替代了可以被关联到 `FROM` 的列别名列表，`column_defination` 中的名字作为列别名。当使用 `ROWS FROM()` 语法时，一个 `column_defination` 列表可以被分别关联到每个成员函数，或者只有一个成员函数且没有 `NO ORDINALLY` 子句，一个 `column_defination` 列表可以写出来代替后面的列别名列表。



​		考虑这个例子：

```sql
SELECT *
    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
```

​		函数 [dblink](https://www.postgresql.org/docs/13/contrib-dblink-function.html) (模块 [dblink](https://www.postgresql.org/docs/13/dblink.html) 的一部分)执行一个远程查询。它被声明为返回 `record` ，因为它可能被应用于任何类型的查询。实际的列要被在调用语句中指出，让分析器知道，例如，`*` 会被扩展成的内容。

​		使用 `ROWS FROM` 的例子：

```sql
SELECT *
FROM ROWS FROM
    (
        json_to_recordset('[{"a":40,"b":"foo"},{"a":"100","b":"bar"}]')
            AS (a INTEGER, b TEXT),
        generate_series(1, 3)
    ) AS x (p, q, s)
ORDER BY p;

  p  |  q  | s
-----+-----+---
  40 | foo | 1
 100 | bar | 2
     |     | 3
```

​		它把两个函数 join 成一个单个的 from 对象。`json_to_recordset()` 被解构，返回两个列，第一个 `integer` 和第二个 `text`。`generate_series()` 的结果被直接应用。`ORDER BY` 子句将列值按照 integer 排序。



#### 7.2.1.5 平级子查询

​		出现在 `FROM` 中的子查询可以被优先于通过使用关键字 `LATERAL` 。这允许它们引用前面的 `FROM` 提供的列。()

​		出现在 `FROM` 中的表函数，也可以被关键字 `LATERAL` 提高优先级，但是对于函数，这个关键字时可选的；在任何情况下，函数的参数可以包含对对面的 `FROM` 提供的列的引用。

​		一个 `LATERAL` 项可以出现在 `FROM` 列表的顶层，或者在一个 `JOIN` 树中。在后一种情况下，它可以引用左边的 JOIN 的任何项目。

​		当一个 `FROM` 项包含 `LATERAL` 交叉引用，求值的进行过程如下：对于提供了交叉引用列的 `FROM` 项的每一行，或者提供列的多个 `FROM` 项的行的集合，`LATERAL` 项被使用那和列或那个列集合求值。结果行被执行 join 就像这些行的来源行那样。对于每行或每个行的集合都被执行一遍。

​		一个 `LATERAL` 的小例子：

```sql
SELECT * 
FROM 
   foo, 
   LATERAL (
     SELECT * 
     FROM bar 
     WHERE bar.id = foo.bar_id
   ) ss;
```

​		这不是特别有用，因为它跟下面这种更方便的形式结果一样：

```sql
SELECT * 
FROM foo, bar 
WHERE bar.id = foo.bar_id;
```

​		`LATERAL` 主要用于，当交叉引用列对于计算被 join 的行是必须的情况下。一个普遍的用法是为 set-returning 函数提供给一个参数值。例如，假定 `vertices(polygon)` 返回多边形的定点结合，我们可以确认 close-together 的顶点存储一个像这样的表中：

```sql
SELECT p1.id, p2.id, v1, v2
FROM polygons p1, polygons p2,
     LATERAL vertices(p1.poly) v1,
     LATERAL vertices(p2.poly) v2
WHERE (v1 <-> v2) < 10 AND p1.id != p2.id;
```

​		这个查询也可以为写为：

```sql
SELECT p1.id, p2.id, v1, v2
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2
WHERE (v1 <-> v2) < 10 AND p1.id != p2.id;
```

​		或者以其他几种等价的规划。(如前面提到的那样，`LATERAL` 关键字在这个例子中不是必须的，但我们用它来使说明更加清晰。)

​		经常特殊处理 `LEFT JOIN` 到 `LATERAL` 子查询，因此原始行将会出现在结果中，即使 `LATERAL` 子查询给他们返回了零行。例如，如果 `get_product_names()` 返回了厂商产生的产品名字，但表里的一些厂商当前没有产品，我们会找出哪些，用下列语句：

```sql
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;
```



### 7.2.2 WHERE 子句

​		[WHERE](https://www.postgresql.org/docs/13/sql-select.html#SQL-WHERE) 子句的语法是：

```sql
WHERE search_condition
```

​		search_condition 可以是任何返回布尔值的 **值表达式**(看 [Section 4.2](https://www.postgresql.org/docs/13/sql-expressions.html))。

​		在 `FROM` 子句处理完成后，派生的虚拟表的每一行会被 search condition 再次检查。如果 condition 的结果为 true，这个行会被保留在结果表中，否则(例如，如果结果是 false 或 null)，这个行会被抛弃。典型的 search condition 至少会引用 `FROM` 子句生成的表的一个列；但这不是必须的，但这种 search condition 是相当无用的。

> **Note**
>
> ​		一个 inner join 的 join condition 可以被写为 WHERE 子句，也可以用 JOIN 子句。例如，下列表表达式是等价的：
>
> ```sql
> FROM a, b WHERE a.id = b.id AND b.val > 5
> ```
>
> 和
>
> ```sql
> FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val > 5
> ```
>
> 或者甚至
>
> ```sql
> FROM a NATURAL JOIN b WHERE b.val > 5
> ```
>
> ​		你使用哪种形式是风格问题。FROM 子句中的 JOIN 语法对于其他数据库系统可能不是兼容的，虽然它是 SQL 标准的一部分。对于 outer join ，没有其他选择：它们必须在 FROM 子句中。outer join 的 ON 子句或 USING 子句与 where condition 是不等价的，因为它会导致额外的行(哪些无法完成匹配的输入行)或者最终结果的某些行移除。



​		下面是一些 `WHERE` 子句的例子：

```sql
SELECT ... FROM fdt WHERE c1 > 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 > fdt.c1)
```

​		`fdt` 是 `FROM` 子句中的派生表。不满足 `WHERE` 子句中的 search condition 的行被从 `fdt` 中排除。注意标量子查询被作为值表达式的使用。就像任何其他的查询那样，子查询可以使用复杂的表表达式。也要注意 `fdt` 在子查询中是怎样被引用的。将 `c1` 写为 `fdt.c1` 仅仅在 `c1` 在子查询中也是派生表的列名的时候才是必须的。但无论是否必须，带表名前缀都让查询语句更加清晰。这个例子展示了，一个外部查询的列命名空间怎样扩展到它的内部查询。



### 7.2.3 GROUP BY 子句和 HAVING 子句

​		通过 `WHERE` 过滤器之后，派生输入表可能会被分组，使用 `GROUP BY` 子句，使用 `HAVING` 子句排除分组后的行。

```sql
SELECT select_list
FROM ...
[WHERE ...]
GROUP BY grouping_column_reference [, grouping_column_reference]...
```

​		[GROUP BY](https://www.postgresql.org/docs/13/sql-select.html#SQL-GROUPBY) 子句被用来将被指定的列上值相等的行分成一组。被指定的列的书写顺序不重要。效果是将所有在指定的列上拥有相同值的行合并为一行来表示组中的所有行。这么做是为了删除冗余或者在分组上应用聚合函数。例如：

```sql
=> SELECT * FROM test1;
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

=> SELECT x FROM test1 GROUP BY x;
 x
---
 a
 b
 c
(3 rows)
```

​		在第二个查询中，我们不能写 `SELECT * FROM test1 GROUP BY x`，因为对于列 `y`，没有单个值可以将整个行关联到某个分组。group-by 列可以在 select list 中引用，因为在每个组中，它们都有单个的值。

​		一般，如果一个表被分组，`GROUP BY` 中没列出的列，不可以被引用，除非这个列在聚合表达式中。一个使用聚合表达式的例子是：

```sql
=> SELECT x, sum(y) FROM test1 GROUP BY x;
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)
```

​		在这里 `sum` 是个聚合函数，它基于整个组计算出一个值。更多关于聚合函数的信息可以看 [Section 9.21](https://www.postgresql.org/docs/13/functions-aggregate.html)。

>**Tip**
>
>​		不使用聚合函数的分组有效地计算了一个列中的唯一值。这也可以使用 `DISTINCT` 子句(看 [Section 7.3.3](https://www.postgresql.org/docs/13/queries-select-lists.html#QUERIES-DISTINCT))。

​		下面是另一个例子：它计算每个产品的总销售额(而不是所有产品的总销售额)：

```sql
SELECT 
    product_id, 
    p.name, 
    (sum(s.units) * p.price) AS sales
FROM products p LEFT JOIN sales s USING (product_id)
GROUP BY 
    product_id, 
    p.name, 
    p.price;
```

​		在这个例子中，列 `product_id, p.name, p.price` 必须在 `GROUP BY` 子句中，因为它们被在 select list 中引用(but see below)。列 `s.units` 不必出现在  `GROUP BY` 子句中，因为它仅仅被使用在聚合表达式中(`sum(...)`)，这个聚合表达式表示一个产品的销售额。对于每个产品，这个查询返回一个关于这个产品总销售额的汇总行。

​		如果产品表这样设置，`product_id` 是主键，那么上面的例子中用 `product_id` 分组就行了，因为名字和价格将会功能性的依赖于产品 ID，对于每个产品 ID 组返回哪个名字和价格的值是没有二义性的。

​		在严格的 SQL 中，`GROUP BY` 只能根据源表的列进行分组，但 pg 对此进行了扩展，可以根据 select list 中的项进行分组。根据值表达式进行分组也是允许的。

​		如果一个表用 `GROUP BY` 进行了分组，并且只对某些分组感兴趣，这时可以使用 `HAVING` 子句，很像 `WHERE` 子句，从结果中删除不感兴趣的分组。语法是：

```sql
SELECT select_list 
FROM ... 
[WHERE ...] 
GROUP BY ... 
HAVING boolean_expression
```

 		`HAVING` 子句中的表达式可以引用已分组的表达式，也可以引用未分组的表达式(这个必须调用一个聚合函数)。

例子：

```sql
=> SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) > 3;
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

=> SELECT x, sum(y) FROM test1 GROUP BY x HAVING x < 'c';
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)
```

​		再次，一个更加贴近现实的例子：

```sql
SELECT 
    product_id, 
    p.name, 
    (sum(s.units) * (p.price - p.cost)) AS profit
FROM 
    products p LEFT JOIN sales s USING (product_id)
WHERE s.date > CURRENT_DATE - INTERVAL '4 weeks'
GROUP BY 
    product_id, 
    p.name, 
    p.price, 
    p.cost
HAVING sum(p.price * s.units) > 5000;
```

​		在上面的例子中，`WHERE` 子句通过一个未分组列进行过滤(只有4周内的销售，这个表达式才会为 true)，而 `HAVING` 子句获取总销售额超过 5000 的分组。注意，查询中的聚合表达式不必相同。

​		如果一个查询包含聚合函数调用，但没有 `GROUP BY` 子句，分组动作也会被执行：结果是一条(或者一条也没有，如果那一行被 `HAVING` 子句删除了的话)。如果它包含一个 `HAVING` 子句，结果也是 true，甚至没有聚合函数调用或者 `GROUP BY` 子句。



### 7.2.4 GROUP SETS，CUBE，ROLLUP

​		很多比上述例子复杂的分组操作很可能会用到概念：分组集合(grouping sets)。被 `FROM` 和 `WHERE` 子句选出的数据被每个指定的分组结合独立分组，每个分组的聚合计算按照简单 `GROUP BY` 子句的方式来，然后返回结果。例如：

```sql
=> SELECT * FROM items_sold;
 brand | size | sales
-------+------+-------
 Foo   | L    |  10
 Foo   | M    |  20
 Bar   | M    |  15
 Bar   | L    |  5
(4 rows)

=> SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ());
 brand | size | sum
-------+------+-----
 Foo   |      |  30
 Bar   |      |  20
       | L    |  15
       | M    |  35
       |      |  50
(5 rows)
```

​		`GROUPING SETS` 的每个子列表可以指定零或多个 列 或 表达式，并且按照直接在 `GROUP BY` 子句中那样被计算。一个空的 grouping set 意思是所有行被聚合到一个单个的组(这会被输出，即使没有一个输入行)，像上面描述的那个不带 `GROUP BY` 子句的聚合函数的例子那样。

​		对于没有出现分组列的 grouping sets，在结果中，对于分组列或分组表达式的引用被 null 值替代。要分别哪个将特定的输出分组，看 [Table 9.59](https://www.postgresql.org/docs/13/functions-aggregate.html#FUNCTIONS-GROUPING-TABLE) 。

​		有个标准的语法来指定两种常见类型的 grouping set。这个形式的一个子句：

```sql
ROLLUP ( e1, e2, e3, ... )
```

​		表示给定的表达式列表和这个列表的所有前缀(包括空列表)；因此它等价于：

```sql
GROUPING SETS (
    ( e1, e2, e3, ... ),
    ...
    ( e1, e2 ),
    ( e1 ),
    ( )
)
```

​		这对于分层数据的分析是非常常用的；例如，部门、系、全公司的总薪水。

​		这个形式的一个子句：

```sql
CUBE ( e1, e2, ... )
```

​		表示给定的列表和列表的所有子集()。因此：

```sql
CUBE ( a, b, c )
```

​		等价于：

```sql
GROUPING SETS (
    ( a, b, c ),
    ( a, b    ),
    ( a,    c ),
    ( a       ),
    (    b, c ),
    (    b    ),
    (       c ),
    (         )
)
```



​		`CUBE` 和 `ROLLUP` 的单个元素可以是表达式，后者圆括号括起来的子列表。在后一种情况下，子列表被像单一的单元来对待，对于生成 grouping sets 来说。例如：

```sql
CUBE ( (a, b), (c, d) )
```

等价于：

```sql
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b       ),
    (       c, d ),
    (            )
)
```



```sql
ROLLUP ( a, (b, c), d )
```

等价于：

```sql
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b, c    ),
    ( a          ),
    (            )
)
```



​		`COBE` 和 `ROLLUP` 结构可以直接用在 `GROUP BY` 子句中，也可以嵌套在 `GROUPING SETS` 子句中。如果一个 `GROUPING SETS` 子句别嵌套在另一个 `GROUPING SETS` 子句中，效果与所有内层`GROUPING SETS` 子句的元素被直接写在外层`GROUPING SETS` 子句中是相同的。