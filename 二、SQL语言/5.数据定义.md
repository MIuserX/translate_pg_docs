

### 5.1 表的基础知识

英文：https://www.postgresql.org/docs/13/ddl-basics.html

​		关系型数据库中的表非常像我们打印在纸上的表格：由行和列构成。列的数量和顺序是固定的，每个列都有个名字。行的数量是变化的 - 这表示某个时刻表中所存储的数据。SQL 并不保证查出来的行的顺序。当读取一个表的时候，行将会以顺序未定义的情况出现，除非显式指定了排序。这在 [Chapter 7](https://www.postgresql.org/docs/13/queries.html) 中被描述。进一步，SQL 也不会为每一行做唯一约束，所以一个表中可能有完全相同的行。这是基于 SQL 的数学模型必然的结果，但这可能不是我们想要的。在后续的章节里，我们会讨论怎么处理这种情况。

​		每个列都有数据类型。数据类型包含了能赋值给列的可能的值的集合，也赋予了存储在列中的数据以语义以便于被用作运算。一个例子，被声明为一个数字类型的列不能接受任意字符串值，而且这个列的存储的值可以被用来进行数学运算。与之形成对比的是，被声明为字符串类型的列能接受几乎所有类型的数据但并不能让它自己用于数学计算，即使其他的操作像字符串粘接是允许的。

​		pg 内置了很多的数据类型，能适应大部分应用程序。用户也可以自定义数据类型。大部分内置数据类型拥有明显的名字和语义，所以我们后续在 [Chapter 8](https://www.postgresql.org/docs/13/datatype.html) 详细解释。最常用的数据类型有 `integer` 对于整数，`numeric` 对于小数，`text` 对于字符串，`date` 对于日期，`time` 对于时间值，`timestamp` 对于同时包含日期和时间的值。

​		要创建一个表，可以用 `CREATE TABLE` 命令。在这个命令中，至少要为新表指定一个名字，列的名字和数据类型。例如：

```sql
CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);
```

​		上述 SQL 创建一个叫 `my_first_table` 的表，有两个列。第一个列 `first_column` 数据类型为 `text`；第二个列 `second_column` 数据类型是 `integer`。表名与列名遵循标识符语法规则(在 [Section 4.1.1](https://www.postgresql.org/docs/13/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS) 中描述)。数据类型的名字也是标识符，但也有一些例外。注意列的列表是用逗号分开的，并且被圆括号括起来。

​		当然，前面的例子太刻意了。正常情况下，你赋予表和列的名字会暗示其存储什么种类的数据。所以更接近现实的 SQL 是：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);
```

 		(`numeric` 类型可以存储小数，典型的应用是存储金钱数量。)

> **Tip**
>
> ​		当你要创建大量互相有联系的表时，对表名和列名使用一种统一的命名模式是非常有用的。例如，使用单数或复数形式的表名，这两种形式都有支持的理论家。

​		一个表包含的列的个数是有上限的。根据列的类型，列的个数在 250 到 1600 之间。然后，定义一个包含很多列的表大概率是不常见的且是有问题的设计。

​		如果某个表不用了，你可以用 `DROP TABLE` 命令删除它。例如：

```sql
DROP TABLE my_first_table;
DROP TABLE products;
```

​		尝试删除一个不存在的表会导致报错。然而，在创建表前进行无条件地删除而忽略报错在 SQL 脚本中是非常普遍的，所以无论这个表是否存在这个脚本都能工作。(如果你喜欢，你可以用 `DROP TABLE IF EXISTS` 来避免报错，但不是SQL标准。)

​		如果你需要修改一个表的结构，看 [Section 5.6](https://www.postgresql.org/docs/13/ddl-alter.html)。

​		使用到目前为止我们讨论的工具，你已经可以创建一个完全有实际意义的表。这个章节的后续部分是关于为表定义添枝加叶，来保证数据的完整性，安全性，或者易用性。如果你急着向表里添加数据你可以跳到 [Chapter 6](https://www.postgresql.org/docs/13/dml.html) 读这个章节的后面部分。



### 5.2 默认值

英文：https://www.postgresql.org/docs/13/ddl-default.html

​		列可以被赋予默认值。当创建一个新行时，如果有些列没有被指定值，那么就会使用默认值。数据操纵语句也可以显式的使用将列设置为默认值，而无需知道列的默认值具体时什么。(关于数据操作的细节在 [Chapter 6](https://www.postgresql.org/docs/13/dml.html) 。)

​		如果没有显式的指定默认值，默认值是 NULL。这个规则大部分时间是有意义的，因为 NULL 可以被解读为未知的数据。

​		在一个表定义中，默认值被写在列的数据类型后面。例如：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric DEFAULT 9.99
);
```

​		默认值可以是一个表达式，这个表达式将会在创建行的时候求值(而不是建表的时候)。一个关于 `timestamp` 的常见默认值是 `CURRENT_TIMESTAMP` ，当插入行的时候被设置。另一个常见的例子是为每个行生成一个 “序列号”。在 pg 中，典型的做法是：

```sql
CREATE TABLE products (
    product_no integer DEFAULT nextval('products_product_no_seq'),
    ...
);
```

​		`nextval()` 函数会应用 ***序列号对象***([Section 9.7 中描述](https://www.postgresql.org/docs/13/functions-sequence.html)) 的合适的值。这种管理方法是如此广泛地使用，所以有个特殊的缩写：

```sql
CREATE TABLE products (
    product_no SERIAL,
    ...
);
```

​		`SERIAL` 被在 [Section 8.1.4](https://www.postgresql.org/docs/13/datatype-numeric.html#DATATYPE-SERIAL) 中讨论。



### 5.3 generated columns

英文：https://www.postgresql.org/docs/13/ddl-generated-columns.html

​		generated column 是一种特殊的列，它可以用其他列计算得来。因此，这是表的视图列而生的。有两种 generated column：stored 和 virtual。一个 stored generated column 在它被写入的时候(insert 或 update) 进行计算，并且占用存储空间就好像它是一个真正的列。一个 virtual generated column 不占用存储空间，当它被读取的时候才会被计算。因此，一个 virtual generated column 和视图很相似，一个 stored generated column 和物化视图非常相似(除过，它会自动更新)。pg 目前只实现了 stored generated column 。

​		要创建一个 generated column ，在 `CREATE TABLE` 子句中使用 `GENERATED ALWAYS AS` 子句，例如：

```sql
CREATE TABLE people (
    ...,
    height_cm numeric,
    height_in numeric GENERATED ALWAYS AS (height_cm / 2.54) STORED
);
```

​		关键字 `STORED` 必须被使用来指定 generated column 的类型。欲了解更多细节看 [CREATE TABLE](https://www.postgresql.org/docs/13/sql-createtable.html)。

​		generated column 不能直接写。在 `INSERT` 和 `UPDATE` 命令中，不能为 generated column 指定值，但是默认值关键字 `DEFAULT` 可以使用。

​		思考一下一个带默认值的列与一个 generated column 的不同点。对于列的默认值，当插入行的时候没指定值的时候会被计算；一个 generated column 在更新行的时候自动更新，而且不能被覆盖。列的默认值不太可能会引用表中的其他列；一个 generation 表达式一般会引用表中的其他列。列的默认值可以使用不稳定的函数，例如 `random()` ，或者使用表示当前时间的函数；这在 generated column 中是不允许的。

​		下面是一些关于定义 generated column 和 表引用generated column 的限制：

* generation 表达式只能使用稳定的函数，不能用子查询，不能引用当前行之外的任何东西。
* generation 表达式不能引用另一个 generated column。
* generation 表达式不能引用系统列，除过 `tableoid`。
* generated column 不能有默认值和唯一约束。
* generated column 不能是 partition key 的一部分。
* 外部表不能有 generated column。详情看 [CREATE FOREIGN TABLE](https://www.postgresql.org/docs/13/sql-createforeigntable.html)。
* 对于继承：
  * 如果父列是一个 generated column，子列也必须是使用相同表达式的 generated column。在子列定义中，xxx，因为会从父列中复制。
  * 在多继承情况中，如果一个父列是 generated column，所有的父列必须是使用相同表达式的 generated column。
  * 如果父列不是 generated column，子列可以是 generated column 也可以不是。



​		其他一些关于使用 generated column 的要考虑点：

* generated column 的访问权限与它的基础列是相互独立的。所以，我们可以管理，让一个特定的角色可以读取 generated column 而不能读取它的基础列。
* 从概念上讲，generated column 在 `BEFORE` 触发器运行之后才会更新。因此，在 `BEFORE` 触发器中修改基础列的值将会影响到 generated column。但实际上恰恰相反，在 `BEFORE` 触发器中不允许访问  generated column。



### 5.4 约束

英文：https://www.postgresql.org/docs/13/ddl-constraints.html

​		数据类型是一种限制数据种类的方式。然而大部分应用程序提供的约束都太过粗略。例如，一个存储产品价格的列应该只接受正数。但没有一种标准类型是只接受正数的。另一个问题是如果你想一个列的数据被其他列或其他行约束。例如，在一个产品信息表里，对于每个产品应该只有一行。

​		为了这个目的，SQL 允许你在列或表上定义约束。约束使你能给表的数据施以更多的控制。如果用户想要向一个列中存储违反其约束的值，会收到一个报错。即使违反约束的值来源于默认值，这个规则依然生效。



#### 5.4.1 check 约束

​		一个 check 约束是最一般的约束类型。这允许你为某个列指定一个布尔表达式，这个列的值必须遵循这个布尔表达式。例如，要求价格必须为正数，你可以：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0)
);
```

​		如你所见，约束定义在数据类型后面，就像默认值定义一样。默认值与约束的顺序可以颠倒。一个 check 约束的定义由 `CHECK` 关键字后跟着圆括号括起来的表达式。chech 约束的表达式应该引用被约束的列，否则约束表达式没有意义。

​		你以可以给约束一个独立的名字。这可以让报错信息更加清晰，并且你可以通过这个名字来也引用约束当你需要修改它的时候。语法如下：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CONSTRAINT positive_price CHECK (price > 0)
);
```

​		因此，指定一个有名字的约束时，使用关键字 `CONSTRAINT` ，后跟着一个标识符，再跟着约束定义。(如果你不移这种方式指定约束的名字，系统将会自己给个名。)

​		check 约束也可以引用多个列。你要存储一个一般价格和打折后的价格，并且想要保证打折价格低于一般价格：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
```

​		上面例子中，前两个约束看起来非常相似。第三个约束使用了一个新语法。他没有与任何一个具体的列关联起来，而是作为一个独立的元素列在逗号分隔的列列表里。列定义与约束定义可以混合在一起。

​		我们说前两个约束是列级约束，然而第三个约束是表级约束，因为它没有被关联到任何一个列上。列级约束也可以被写为表级约束，但反过来则不行，因为列级约束被假定为只会引用它关联的列。(pg 不强制这个规则，但如果你想表定义语句也能适应于其他数据库系统，最好遵循这个约束。) 上面的例子也可以被写为：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
```

​		或者甚至：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0 AND price > discounted_price)
);
```

​		使用哪种，是个人便好的问题。

​		也可以用向列级约束赋予名字同样的方式向表级约束赋予名字：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price > 0),
    discounted_price numeric,
    CHECK (discounted_price > 0),
    CONSTRAINT valid_discount CHECK (price > discounted_price)
);
```

​		应该注意的是，check 约束当表达式被求值为 true 或 null 时才会被认为符合约束。因为如果有一个操作数是 null ，大部分表达式就会被求值为 null，所以 check 约束不会禁止被约束的列为 null 。为了保证一个列不包含 null 值，可以使下个小节将要描述的 not-null 约束。

> **Note**
>
> ​		pg 不支持 xxx。有时违反了这个规则的约束在简单的测试中能生效，但这不能保证数据不会到达某个使得 check 表达式为 false 的状态(由于被引用的其他行的子序列改变)。这将会导致数据库 dump 和重载错误。重载将会错误，尽管整个数据库对于约束是一致的，因为在某种顺序下的没有加载的数据将会符合约束。如果可能，使用 `UNIQUE`, `EXCLUDE`, `FOREIGN KEY` 约束来表达跨行和跨表的限制。
>
> ​		如果你想要的是一次性检查在其他行的背景下在插入行的时候，而不是一个持续维护的一致性保证，一个自定义 [触发器](https://www.postgresql.org/docs/13/triggers.html) 可以被用来满足需要。(这个方法会防止 dump/reload 问题，因为 pg_dump 不会重新安装触发器，直到重载数据之后，所以 check 约束不会在 dump/reload 期间被强制执行。)

> **Note**
>
> ​		pg 假设 check 约束的条件是不可变的，这是说，当输入的行一定时，输出的结果也是一定的。这个假设证明仅在插入行或更新行的时候检查 check 约束的合法性。(上面这些关于不引用其他表数据的警告实际上是这个限制的一个特殊例子。)
>
> ​		打破这个假设的常见例子是在 check 表达式中引用用户自定义函数，然后改变自定义函数的行为。pg 不会禁止这种行为，但当表里已有的行违反了 check 约束时不会有通知。这会造成数据库 dump 并且 reload 失败。处理这种变化，推荐的方法是先 drop 约束(使用 `ALTER TABLE`) ，调整函数的定义，然后重新添加约束，从而使数据库重新检查表达的所有行是否满足约束。



#### 5.4.2 Not-Null 约束

​		not-null 约束指定列一定不能为 null 值。语法的例子：

```sql
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric
);
```

​		not-null 约束经常为写为列级约束。not-null 约束与创建这样一个 check 约束：`CHECK (column_name IS NOT NULL)` 在功能上是等价的，但在 pg 里，显式地创建一个 not-null 约束是更高效的。缺点是你不能为用这种方法创建的约束给予一个显式的名字。

​		当然，一个列可能有多个约束。只需要一个接一个的写着就行：

```sql
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price > 0)
);
```

​		写约束的顺序是无关紧要的。约束被执行的顺序不是必要指定的。

​		`NOT NULL` 约束有个相反的：`NULL` 约束。这不是说列值必须为 null 值，这没什么意义。而是说，这会使用默认的行为，即允许列值为 null 值。`NULL` 约束不在当前的 SQL 标准里，在可移植的程序不应该使用这个。(这被 pg 支持只是为了兼容其他数据库系统。) 然后，一些用户喜欢这个特性，因为这使得在一个脚本文件中切换约束变得容易。例如，你可以：

```sql
CREATE TABLE products (
    product_no integer NULL,
    name text NULL,
    price numeric NULL
);
```

​		然后在想要的地方输入 `NOT` 关键字。

> **Tip**
>
> ​		在大部分数据库设计中，大部分列应该是 not null 的。



#### 5.4.3 唯一约束

​		唯一约束保证某个列或某几个列的组合的取值在整个表中是唯一的。语法是：

```sql
CREATE TABLE products (
    product_no integer UNIQUE,
    name text,
    price numeric
);
```

​		上述例子写为列级约束，同时：

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    UNIQUE (product_no)
);
```

​		是写为表级约束。

​		为了给某几个列定义一个唯一约束，将之写为表级约束：

```sql
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    UNIQUE (a, c)
);
```

​		这指定了 a, c 列的值组合在整个表内是唯一的，而单个一个列的值不是唯一的。

​		你可以为唯一约束赋予一个名字，使用一般的方法：

```sql
CREATE TABLE products (
    product_no integer CONSTRAINT must_be_different UNIQUE,
    name text,
    price numeric
);
```

​		添加一个唯一约束会自动创建一个 唯一B-tree索引。一个只覆盖某些行的唯一限制不能被写为唯一约束，但它可以创建一个 [partial index](https://www.postgresql.org/docs/13/indexes-partial.html) 来执行约束。

​		一般，当一个表里有超过一行的在唯一约束里的列值是相等的，就违反了唯一约束。然后，两个 null 值不被认为违反。这意味着，只要唯一约束里的列有一个值是 null，那么就存在重复行的可能。这个行为是符合 SQL 标准的，但有些其他数据库系统并不遵循这个规则。所以开发可移植的应用程序时应该注意这一点。



#### 5.4.4 主键

​		主键约束意味着，一个列或一个列组合，在整个表的范围内，可以被用作行的唯一标识符。这要求值必须唯一且非 null。所以，下面两个表定义接受同样的数据：

```sql
CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);

-- 

CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
```

​		主键可以跨越超过一个列；语法和唯一约束相似：

```sql
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    PRIMARY KEY (a, c)
);
```

​		添加主键将会自动创建一个 唯一B-tree索引，还会强制列  `NOT NULL`。

​		一个表最多只能有一个主键。(表可以有多个唯一约束或not-null约束，功能上几乎相同，但主键只能有一个。) 关系数据理论要求每个表必须有个主键。pg 不强制这个规则，但最好遵循它。

​		主键对于文档和应用程序都是有用的。例如，一个允许修改数据的 GUI 应用程序，可能需要知道表的主键，以便于唯一的定位每个行。数据库有很多方式来使用主键；例如，主键可以定义外键应用的默认列。



#### 5.4.5 外健

​		外键约束指定，一个列或一个列组合的值必须匹配另一个表中行的值。我们说这维护了两个关系表的 ***引用完整性***。

​		假设你有一个产品表：

```sql
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
```

​		我们再假设，有个存储这些产品的订单的表。我们想保证订单表只包含存在的产品的订单。所以我们定义一个外键约束在订单表上，来引用产品表：

```sql
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products (product_no),
    quantity integer
);
```

​		现在就无法创建 product_no 不在产品表里的订单了。

​		这种情况下，我们讲订单表是 **引用表** ，产品表是 **被引用表**。与此类似，也有 **引用列** 和 **被引用列** 之说。

​		你可以将上述 SQL 做些简化：

```sql
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer REFERENCES products,
    quantity integer
);
```

​		因为在缺省情况下，被引用表的主键中的列将被当作引用列。

​		外键也可以约束或引用一个列组。通常，这需要写成表级约束。下面是个例子：

```sql
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)
);
```

​		当然，约束列的数量和类型要与被引用列的数量和类型相同。

​		通常，你可以为外键赋予一个名字。

​		一个表可以拥有超过一个外键。这用来实现表之间多对多的关系。假设你有产品和订单表，但现在你想在一个订单里包含多个产品（上面关于产品表和订单表中的例子是没法做到这个的）。你可以使用如下的表结构：

```sql
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
```

​		注意上述的第三个表里，主键和外键是重合的。

​		我们知道外键禁止创建没有与任何产品关联的订单。但如果一个产品被移除之后，之前创建的引用这个产品的订单会怎么样呢？SQL 允许你处理这样的情况。直观上，我们有以下几个方法：

* 禁止删除一个被引用的产品
* 删除一个被引用的产品时，同时删除与之相关的订单
* 其他



​		为了讲清楚这个问题，让我们实现这样一个多对多关系的例子：当要删除一个被引用的产品时，禁止这样做。当要删除一个订单时，订单相关联的项被也被删除：

```sql
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products ON DELETE RESTRICT,
    order_id integer REFERENCES orders ON DELETE CASCADE,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
```

​		restrict 和 cascade 删除是两种最常见的选项。`RESTRICT` 防止被引用行被删除。`NO ACTION` 意思是当被引用行已被删除，而引用行还存在，当检查约束的时候，将会报错；如果你不指定删除方式，这是默认行为。(这两种方式的最大区别是：`NO ACTION` 允许在事务中将约束检查推迟到后面，而 `RESTRICT` 不是这样。) `CASCADE` 指定当被引用行被删除时，引用它的行和会被自动删除。还有其他两个选项：`SET NULL` 和 `SET DEFAULT` 。这俩方法会让引用列被设置为 null 值或默认值，当被引用行被删除的时候。注意，这些方法不会阻止你遵循其他任何约束。例如，如果指定了 `SET DEFAULT` ，但默认值不遵循约束，这个操作就会失败。

​		与 `ON DELETE` 类比的还有 `ON UPDATE` ，当被引用列改变的时候(被 update)。可能的动作是相同的。在这种情况下，`CASCADE` 意思是将被引用的新值复制给引用列。

​		正常情况下，引用行在任何一个引用列是 null 值时无需遵循外键约束。如果 `MATCH NULL` 被添加到外键声明中，引用行只有在所有引用列是 null 值时可以不遵循约束(所以，null值和非null值混合的，一定会导致 `MATCH NULL` 约束失败)。如果你想避免引用行逃脱约束，将引用列声明为 `NOT NULL`。

​		外键引用的列必须是主键或者带有唯一约束。这意味着被引用列常常是带有索引的(主键和唯一约束的B-tree索引)；所以检查引用行是否拥有一个匹配是非常高效的。从被引用表删除一个被引用行或者更新被引用列，将会在引用表上进行一次扫描，扫描那些相关的行，所以为引用列建立索引是个好主意。因为这不是必须的，并且有很多种方法创建索引，外键约束的声明不会自动为引用列创建索引。

​		更多关于更新和删除数据的知识在 [Chapter 6](https://www.postgresql.org/docs/13/dml.html) 。外键约束的语法可以看 [CREATE TABLE](https://www.postgresql.org/docs/13/sql-createtable.html)。



#### 5.4.6 exclusion 约束

​		exclusion 约束保证，如果两个行进行比较，使用指定的列或表达式，使用指定的操作符，至少一个操走符将会返回 false 或 null。语法是：

```sql
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &&)
);
```

​		看 [CREATE TABLE ... CONSTRAINT ... EXCLUDE](https://www.postgresql.org/docs/13/sql-createtable.html#SQL-CREATETABLE-EXCLUDE) 获取更多细节。

​		添加一个 exclusion 约束将自动创建一个约束指定的类型的索引。



### 5.5 系统列

英文：https://www.postgresql.org/docs/13/ddl-system-columns.html

​		每个表都有几个系统列，这是系统隐式定义的。因此，这些列的名字不能被用户自定义列所使用。(注意，这些限制与列名是否是关键字是两回事；将名字用双引号括起来并不能让你逃脱这个限制。) 实际上你可以不在意这些列的存在，只要知道它们存在就行了。

##### tableoid

​		包含这个行的表的 OID。这个列是为 xxx 而准备的，因为没有这个，分辨一个行来自哪个表是有难度的。tableoid 可以用来与 pg_class 表的 oid 列做 JOIN 来获取表的名字。

##### xmin

​		插入这个 row version 的事务的标识(transaction ID)。(row version 是行的一个状态；update 一个行会导致创建一个这个行的新版本，即row version，这两个行在逻辑上是一个行，在物理上有多行，每个行表示某个时刻的版本。) 

##### cmin

​		事务中插入该 row version 的命令的标识(从0开始)。

##### xmax

​		删除这个 row version 的事务的标识(transaction ID)，为零表示未删除的 row version。在一个可见的行中，这一列可能是非零。这通常意味着删除事务还未提交，或者一个删除的尝试被回滚了。

##### cmax

​		事务中删除该 row version 的命令的标识，或者为零。

##### ctid

​		该 row version 在表中的物理位置。注意，虽然可以用 ctid 快速定位 row version，一个 row version 的 ctid 会在它被更新或者被 `VACUUM ALL` 删除的时候发生变化。因此，不能作为一个永久的行标识。应该用主键来标识一个逻辑行。



​		事务标识是一个32 bit的值。在一个长期运行的数据库实例中，事务 ID 可能会环绕。这不是一个需要特殊维护的致命问题；更多细节看 [Chapter 24](https://www.postgresql.org/docs/13/maintenance.html) 。然后，在长期运行中(指超过10亿事务)依赖事务 ID 的唯一性，是不明智的。

​		命令标识也是一个32 bit的值。这是一个硬限制，即一个事务内最多允许，2的32次方(40亿)个命令。在实践中，这个限制不太可能被达到 - 注意，这是计算 SQL 命令的数量，不是处理的行的个数。同时，只有实际行对数据造成更改的SQL命令才会占用一个命令标识。



### 5.6 修改表结构

英文：https://www.postgresql.org/docs/13/ddl-alter.html



​		当你创建一个表后，发现你搞错了一些事情，或者应用程序的需求发生了变化，你可以删除表，然后再重建。但这不是一个方便的选择，当表里已经有数据的时候，或者表已经被其他数据库对象所引用(例如一个外键约束)。 因此，pg 提供了一个命令族对已存在的表进行修改。注意，这在概念上与修改表数据是不同的：这里我们感兴趣的是修改表定义，或者说修改表结构。

​		你可以：

* 添加列
* 删除列
* 添加约束
* 删除约束
* 修改列的默认值
* 修改列的数据类型
* 重命名列
* 重命名表



​		所有的这些动作都使用 [ALTER TABLE](https://www.postgresql.org/docs/13/sql-altertable.html) 命令，它的参考页面上的信息比这里更加丰富。



#### 5.6.1 添加列

​		要添加一个列，使用类似下面的命令：

```sql
ALTER TABLE products ADD COLUMN description text;
```

​		新加的列会被赋予默认值(如果没用 `DEFAULT` 子句指定，就赋予 null 值。)

> **Tip**
>
> ​		从 pg11 开始，添加一个带有常量默认值的的列，不再意味着在执行 `ALTER TABLE` 语句时会更新表中所有已存在的行的该列为默认值。取而代之的是，下次访问某个行的时候，默认值会被返回，并且当表被重写的时候默认值会被赋予列，这使得即使对于大表，`ALTER TABLE` 也会执行很快。
>
> ​		然而，当默认值不是固定不变的值时(例如，clock_timestamp())，每个行都需要被更新为执行 ` ALTER TABLE` 语句时的时间。为了避免潜在的长时间的更新操作，特别是无论如何你都想赋予列最非默认值，更好的方法是添加不带默认值的列，然后用 `UPDATE` 来插入正确的值，然后再给列添加默认值。

​		你也可以在添加列的时候为它添加约束，使用常见的语法：

```sql
ALTER TABLE products ADD COLUMN description text CHECK (description <> '');
```

​		实际上，所有在 `CREATE TABLE` 中给列声明使用的东西都可以用在这里。记住，默热值必须遵循给定的约束，否则操作会失败。你也可以在给列赋予了合适的值之后再添加约束(接下来会讨论)。



#### 5.6.2 删除列

​		要删除一个列，使用类似下面的命令：

```sql
ALTER TABLE products DROP COLUMN description;
```

​		无论什么数据都会随着列消失。与之相关的约束也会被删除。然而，如果待删除的列被一个其他的表的外键引用，pg 不会沉默地删除这个约束。你可以加上 `CASCADE` 关键字来删除一切依赖于待删除列的对象：

```sql
ALTER TABLE products DROP COLUMN description CASCADE;
```

​		更多细节看 [Section 5.14](https://www.postgresql.org/docs/13/ddl-depend.html)。



#### 5.6.3 添加约束

​		要添加一个约束，需要使用添加约束的语法。例如：

```sql
ALTER TABLE products ADD CHECK (name <> '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
```

​		要添加一个 not-null 约束，这不能被写为一个表级约束，使用下列语法：

```sql
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
```

​		约束将会被立刻检查，所以在约束被添加前，表数据必须遵循约束。



#### 5.6.4 删除约束

​		要删除一个约束你需要知道约束的名字。如果你已经给约束赋予了名字，这个操作会很简单。否则，系统会为约束赋予一个自动生成的名字，你需要找出这个名字。命令行工具 psql 的 `\d tablename` 命令可以帮你；其他接口可能也可以查看表的细节。所以，删除约束的命令为：

```sql
ALTER TABLE products DROP CONSTRAINT some_name;
```

​		(如果你正在处理一个像 `$2` 这样的自动生成的约束名时，你需要将它用双引号括起来，来保证这是个合法的标识符。)

​		如果你想删除一个有其他对象依赖的约束，你需要在删除列的时候加上 `CASCADE` 。一个例子是：某个外键约束依赖了被引用列的唯一约束或主键。

​		上述方法对所有类型的约束都有效，除过 not-null 约束。要删除 not-null 约束，使用：

```sql
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
```

​		(撤销那些没有名字的 not-null 约束。)



#### 5.6.5 改变列的默认值

​		要为列设置一个新的默认值，使用类似下面的命令：

```sql
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
```

​		注意，这不会影响任何已经存在的行，这仅仅只对后续的 `INSERT` 命令生效。

​		要删除一个列的默认值，使用：

```sql
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
```

​		这与将列的默认值设置为 null 的效果是一样的。结果是，删除一个用户未定义的默认值不会报错，因为隐式的默认值是 null。



#### 5.6.6 改变列的数据类型

​		要修改列的数据类型，使用类似下面的命令：

```sql
ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
```

​		如果列中的所有值都可以被隐式类型转换为新类型的值，这个命令才会成功。如果需要一个更复杂的转换，你可以用 `USING` 子句来指定如何将旧类型的值转换为新类型的值。

​		pg 也会尝试将列的默认值转换为新的类型的值，与之相关的约束也会被尝试转换。但是这些转换可能会失败，或者可能产生预期之外的值。通常更好的方法是在改变类型之前删除所有约束，在类型修改后，再将合适的约束加回来。



#### 5.6.7 重命名一个列

​		重命名一个列：

```sql
ALTER TABLE products RENAME COLUMN product_no TO product_number;
```



#### 5.6.8 重命名一个表

​		重命名一个表：

```sql
ALTER TABLE products RENAME TO items;
```



### 5.7 权限

​		当一个对象被创建的时候，它被赋予一个所有者。这个所有者一般是那个执行创建语句的角色。对于大多数种类的对象，初始状态是只有所有者(或数据库超级用户)可以对它执行任何可以执行的操作。要允许其他角色使用这个对象，必须赋予权限。

​		有几种不同的权限：`SELECT, INSERT, UPDATE, DELETE, REFERENCES, TRIGGER, CREATE, TEMPORARY, EXECUTE, USAGE`。一个具体的对象身上有哪些权限，取决于对象的类型(表，函数，等等)。这些权限的意义将在下面讨论。接下来的小节和章节也会告诉你这些权限怎能使用。

​		修改和删除对象是所有者天生的权力，并且不能被授权或取消授权。(然而，就像所有的权限那样，这些权力可以被角色内的用户所继承；看 [Section 21.3](https://www.postgresql.org/docs/13/role-membership.html))。

​		可以变更对象的所有者，对合适的对象使用 `ALTER` 命令，例如：

```sql
ALTER TABLE table_name OWNER TO new_owner;
```

​		数据库超级用户可以做这件事；一般用户，如果是这个对象的所有者(或者隶属于所有者组)也可以做这件事。

​		要授予权限，需要 `GRANT` 命令。例如，如果存在一个角色 `joe` ，存在一个表 accounts，授予更新表的权限的语句：

```sql
GRANT UPDATE ON accounts TO joe;
```

​		在权限的位置上写个 `ALL` 会将与对象相关的所有权限赋予给某个角色。

​		特性的角色名 `PUBLIC` 可以用来向系统内所有用户授予权限。同时，**组角色** 可以在一个多用户的数据库中帮助我们更好的管理权限 - 更多细节看 [Chapter 21](https://www.postgresql.org/docs/13/user-manag.html)。

​		要取消授权，使用 `REVOKE` 命令：

```sql
REVOKE ALL ON accounts FROM PUBLIC;
```

​		一般，只有对象的所有者(或数据库超级用户)才可以将对象的权限授予给别人或取消授权。然而，可以在授予权限时使用 `with grant option` 将授权的权力也赋予给被授权者。如果后面又取消了 grant option ，那么所有被这个失去了授权权力的角色赋予权限的人也将失去授权（这是一个链）。更多细节看 [GRANT](https://www.postgresql.org/docs/13/sql-grant.html) 和 [REVOKE](https://www.postgresql.org/docs/13/sql-revoke.html) 。

​		一个对象的拥有者可以取消他们自己初始拥有的权限，例如，将表设置为对他们自己和别人都是只读。但是拥有者会一直被认为拥有授权的权利，因此，他们可以再重新授权。

​		权限有：

##### SELECT

​		允许 [SELECT](https://www.postgresql.org/docs/13/sql-select.html) 一个表、视图或者其他类表对象的所有列或指定的列。同时也允许 [COPY TO](https://www.postgresql.org/docs/13/sql-copy.html) 。这个权限也被用来在 [UPDATE](https://www.postgresql.org/docs/13/sql-update.html) 和 [DELETE](https://www.postgresql.org/docs/13/sql-delete.html) 引用某个列。对于 sequence 对象，这个权限也允许用 `CURRVAL` 函数。对于大对象，这个权限允许对象被读取。

##### INSERT

​		允许向一个表里 [INSERT](https://www.postgresql.org/docs/13/sql-insert.html) 新行，视图，等。可以被授予特定的列，在这种情况下只有那些授权的列才可以用 `INSERT` 赋值(其他的列将会被设置为默认值)。有了这个权限，也允许使用 [COPY FROM](https://www.postgresql.org/docs/13/sql-copy.html) 。

##### UPDATE

​		允许 [UPDATE](https://www.postgresql.org/docs/13/sql-update.html) 一个表、视图、等的任何列或特定列。(在实践上，任何有用的 `UPDATE` 都同时需要 `SELECT` 权限，因为它需要引用表的列来决定要更新那些行，或者需要利用旧的行来计算新值。) `SELECT ... FOR UPDAT` 和 `SELECT ... FOR SHARE` 也要求至少一个列的 UPDATE 权限，和 SELECT 权限。对于 sequence 对象，这个权限允许使用 `nextval` 和 `setval` 函数。对于大对象，这个权限允许写或者删除对象。

##### DELETE

​		允许对表、视图、等进行 [DELETE](https://www.postgresql.org/docs/13/sql-update.html) 操作。(在实践上，任何有用的 DELETE 命令也需要 SELECT 命令，因为它需要引用表的列来决定删除那些行。)

##### TRUNCATE

​		允许对表、视图、等进行 TRUNCATE 。

##### REFERENCES

​		允许外键引用表或表中的列。

##### TRIGGER

​		允许在表、视图、等上创建触发器。

##### CREATE

​		对于 database，这允许在数据库里创建 schema 和 publication ，允许在 database 里安装受信的扩展。

​		对于 schema，这允许在 schema 里创建新对象。要重命名一个对象，你必须是这个对象的所有者，且拥有包含对象的 schema 的这个权限。

​		对于 tablespace。这允许在 tablespace 里创建 表、索引、临时文件，允许创建该 tablespace 作为默认 tablespace 的 database 。

​		注意，收回这个授权并不影响已存在的对象存在性和位置。

##### CONNECT

​		允许被授权者连接 database。这个权限在连接启动的时候被检查(也会检查任何由 pg_hba.conf 实现的约束)。

##### TEMPORARY

​		允许在 database 里创建临时表。

##### EXECUTE

​		允许调用函数或存储过程，包括使用基于函数的操作符。这是唯一应用于函数或存储过程的权限类型。

##### USAGE

​		对于存储过程编程语言，允许用这种语言创建函数。这是唯一应用于存储过程编程语言的权限类型。

​		对于 schema，这允许访问 schmea 包含的对象(假定这个对象所需的权限也被满足了)。本质上，这个权限允许被授权者在 schema 查找对象。如果没有这个权限，也能看见对象的名字，例如，通过查询系统表。同时，当收回这个权限时，已经存在的会话可能还有 SQL 早就执行了这个查找，所以这不是个完全安全的方法来禁用对象访问。

​		对于 sequence，这允许使用 `currval` 和 `nextval`。

​		对于数据类型和域，这允许使用数据类型和域来建表、建函数、建其他 schema 对象。(注意，这个权限不控制数据类型所有的 usage ，例如类型的值出现在查询中。这仅仅禁止创建基于数据类型的对象。这个权限的主要目的是控制哪些用户能在数据类型上创建依赖，这会导致所有者无法修改数据类型在后面。)

​		对于 外部数据包装器，这允许使用外部数据包装器来创建一个新的 server。

​		对于 foreign server，这允许在 foreign server 里创建一个外部表。授权者也可以创建、修改、删除他们拥有的与 foreign server 关联的用户映射。

​		

​		其他命令所有的权限都被列在命令的参考页上。

​		pg 会在某些类型的对象被创建时，将它们的权限授予 PUBLIC。默认情况下，表、表的列、sequence、外部数据包装器、foreign server、large object、schema、tablespace 的任何权限不会授予出去。对于其他类型的对象，默认授予给 PUBLIC 的权限如下所述：

* database 的 CONNECT 和 TEMPORARY 权限
* 函数和存储过程的 EXECUTE 权限
* 存储过程编程语言和数据类型的 USAGE 权限(包括 domain)

对象的所有者可以删除这些默认授予的权限。(为了最大的安全性，ssue the `REVOKE` in the same transaction that creates the object; then there is no window in which another user can use the object.) 同时，这些默认权限的设置可以被 [ALTER DEFAULT PRIVILEGES](https://www.postgresql.org/docs/13/sql-alterdefaultprivileges.html) 命令修改。



​		下表展示了在 ACL (Access Control List)值中，这些权限的单子符缩写。你会在 psql 命令中列出权限时看到这些，或者查看系统表的 ACL 列时看到这些。

| 权限       | 缩写      | 应用的对象类型                                               |
| ---------- | --------- | ------------------------------------------------------------ |
| SELECT     | r(read)   | LARGE OBJECT, sequence, 表，表的列                           |
| INSERT     | a(append) | 表，表的列                                                   |
| UPDATE     | w(write)  | LARGE OBJECT，sequence，表，表的列                           |
| DELETE     | d         | 表                                                           |
| TRUNCATE   | D         | 表                                                           |
| REFERENCES | x         | 表，表的列                                                   |
| TRIGGER    | t         | 表                                                           |
| CREATE     | C         | database，schema，tablespace                                 |
| CONNECT    | c         | database                                                     |
| TEMPORARY  | T         | database                                                     |
| EXECUTE    | X         | 函数，存储过程                                               |
| USAGE      | U         | domain，foreign data wrapper，foreign server，language，schema，sequence，数据类型 |



​		下表总结了每种 SQL 对象包含的权限，使用了一字符缩写形式。这表里也总计了使用 psql 命令查看每种对象类型的权限设置的命令：

| 对象类型             | 所有权限 | 默认的 PUBLIC 权限 | psql 命令 |
| -------------------- | -------- | ------------------ | --------- |
| database             | CTc      | Tc                 | `\l`      |
| domain               | U        | U                  | `\dD+`    |
| 函数或存储过程       | X        | X                  | `\df+`    |
| foreign data wrapper | U        | none               | `\dew+`   |
| foreign server       | U        | none               | `\des+`   |
| language             | U        | U                  | `\dL+`    |
| large object         | rw       | none               |           |
| schema               | UC       | none               | `\dn+`    |
| sequence             | rwU      | none               | `\dp`     |
| 表(类表对象)         | arwdDxt  | none               | `\dp`     |
| 表的列               | arwx     | none               | `\dp`     |
| tablespace           | C        | none               | `\db+`    |
| 数据类型             | U        | U                  | `\dT+`    |



​		这些对象在被授予给特定的对象时，以 aclitem 形式展现，每条 aclitem 描述了一个授权者将某个权限授予给某个用户。例如，`calvin=r*w/hobbes` 表示角色 calvin 拥有 SELECT(r) 权限，并且可以将之授予给别人的权限(*)，还拥有 UPDATE(w) 权限，但不能授予给别人，这俩权限都是被角色 hobbes 授予的。如果 calvin 还有一些被其他角色授予的权限，这些权限将在另一条 aclitem 中被描述。如果一个 aclitem 的被授权者的位置时空的，表示 PUBLIC.

​		举个例子，假设用户 miriam 创建了个表叫 mytable：

```sql
GRANT SELECT ON mytable TO PUBLIC;
GRANT SELECT, UPDATE, INSERT ON mytable TO admin;
GRANT SELECT (col1), UPDATE (col1) ON mytable TO miriam_rw;
```

​		这时 psql 的 `\dp` 命令将会输出：

```sql
=> \dp mytable
                                  Access privileges
 Schema |  Name   | Type  |   Access privileges   |   Column privileges   | Policies
--------+---------+-------+-----------------------+-----------------------+----------
 public | mytable | table | miriam=arwdDxt/miriam+| col1:                +|
        |         |       | =r/miriam            +|   miriam_rw=rw/miriam |
        |         |       | admin=arw/miriam      |                       |
(1 row)
```

​		如果某个给定的对象的 "Access privileges" 列是空的，这意味着拥有默认权限(这是说，它的权限条目在相关系统表中是 null)。默认权限包含拥有者的所有权限，也可以包含 PUBLIC 的基于对象类型的权限，上面讨论过这个问题。首次对一个对象进行 `GRANT` 或 `REVOKE` 将会实例化它的默认权限(例如，会产生`miriam=arwdDxt/miriam`) 然后每次根据命令的需求来修改它们。与之类似，"Column privileges" 中仅仅有列的非默认值权限。(注意：为了这个目的，"默认权限" 意味着对象类型的内置的默认权限。如果某个对象的默认权限被 `ALTER DEFAULT PRIVILEGES` 命令修改过，这将会在 aclitem 中显式的有一条记录，记录 `ALTER` 的结果。)

​		注意，拥有者的隐式的授权权限不会在访问权限中被列出。`*` 仅仅会在授权权限被授予给某个用户时，才会显示。



### 5.8 行安全策略

​		除过基于 GRANT 可以获取的 SQL标准的权限体系之外，表还可以拥有 ***行安全策略(row security policies)*** ，行安全策略限制：哪些行可以被正常的查询返回；哪些行可以被 INSERT, UPDATE, DELETE 。这个特性也被叫做 ***行级安全性(Row-Level Security)*** 。默认情况下，表没有任何策略，所以当一个用户根据 SQL 权限体系，拥有一个表的访问权限时，表里所有的行都可以平等地被查询或修改。  

​		当一个表的 行安全策略 开启的时候(使用 `ALTER TABLE ... ENABLE ROW LEVEL SECURITY`)，所有对表的正常的查询和更新操作都需要被 行安全策略 允许。（然而，表的所有者不受 行安全策略 的约束。）如果一个表不存在任何 行安全策略，默认的权限：拒绝，会被使用，意思是没有任何行可以被看见或修改。对于全表的操作，像 `TRUNCATE` 和 `REFERENCES` ，不受 行安全策略 的约束。

​		行安全策略 因命令而异，因角色而异，或者因命令和角色一起而异。一个策略可以被指定应用于所有 SQL 命令，或者仅对 `SELECT`，`INSERT`，`UPDATE`，`DELETE`。多个角色可以被给予一个给定的策略，正常的角色成员和继承规则被应用。

​		要在一个策略里指定哪些行是可见的、可更新的，需要一个结果是 boolean 类型的表达式。这个表达式将会在用户查询的任何条件或函数之前被求值。(唯一的例外是 `leakproof` 函数，这个函数被保证不会泄露信息；优化器可能会决定在 行安全策略 之前应用这个函数。) 这个表达式不返回 true 的行不会被处理。需要指定独立的表达式来提供 哪些行可以被查询或更新 的依赖控制。策略表达式将会作为查询的一部分来运行，使用执行查询的用户的权限，但是安全定义函数可以被用来访问数据而不需要调用的用户具有权限。

​		带有 `BYPASSRLS` 属性的数据库超级用户和角色在访问表的时候会绕过 行安全策略。表的所有者一般也会绕过，但是表所有者也可以通过 `ALTER TABLE ... FORCE ROW LEVEL SECURITY`。

​		开启或关闭 行安全策略、向一个表添加策略，一般都是表所有者独有的权限。

​		行安全策略 用 `CREATE POLICY` 命令来创建，使用 `ALTER POLICY` 命令来修改，使用 `DROP POLICY` 来删除。要对一个给定的表开启或关闭行安全策略，使用 `ALTER TABLE` 命令。

​		每个策略都有一个名字，一个表可以定义多个策略。因为策略是属于某个特定表的，一个表的每个策略都得有个唯一的名字。不同的表可以拥有名字相同的策略。

​		当多个策略应用于一个查询时，这些策略被联合使用，对于 **允许策略**(这是默认的策略) 使用 `OR` 连接，对于 **约束策略** 使用 `AND` 连接。这与规则 xxx 是相似的。允许策略 和 约束策略 将在后面深入讨论。

​		一个简单的例子，创建一个策略，仅允许 `managers` 组的用户访问表 `account` ，且只能访问他们自己账户的行：

```sql
CREATE TABLE accounts (manager text, company text, contact_email text);

ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_managers ON accounts TO managers
    USING (manager = current_user);
```

​		上述的策略用 `USING` 子句提供了一个 `WITH CHECK` 检查，所以这个约束被应用于查询命令(一个 manager 不能 `SELECT, UPDATE, DELETE` 属于其他 manager 的行)，还被应用于更新命令(一个 manager 不能 `INSERT, UPDATE` 属于其他 manager 的行)。

​		如果没有指定角色，或者使用了特殊的用户 `PUBLIC`，这时这个策略会被应用于系统内所有用户。要允许所有仅能访问 `users` 表中属于他们自己的行，一个简单的例子是：

```sql
CREATE POLICY user_policy ON users
    USING (user_name = current_user);
```

​		这个工作原理与前一个例子类似。

​		要为查询和更新使用不同的策略，可以将多个策略绑定使用。下面的策略会允许所有用户查看 `users` 表的所有行，但只允许修改自己的行：

```sql
CREATE POLICY user_sel_policy ON users
    FOR SELECT
    USING (true);
CREATE POLICY user_mod_policy ON users
    USING (user_name = current_user);
```

​		在 SELECT 命令中，这两种策略被使用 `OR` 连接起来，效果是所有的行都可以看到。在其他命令类型中，只有第二个策略才会应用，所以效果与之前的相同。

​		行安全策略 可以用 `ALTER TABLE` 命令关闭。关闭 行安全策略 不会删除表上已存在的策略；只是不启用这些策略而已。然后，表里的所有行都是可见的并且可修改的，完全受 SQL 权限系统的影响。

​		下面是一个更大的例子，关于如何在生产环境中使用这个特性。表 `passwd` 模拟 Unix 的密码文件：

```sql
-- Simple passwd-file based example
CREATE TABLE passwd (
  user_name             text UNIQUE NOT NULL,
  pwhash                text,
  uid                   int  PRIMARY KEY,
  gid                   int  NOT NULL,
  real_name             text NOT NULL,
  home_phone            text,
  extra_info            text,
  home_dir              text NOT NULL,
  shell                 text NOT NULL
);

CREATE ROLE admin;  -- Administrator
CREATE ROLE bob;    -- Normal user
CREATE ROLE alice;  -- Normal user

-- Populate the table
INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

-- Be sure to enable row level security on the table
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

-- Create policies
-- Administrator can see all rows and add any rows
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
-- Normal users can view all rows
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
-- Normal users can update their own records, but
-- limit which shells a normal user is allowed to set
CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );

-- Allow admin all normal rights
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
-- Users only get select access on public columns
GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
-- Allow users to update certain columns
GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
```

​		正如任何一个安全设置，测试并保证系统按照预期的那样来运作是非常重要的。使用上面的例子，下面演示了权限系统运行正常。

```sql
-- admin can view all rows and fields
postgres=> set role admin;
SET
postgres=> table passwd;
 user_name | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------
 admin     | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

-- Test what Alice is able to do
postgres=> set role alice;
SET
postgres=> table passwd;
ERROR:  permission denied for relation passwd
postgres=> select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;
 user_name | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+-----------+--------------+------------+-------------+-----------
 admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

postgres=> update passwd set user_name = 'joe';
ERROR:  permission denied for relation passwd
-- Alice is allowed to change her own real_name, but no others
postgres=> update passwd set real_name = 'Alice Doe';
UPDATE 1
postgres=> update passwd set real_name = 'John Doe' where user_name = 'admin';
UPDATE 0
postgres=> update passwd set shell = '/bin/xx';
ERROR:  new row violates WITH CHECK OPTION for "passwd"
postgres=> delete from passwd;
ERROR:  permission denied for relation passwd
postgres=> insert into passwd (user_name) values ('xxx');
ERROR:  permission denied for relation passwd
-- Alice can change her own password; RLS silently prevents updating other rows
postgres=> update passwd set pwhash = 'abc';
UPDATE 1
```

​		前面讨论的所有 行安全策略 都是 允许策略，意思是当多个策略被应用时，他们被用 `OR` 连接起来。允许策略 被用来允许访问某些行，与之相似，多个 约束策略(一个记录必须满足，且用 `AND` 连接起来) 也可以连接起来。基于上面的例子，我们添加一个约束策略来要求管理员通过本地 Unix socket 来访问 `passwd` 表的记录：

```sql
CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin
    USING (pg_catalog.inet_client_addr() IS NULL);
```

​		然后我们可以看到，一个管理员通过网络连接将不会看到任何记录，因为约束策略：

```sql
=> SELECT current_user;
 current_user 
--------------
 admin
(1 row)

=> select inet_client_addr();
 inet_client_addr 
------------------
 127.0.0.1
(1 row)

=> SELECT current_user;
 current_user 
--------------
 admin
(1 row)

=> TABLE passwd;
 user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir | shell
-----------+--------+-----+-----+-----------+------------+------------+----------+-------
(0 rows)

=> UPDATE passwd set pwhash = NULL;
UPDATE 0
```

​		引用性的完整性检查，例如 唯一约束 或 主键约束 或 外键引用，都会绕过 行安全策略 来保证数据完整性可以被维护。当禁止 “covert channel” 的开发 schema 和 行安全策略基于这样的引用完整性检查缺乏信息时，care 一定会发生。

​		在一些上下文中，确保 行安全策略 没有启用是非常重要的。例如，当做备份的时候，行安全策略 不发一言地导致备份中缺少某些行，是灾难性的行为。在这种情况下，你可以设置 [row_security](https://www.postgresql.org/docs/13/runtime-config-client.html#GUC-ROW-SECURITY) 配置参数为 `off`。这不会自行绕过行安全策略；它会在被行安全策略过滤掉某行行时报错。导致错误的问题可以帮助我们解决这个问题。

​		在上面的例子中，策略表达式只考虑了行的当前值被访问或更新的情况。这是最简单和 best-performing 的场景；如果可能的话，最好设计行安全的应用程序，像这种方式一样工作。如果需要其他表的行来做策略的决定是必须的，这可以用子查询(sub-SELECT) 来完成，或者使用包含 SELECT 的函数，在策略表达式里。要注意无论怎样这类访问会造成 race conditions ，会导致信息泄漏，如果 care 没发生的话。一个例子，考虑下面的表设计：

```sql
-- definition of privilege groups
CREATE TABLE groups (group_id int PRIMARY KEY,
                     group_name text NOT NULL);

INSERT INTO groups VALUES
  (1, 'low'),
  (2, 'medium'),
  (5, 'high');

GRANT ALL ON groups TO alice;  -- alice is the administrator
GRANT SELECT ON groups TO public;

-- definition of users' privilege levels
CREATE TABLE users (user_name text PRIMARY KEY,
                    group_id int NOT NULL REFERENCES groups);

INSERT INTO users VALUES
  ('alice', 5),
  ('bob', 2),
  ('mallory', 2);

GRANT ALL ON users TO alice;
GRANT SELECT ON users TO public;

-- table holding the information to be protected
CREATE TABLE information (info text,
                          group_id int NOT NULL REFERENCES groups);

INSERT INTO information VALUES
  ('barely secret', 1),
  ('slightly secret', 2),
  ('very secret', 5);

ALTER TABLE information ENABLE ROW LEVEL SECURITY;

-- a row should be visible to/updatable by users whose security group_id is
-- greater than or equal to the row's group_id
CREATE POLICY fp_s ON information FOR SELECT
  USING (group_id <= (SELECT group_id FROM users WHERE user_name = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
  USING (group_id <= (SELECT group_id FROM users WHERE user_name = current_user));

-- we rely only on RLS to protect the information table
GRANT ALL ON information TO public;
```

​		现在，假设 `alice` 想要改变 "slightly secret" 信息，但决定不信任 `mallory` 因为行的新的内容，所她这样做：

```sql
BEGIN;
UPDATE users SET group_id = 1 WHERE user_name = 'mallory';
UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;
COMMIT;
```

​		这看起来是安全的，没有机会让 `mallory` 看到 "secret from mallory" 字符串。然而，这存在一个 race condition 。如果 `mallory` 当前正在做：

```sql
SELECT * FROM information WHERE group_id = 2 FOR UPDATE;
```

​		并且她的事务处于 `READ COMMITTED` 模式下，对于她来说是可能看到 "secret from mallory" 的。这发生在她的事务达到了 `information` 行刚在 `alice` 做了操作之后。这会锁住，等待 `alice` 的事务提交，然后获取更新的行，幸亏有 `FOR UPDATE` 子句。然而，这并不会获取到更新的行因为隐式的从 `users` 中 SELECT，因为这个子查询没有 `FOR UPDATE` ，而是 `users` 的行被从一个快照中读取，这个快照产生于查询开始的时候。因此，这个策略表达式测试了 `mallory` 的老的权限级别，但允许她读取了更新的行。

​		关于这个问题，存在几个对策。简单的对策是在行安全策略的子查询中使用 `SELECT ... FOR SHARE` 。然而，这要求在被引用的表上(这里是 `users` 表)授予 `UPDATE` 权限给受影响的用户，这可能不是我们想要的。(但是另一个行安全策略可以被应用于防止他们实际上拥有那个权限；或者子查询可以被嵌入一个安全定义的函数中。) 同时，对被引用的表上的 row share 锁的重度并行使用会导致性能问题，特别是更新操作较频繁的时候。另一个对策是，在引用表的更新操作不是很频繁的场景下更适合的，是更新被引用表的时候获取一个 exclusive 锁，因此不会用并发的事务使用老的行的值。或者一个事务在提交更新之后等待所有的并发事务解决并且对依赖于新安全环境的更新操作做一修改。



### 5.9 模式(schema) 

​		一个 pg 集群包含一个或多个 database。数据库用户和一些其他的数据库对象是全集群共享的。一个客户端的连接可以仅可访问一个单 database，这在连接请求里会指定。

> **Note**
>
> ​		一个集群的用户对访问所有 database 的权限不是必需的。用户的共享意味着不能多个 database 拥有一样名字的用户，在同一个集群里；但是系统不能被配置为允许某个用户访问某几个 database。

​		一个 database 包含一个或多个 schema，schema 中包含表。schema 中还包含了其他的数据库对象，包括数据类型、函数、操作符。不同的 schema 中可以使用同样的对象名字而不会发生冲突。例如，`schema1` 和 `myschema` 可以都存在一个叫 `mytable` 的表。不像 database，schema 并没有被严格的分离开：一个用户可以访问他们连接的 database 内的所有 schema 及其包含的数据库对象，如果这个用户有权限的话。

​		用户想要使用 schema 一般有以下几个理由：

* 允许多个用户使用一个 database 而不会产生冲突
* 将数据库对象组织称多个分组而易于管理
* 第三方应用可以被放进互相区分的 schema 中放置冲突



​		schema 与操作系统层面的路径是相似的，除过 schema 不能嵌套。



#### 5.9.1 创建一个 schema

​		要创建一个 schema，使用 `CREATE SCHEMA	` 命令。为你的 schema 指定一个名字。例如：

```sql
CREATE SCHEMA myschema;
```

 		要创建或访问一个 schema 中的对象，在对象前面加上限定的 schema 名和表名，例如：

```sql
schema.table
```

​		上述形式在任何地方都生效，包括修改表和查询表的操作。(为了简洁，我们仅仅写表名，同样的注意适用于其他对象，例如数据类型和函数。)

​		实际上，更通用的语法是：

```sql
database.schema.table
```

​		这也可以使用，但目前这仅仅是形式上兼容 SQL 标准。如果你写了 database 名字，它必须与你连接的 database 是一致的。

​		所以要在新 schema 中创建一个表，使用：

```sql
CREATE TABLE myschema.mytable (
 ...
);
```

​		要删除一个 schema，如果 schema 是空的话(schema内部的所有对象都被删除了)，使用：

```sql
DROP SCHEMA myschema CASCADE;
```

​		看 [Section 5.14](https://www.postgresql.org/docs/13/ddl-depend.html) 获取关于这个背后的原理。

​		你经常会创建一个拥有者为其他人的 schema(因为这是约束数据库用户工作在良定义的名字空间的方法之一)。使用下面的语法：

```sql
CREATE SCHEMA schema_name AUTHORIZATION user_name;
```

​		你甚至可以忽略 schema name，在忽略的情况下，schema name 将会与当前的用户名一样。看 [Section 5.9.6](https://www.postgresql.org/docs/13/ddl-schemas.html#DDL-SCHEMAS-PATTERNS) 获取更多信息。

​		以 `pg_`  开头的schema name 被保留为系统目的，不能被用户创建。



#### 5.9.2 public schema

​		在前面的小节中，我们建表的时候没有指定 schema name。默认上这些表(或其他对象)被自动地叫做 "public" 的 schema 下。每个新 database 都包括这样一个 schema。因此，下面两个例子是等价的：

```sql
CREATE TABLE products ( ... );
```

和：

```sql
CREATE TABLE public.products ( ... );
```



#### 5.9.3 schema 的搜索路径

​		带 schema 前缀的名字风格对于书写来说是冗长的，而且通常最好不要在应用程序中。因此表名通常不带 schema 前缀，仅仅写个表名。系统决定使用哪个表取决于搜索路径，是一个 schema 命令列表。第一个找到的被当作想要的。如果搜索路径中没找到，会报错，就算想要的表存在于其它 schema 中。

​		在不同的 schema 中创建名字类似的对象会使写精确的SQL变的复杂。也会使某个用户意外或恶意修改其他人的查询变的可能。由于不带 schema 前缀的写法的流行，而且在 pg 内部也会使用，将一个 schema 加入搜索路径有效地信任所有对于 schema 拥有 `CREATE` 权限的用户。当你运行一个 SQL，一个可以在你的搜索路径包含的schema中创建对象的恶意用户，可以控制或执行任意 SQL 函数像你一样。

​		搜索路径中的第一个 schema 被当作当前 schema。不仅仅是第一个被搜索的 schema，也是当 `CREATE TABLE` 语句未指定 schema 时默认使用的 schema。

​		要查看当前搜索路径，使用下面的命令：

```sql
SHOW search_path;
```

​		在默认设置下，会返回：

```sql
search_path
--------------
 "$user", public
```

​		结果中，第一个元素表示第一个搜索路径是与当前用户名一致的 schema。如果这个 schema 不存在，第二个搜索路径是 `public` schema。

​		搜索路径中，第一个存在的 schema 是创建新对象时的默认 schema。这就是默认情况下，创建的对象会在 `public` schema 下的原因。当对象在其他任何上下文中被不带 schema 前缀的引用(表结构修改、表数据修改，或者查询)，搜索路径就会被使用，直到找到一个匹配的对象。因此，在默认配置下，任何未带前缀的访问仅仅只引用 `public` schema。

​		要把一个 schema 加入搜索路径，我们使用：

```sql
SET search_path TO myschema,public;
```

​		(这里我们忽略了 `$user`，因为不急着需要它。) 然后我们可以访问表而无需 schema 签前缀：

```sql
DROP TABLE mytable;
```

​		同时，`myschema` 是搜索路径中第一个元素，新对象会被默认创建在它下面。

​		我们也可以写：

```sql
SET search_path TO myschema;
```

​		这时我们不再能不带 schema 前缀的访问 `public` schema。`public` schema 没什么特别的，只有一个点是：它是默认存在的。也不能被删除。看 [Section 9.26](https://www.postgresql.org/docs/13/functions-info.html) 获取更多操纵搜索路径的知识。

​		搜索路径对于 数据类型、函数、操作符 的工作原理跟表是一样的。数据类型和函数也可以带 schema 前缀，就像表那样。如果你需要在表达式里写一个带 schema 前缀的操作符，有个特别的规定：你必须写

```sql
OPERATOR(schema.operator)
```

​		这样写是必须的，为了防止语法二义性。例如：

```sql
SELECT 3 OPERATOR(pg_catalog.+) 4;
```

​		实践上，操作符经常依赖搜索路径，不用那样丑陋的写法。



#### 5.9.4 schema 与权限

​		默认情况下，用户不能访问不属于自己的 schema 下的任何对象。如果要允许这样操作，schema 的拥有者必须将相关 schema 的 `USAGE` 权限授予使用者。要允许用户使用 schema 下面的对象，要视对象的类型给予其他相关的权限。

​		用户可以被允许在其他人的 schema 下创建对象。要允许这样操作，需要将 schema 的 `CREATE` 权限授予给使用者。注意，默认情况下，任何用户拥有 `public` schema 的 `USAGE` 和 `CREATE` 权限。这允许所有有权限连接指定 database 的用户，在其 `public` schema 下创建对象。一些收回相关授权的 [usage patterns](https://www.postgresql.org/docs/13/ddl-schemas.html#DDL-SCHEMAS-PATTERNS) 调用：

```sql
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
```

​		(上面的例子中，第一个 `public` 是 schema 名，第二个意思是 "所有用户"。第一个是一个标识符，第二个是个关键字，因此不同的大写；查看参考在 [Section 4.11](https://www.postgresql.org/docs/13/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS)。)



#### 5.9.5 系统 schema: catalog

​		除过 `public` 和用户自定义 schema，每个 database 还包含一个 `pg_catalog` schema，这个 schema 包含了系统表和所有的内置数据类型、函数、操作符。`pg_catalog` 是搜索路径中永久有效的部分。如果它没有被显式地写在搜索路径中，它会隐式地在搜索路径中的 schema 之前被搜索。这保证了内置的名字一直可以被找到。然而，你可以显式地将 `pg_catalog` 放置于你的搜索路径最后，如果你想用自定义的名字覆盖内置的名字。

​		因为系统表名字前缀为 `pg_`，最好不要使用这种名字作为用户自定义的名字，以防止与后续版本的系统表名发生冲突。(在默认的搜索路径设置下，一个不带 schema 前缀的表将会引用到系统表而不是你想要的表。) 系统表将会一直遵循这个命令惯例，所以只要用户不建立以 `pg_` 开头的表名，就不会发生冲突。



#### 5.9.6 使用模式

​		可以用 schema 以多种方式组织你的数据。一个 ***schema 安全使用范式*** 可以防止不受信的用户改变其他用户的查询的行为。当一个 database 没有使用 schema安全使用范式 时，用户想要安全地进行查询时，数据库需要在每个回话开始时，采取安全行为。特别是，他们会在打开一个回话时设置 `search_path` 为空字符串或者从 `search_path` 中删除非超级用户可写的 schema。只有一些默认配置支持的使用范式：

* 约束用户到私有的 schema。为了实现这个目标，执行 `REVOKE CREATE ON SCHEMA public FROM PUBLIC` ，然后为每个用户创建一个与用户名同名的 schema。默认的搜索路径第一个 schema 是 `$user`，这被解析为用户名。因此，如果每个用户拥有一个与其他用户隔离开的 schema，默认上，他们回自己的 schema。当一个 database 使用了这个范式，但一些不受信的用户早已登陆，考虑审查 public schema 中名字类似 `pg_catalog` 中的对象名的对象。这个范式是一个 schema 安全使用范式，除非某个非受信用户是 database 的所有者或拥有 `CREATEROLE` 权限，在这种情况下不存在安全的使用范式。
* 从默认搜索路径中删除 `public` schema。通过修改 [postgresql.conf](https://www.postgresql.org/docs/13/config-setting.html#CONFIG-SETTING-CONFIGURATION-FILE) 或使用 `ALTER ROLE ALL SET search_path = "$user"`。每个用户保留向 `public` schema 创建对象的权限，但仅仅使用带 schema 前缀的写法能引用这些对象。虽然带 schema 前缀的表名引用是正常的，但调用 `public` schema 的函数会变的不安全和不可靠。如果你在 `public` schema 创建函数或扩展，使用第一个范式。否则，像第一个范式那样，这是安全的，除非某个非受信用户是 database 的所有者或拥有 `CREATEROLE` 权限。
* 保持默认设置。所有用户隐式地访问 `public` schema。这模仿了 schema 一点也不能用的环境，提供了一个 schema无感 的世界。然而，这不是安全的范式。这仅仅在 database 只有一个用户或一些互信的用户的情况下是可接受的。



​		对于上述的任何一个使用范式，要安装共享的应用程序(表被每个用户使用，第三方提供的额外的函数，等等)，将他们放入分离的 schema。记得授予合适的权限，来允许其他用户来访问他们。这时可以使用这些额外的对象，通过一个带有 schema 前缀的写法。或者他们将额外的 schema 加入他们的搜索路径，他们自己选择。



#### 5.9.7 兼容性

​		在 SQL 标准中，同一个 schema 下的对象被不同的用户所拥有的概念是不存在的。而且，一些实现中不允许你创建与所有者不同名字的 schema。实际上，在哪些实现了基本 schema 支持的数据库系统中，schema 和 用户 的概念几乎是等价的。因此，很多用户认为带限定的名字就是：***user_name.table_name*** 。这在 pg 中，是你为每个用户创建一个 schema 时，pg 的行为。

​		同时，SQL 标准中没有 `public` schema 这个概念。如果为了最大的兼容 SQL 标准，你可以不用 `public` schema。

​		当然，一些 SQL 数据库系统可能完全没实现 schema，或者提供命名空间的支持来允许跨库访问。如果你需要这种系统，最大兼容性的实现应该是一点也不用 schema。



### 5.10 继承

​		pg 实现了表继承，这对数据库设计者可能是个有用的工具。(SQL:1999 和后续的标准定义了类型继承特性，这与此处讨论的东西不同)

​		让我们用一个列子开始：假设我们要为城市创建一个数据模型。每个州都有很多城市，但只有一个首府。我们想要能快速地获取一个州的首府城市。可以创建两个表来实现这个，一个表保存首府城市的信息，一个表保存非首府城市的信息。然而，当我们想获取任意一个城市的信息呢？无论它是不是首府城市。继承特性可以帮我们来解决这个问题。我们定义 `capitals` 表继承自 `cities` 表：

```sql
CREATE TABLE cities (
    name            text,
    population      float,
    elevation       int     -- in feet
);

CREATE TABLE capitals (
    state           char(2)
) INHERITS (cities);
```

​		在上述例子中，`capitals` 表继承了父表 `cities` 的所有列。州的首府城市拥有一个额外的列：`state`，这个列记录首府城市所属的州。

​		在 pg 中，一个表可以从零个或多个表中继承，一个查询可以引用某个表的所有行或者某个表+它的子代表的所有行。后一种行为是默认行为。例如，下面的查询获取所有城市的名字，包括州的首府城市，位于海拔700英尺以上的：

```sql
SELECT name, elevation
    FROM cities
    WHERE elevation > 500;
```

​		根据 pg 教程给定的简单数据(看 [Section 2.1](https://www.postgresql.org/docs/13/tutorial-sql-intro.html)) ，上面的查询会返回：

```sql
   name    | elevation
-----------+-----------
 Las Vegas |      2174
 Mariposa  |      1953
 Madison   |       845
```

​		另一方面，下面的查询会返回所有不是首府城市且海拔500英尺的城市：

```sql
SELECT name, elevation
    FROM ONLY cities
    WHERE elevation > 500;

   name    | elevation
-----------+-----------
 Las Vegas |      2174
 Mariposa  |      1953
```

​		上述例子中，`ONLY` 关键字意思是该查询仅作用于 `cities` 表，不包括继承自 `cities` 的表。以今为止我们讨论过过的很多命令：`SELECT, UPDATE, DELETE` 都支持 `ONLY` 关键字。

​		你也可以在表名后加一个 `*` 来显式地包括继承的表：

```sql
SELECT name, elevation
    FROM cities*
    WHERE elevation > 500;
```

​		写一个 `*` 不是必要的，因为包括继承的表是默认行为。然后，这个语法仍旧被支持，用于与老的 release 版保持兼容。

​		在一些场景中，你可能需要知道某个特定的行属于哪个表。存在一个系统列叫做 `tableoid` 可以告诉你这个答案：

```sql
SELECT c.tableoid, c.name, c.elevation
FROM cities c
WHERE c.elevation > 500;
```

​		这会返回：

```sql
 tableoid |   name    | elevation
----------+-----------+-----------
   139793 | Las Vegas |      2174
   139793 | Mariposa  |      1953
   139798 | Madison   |       845
```

​		(如果你重新生成这个例子，你将会得到不同的 oid) 通过与 `pg_class` 表作 JOIN ，你可以查看表名：

```sql
SELECT p.relname, c.name, c.elevation
FROM cities c, pg_class p
WHERE c.elevation > 500 AND c.tableoid = p.oid;
```

​		这会返回：

```sql
 relname  |   name    | elevation
----------+-----------+-----------
 cities   | Las Vegas |      2174
 cities   | Mariposa  |      1953
 capitals | Madison   |       845
```

​		另一个效果一样的方法是使用 `regclass` 别名类型，这将会输出 OID 的象征意义：

```sql
SELECT c.tableoid::regclass, c.name, c.elevation
FROM cities c
WHERE c.elevation > 500;
```

​		继承不会自动地将数据从 INSERT 和 COPY 命令传递给子代表。在我们的例子中，下列命令会执行失败：

```sql
INSERT INTO cities (name, population, elevation, state)
VALUES ('Albany', NULL, NULL, 'NY');
```

​		我们可能希望数据被影射到 `capitals` 表，但实际并不会发生：INSERT 只会将数据插入指定的表中。在一些情况下可以使用一个规则将插入动作映射到其他表(看 [Chapter 40](https://www.postgresql.org/docs/13/rules.html)) 。但对上述的例子不顶用，因为 `cities` 表不存在 `state` 列，因此在规则被应用之前，INSERT 就被拒绝掉了。

​		父表所有的 check 约束和 not-null 约束都会被子表继承，除非用 `NO INHERIT` 子句指定。其他类型的约束(唯一约束，主键，外键) 不会被继承。

​		一个表可以从超过一个父表中继承，在这种情况下，它拥有所有父表的列的集合。子表中定义的列会被加入到这个集合。如果父表之间有重名的列，或者父表与子表有重名的列，这些重名的列会被 "合并"，也就是说，子表中只有一个重名的列。要能被 “合并”，重名的列必须拥有相同的数据类型，否则会报错。可继承的 check 约束和 not-null 约束会以同样的方式被 “合并”。举例来说，如果重名的列有一个来源被标记为 not-null，那么子表中这个列也会被标记为 not-null。check 约束如果重名就会被合并，如果 check 约束的条件不一致，合并将会失败。

​		表继承关系在子表建立的时候被建立，在 `CREATE TABLE` 命令中使用 `INHERITS` 子句。如果子表被以兼容的方式建立，后续也可以继续为它添加继承关系，使用 `ALTER TABLE` 的 `INHERIT` 子句。要做到这一点，子表必须已经包含父表所有的列。还必须包含父表的 check 约束。与此类似，可以从子表上移除一个父表继承关系，使用 `ALTER TABLE` 的 `NO INHERIT` 子句。像前述那样动态的增加或删除表继承关系对于表分区操作是非常有用的(看 [Section 5.11](https://www.postgresql.org/docs/13/ddl-partitioning.html))。

​		一个方便的创建兼容的表的方式是使用 `CREATE TABLE` 命令的 `LIKE` 子句。这会创建一个与原表相同表结构的新表。如果原表上定义了 check 约束，那么应该使用 `LIKE` 子句的 `INCLUDING CONSTRAINTS` 选项，因为子表必须拥有被认为是兼容的约束。

​		一个父表不能在子表还存在的情况下被删除。子表中从父表中继承的列和 check 约束不能被删除也不能被修改。如果你想删除一个父表与所有的子代表，一个简单的方法是删除父表的时候加上 `CASCADE` 选项(看 [Section 5.14](https://www.postgresql.org/docs/13/ddl-depend.html))。

​		[ALTER TABLE](https://www.postgresql.org/docs/13/sql-altertable.html) 会将列和 check 约束的任何变化向子代表传递。在说一次，被其他表依赖的列只有加上 `CASCADE` 关键字才能被删除。`ALTER TABLE` 遵循与 `CREATE TABLE` 一样的列合并与拒绝的规则。

​		继承的查询只检查父表的访问权限。因此，例如，被授予了 `cities` 表的 UPDATE 权限意味着当数据从 `cities` 表被访问的时候  `capitals` 表的数据也可以被更新。这维护了数据在父表中的存在性。但是没有授权的情况下，`capitals` 表的数据是不能更新的。与此类似，父表中的行安全策略也被应用到子表的行上，在一个继承的查询里。一个子表的策略，如果存在的话，仅应用于它在查询中出现的时候；在这种情况下，任何关联到父表的策略都被忽略。

​		外部表(看 [Section 5.12](https://www.postgresql.org/docs/13/ddl-foreign-data.html)) 也可以是继承关系的子代，可以作为父表，也可以作为子表，也可以仅作为一个普通的表。如果外部表作为继承关系的一部分，外部表不支持的操作在所有子表上也能被支持。



#### 5.10.1 中止

​		注意，不是所有的 SQL 命令适用于继承关系。查询数据、修改数据、修改 schema (例如，`SELECT, UPDATE, DELETE`，`ALTER TABLE` 的大部分变量，但 `INSERT` 或 `ALTER TABLE ... RENAME` 不会这样。) 默认支持包含子表或者支持以 `ONLY` 子句来执行。作维护的 SQL 命令，(像 `REINDEX, VACCUM` ) 典型只工作在单个的、物理的表，而不支持在继承关系上的递归。每个单个的命令的行为被描述在参考文档上（[SQL ](https://www.postgresql.org/docs/13/sql-commands.html)）。

​		继承特性的一个重要限制是：索引和外键约束仅仅应用单个表，不是它们的子代。被外键引用的表或用外键约束的表都遵循这个规则。因此，上面的例子中：

* 如果我们将 `cities.name` 定义为主键或唯一索引，这不会阻止 `capitals` 表拥有和父表字段名一样的列。那些重复的行默认会被展示对于来自 `cities` 的查询。实际上，默认情况，`capitals` 表不会拥有唯一约束，所以可以包含名字一样的多个行。你可以为 `capitals` 表加上唯一约束，相较于 `cities` 表，这不会防止重复的行。
* 相似的，如果我们指定 `cities.name` 外键引用某个其他表的列，这个约束不会自动传播给 `capitals` 表。在这种情况下，你可以手动为 `capitals` 表加上外键约束。
* 指定其他表外键引用 `cities.name`，将会允许其他表包含城市名，但不是首府名。对于这种情况没啥好对策。



​		一些继承没实现的功能在可声明的分区功能上实现了。决定是否分区带继承时三思而后行对你的应用程序是非常有用的。



### 5.11 表分区

​		pg 支持基础的表分区。这个小节描述了：为什么 & 怎样 将表分区作为你的数据库设计的一部分。



#### 5.11.1 概览

​		表分区是指将逻辑上很大的一个表分成物理上的小片。表分区有以下几个优点：

* 在一些确切的环境中，查询性能有很大提高，特别是当访问最频繁的行位于一个分区内或几个分区内。分区有效地替代了具有更高高度的索引树，使得索引中最频繁使用的部分可以放入内存。
* 若查询或更新大部分访问一个分区，使用在那个分区上的顺序扫描比使用索引更能提升性能，使用索引会将任意读取分散到整个表上。
* 数据块加载与删除数据可以通过添加或删除分区来实现，如果使用范式被限定为分区设计。删除某个分区可以使用 `DROP TABLE` 或者 `ALTER TABLE DETOUCH PARTITION` ，比数据块操作快很多。这些命令会防止 `VACCUM` 由于数据块的删除。
* 很少被访问的数据可以被移动到更加便宜或更加慢的存储设备上。



​		这些优点在表非常大的时候是非常有用的。一个表从分区中受益的确切的点取决于应用程序，首要规则是表的大小应该超过数据库服务器的物理内存大小。

​		pg 对以下几种形式的分区提供了内置的支持：

* Range Partitioning

  一个表被按照范围分区，范围由一个关键列或多个关键列定义，不同分区的范围没有重叠。例如，一个表按照日期范围分区，或者按照商业对象的标识分区。每个范围的边界，是小的被包含，大的不包含。例如，一个分区的范围是1到10，下一个分区的范围是10到20，10属于第二个分区而不是第一个。

* List Partitioning

  表被按照分区指定的值来分区。

* Hash Partitioning

  表按分区指定的系数和余数来分区。Each partition will hold the rows for which the hash value of the  partition key divided by the specified modulus will produce the  specified remainder.



​		如果你的应用程序需要使用其他形式的分区，继承或 `UNION ALL` 可以被使用。这些方法提升了复杂度，但没有内置的声明式分区方法所能提供的一些性能提升。

​		

#### 5.11.2 声明式分区(Declarative Partitioning)

​		pg 允许你声明一个表是要被分区的。被分区的表被视为 **分区表**。声明中包含 分区方法(上面列出的)，一个被用作分区key的列名列表或表达式。

​		分区表是个 “虚表”，没有自己的存储空间。取而代之，存储属于分区，分区是与分区表关联的原始表。每个分区存储了数据的一个子集。所有被插入到分区表的行会被影射到一个分区，根据分区key。分区key相关的列的修改可能会导致行被移动到其他分区。

​		分区本身可能被定义为分区表，导致子分区出现。虽然所有的分区需要拥有相同的列，因为它们的源，分区可以拥有自己的索引、约束、和默认值，相对于其他分区是唯一的。看 [CREATE TABLE](https://www.postgresql.org/docs/13/sql-createtable.html) 了解更多关于分区表和分区的细节。

​		将一个一般的表转变为分区表是不可能的，反向也是不可能的。然而，将一个一般的表或分区表作为一个分区表的分区是可能的，或者将分区表的分区删除，将它转变为一个独立的表。这可以简化或加速很多维护过程。看 [ALTER TABLE](https://www.postgresql.org/docs/13/sql-altertable.html) 了解更多关于 `ATTACH PARTITION` 和 `DETACH PARTITION` 的知识。

​		分区也可以是外部表，即使它们拥有一些一般表没有的限制，看 [CREATE FOREIGN TABLE](https://www.postgresql.org/docs/13/sql-createforeigntable.html) 查看更多信息。



##### 5.11.2.1 例子

​		假设我们要为一个大型冰淇凌公司构建数据库。这个公司每天测量最高温度，并记录每个区域的销量。概念上，我门需要这样一个表：

```sql
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
```

​		我们知道大部分查询会访问最近一周、最近一月、最近一个季度的数据，因为这个表的主要作用是为管理人员提供在线报告。为了减少老数据的数量，决定只存储最近3年的数据。每个月初我们会删除最老的一个月的数据。在这种情况下，我们可以使用分区表来满足我们的各种需求。

​		要在这个例子中使用声明式分区，需要以下步骤：

1. 通过使用 `PARTITION BY` 子句来将 `measurement` 表创建为分区表，这个子句包括分区方法(这个例子汇总使用 RANGE PARTITION)、作为分区 key 的列。

   ```sql
   CREATE TABLE measurement (
       city_id         int not null,
       logdate         date not null,
       peaktemp        int,
       unitsales       int
   ) PARTITION BY RANGE (logdate);
   ```

2. 创建分区。每个分区的定义中必须指定符合分区方法和分区key的边界。注意，这样指定边界，新分区的值会覆盖老分区的值，这将会造成错误。

   因此，可以在 pg 的一般表(或者可能的话，外部表)上以任何方式创建分区。可以单独为每个分区指定 tablespace 和 存储参数。

   对于我们的例子，每个分区应该存储一个月的数据，这是为了满足一次性删除一个月的数据的需求。所以命令想下面这样：

   ```sql
   CREATE TABLE measurement_y2006m02 PARTITION OF measurement
       FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');
   
   CREATE TABLE measurement_y2006m03 PARTITION OF measurement
       FOR VALUES FROM ('2006-03-01') TO ('2006-04-01');
   
   ...
   CREATE TABLE measurement_y2007m11 PARTITION OF measurement
       FOR VALUES FROM ('2007-11-01') TO ('2007-12-01');
   
   CREATE TABLE measurement_y2007m12 PARTITION OF measurement
       FOR VALUES FROM ('2007-12-01') TO ('2008-01-01')
       TABLESPACE fasttablespace;
   
   CREATE TABLE measurement_y2008m01 PARTITION OF measurement
       FOR VALUES FROM ('2008-01-01') TO ('2008-02-01')
       WITH (parallel_workers = 4)
       TABLESPACE fasttablespace;
   ```

   (回忆一下，临近的分区可以共享边界值，因为范围的上界是不包含在范围内的。)

   如果你想实现子分区，再次指定 `PARTITION BY` 子句，在创建单个分区的命令中，例如：

   ```sql
   CREATE TABLE measurement_y2006m02 PARTITION OF measurement
       FOR VALUES FROM ('2006-02-01') TO ('2006-03-01')
       PARTITION BY RANGE (peaktemp);
   ```

   创建分区 `measurement_y2006m02` 之后，被插入到 `measurement` 表的任何记录如果被影射到 `measurement_y2006m02` 分区，这些记录将会被进一步映射到根据 `peaktemp` 列划分的分区中。分区 key 可能和上一级分区的key有所重叠，

   。

   向父表中插入不能映射到任何已存在分区的记录将会造成报错，需要人工添加一个合适的分区。

   为分区人工创建表约束来描述分区边界不是必须的。这些约束会被自动创建。

3. 在分区key的列上创建索引，并创建其他你需要的索引，在分区表上。(分区key上的索引不是必须的，但大部分场景这个都很有用。) 这会在每个分区上自动创建合适的索引，而且后来创建或添加的分区也会拥有该索引。在分区表上声明的索引或唯一约束，跟分区表一样是 “虚” 的：实际的索引在各个分区的表的子索引中。

   ```sql
   CREATE INDEX ON measurement (logdate);
   ```

4. 确保 [enable_partition_pruning](https://www.postgresql.org/docs/13/runtime-config-query.html#GUC-ENABLE-PARTITION-PRUNING) 配置参数在配置文件 postgresql.conf 中是开启的。如果没开启，查询将不会按期望的那样被优化。



​		在上面的例子中，我们将每个月创建一个分区，所以写个脚本自动生成 DDL 是比较方便的。



##### 5.11.2.2 分区维护

​		初始建立分区表时就被建立的分区集合一般不会保持静态。删除存储老数据的分区和周期性的添加包含新书的分区这种事是非常普遍的。分区操作的一个重要优点是：它可以精确地执行这种繁重的工作通过几乎立刻操作分区的结构，而不是移动大量的数据。

​		删除老数据的最简单方法是删除对应的分区：

```sql
DROP TABLE measurement_y2006m02;
```

​		这可以非常快地删除上百万的记录，因为不必单独删除每个记录。但要注意上述的命令要求取得父表的 `ACCESS EXCLUSIVE` 锁。

​		另一个比较受欢迎的方法是从分区表中移除分区，但将分区作为一个表的形式保留下来：

```sql
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02;
```

​		这允许对分区中的数据进行更进一步的处理，在它被删除之前。例如，这通常是使用 `COPY`、pg_dump 或其他类似工具备份数据的好时机。也可能是将数据进行聚合处理，例如执行其他数据操作或运行报表的好时机。

​		与此相似，我们可以增加新分区来处理新数据。我们可以为分区表创建一个空分区，就像前述那样创建的原始分区一样：

```sql
CREATE TABLE measurement_y2008m02 PARTITION OF measurement
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01')
    TABLESPACE fasttablespace;
```

​		相较于添加新分区，有时更方便的方式是在分区结构之外创建一个新表，后面再将这个新表作为分区的一部分。这允许新数据被加载、检查、传输 在它出现在分区表之前。`CREATE TABLE ... LIKE` 对于重复按父表结构定义是有帮助的：

```sql
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS)
  TABLESPACE fasttablespace;

ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate >= DATE '2008-02-01' AND logdate < DATE '2008-03-01' );

\copy measurement_y2008m02 from 'measurement_y2008m02'
-- possibly some other data preparation work

ALTER TABLE measurement ATTACH PARTITION measurement_y2008m02
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01' );
```

​		在运行 `ATTACH PARTITION` 命令之前，建议在要加入分区的表上创建 check 约束，来匹配期望的分区约束，就像上面描述的那样。这种方式下，系统能跳过用来验证分区约束的扫描。如果没有 check 约束，表将会被扫描，来验证分区的约束，这操作要求持有分区的 `ACCESS EXCLUSIVE` 锁和父表的 `SHARE UPDATE EXCLUSIVE` 锁。建议在完成 `ATTACH PARTITION` 操作后，删除冗余的 check 约束。

​		如上所述，在分区表上创建所以是可能的，因此它们被自动应用到所有层级。这时非常方便的，不仅仅已存在的分区会被索引，未来创建的分区也会被索引。一个限制是创建这样的索引时不能使用 `CONCURRENTLY` 模式。要避免长时间的锁表，可以使用 `CREATE INDEX ON ONLY` 在分区表上，这样的索引被标记为 "invalid"，分区不会被自动应用这个索引。可以在分区上独立创建索引使用 `CONCURRENTLY` 模式，然后将分区上索引 attach 到父表的索引上，使用 `ALTER INDEX .. ATTACH PARTITION` 命令。一旦所有分区的索引被 attach 到父表的索引上，父表上的索引会被自动标记为 "valid"。例如：

```sql
CREATE INDEX measurement_usls_idx ON ONLY measurement (unitsales);

CREATE INDEX measurement_usls_200602_idx
    ON measurement_y2006m02 (unitsales);
ALTER INDEX measurement_usls_idx
    ATTACH PARTITION measurement_usls_200602_idx;
...
```

​		这个技术也可以和 唯一约束、主键 一起使用，索引将会被隐式地创建当约束被创建的时候。例如：

```sql
ALTER TABLE ONLY measurement ADD UNIQUE (city_id, logdate);

ALTER TABLE measurement_y2006m02 ADD UNIQUE (city_id, logdate);
ALTER INDEX measurement_city_id_logdate_key
    ATTACH PARTITION measurement_y2006m02_city_id_logdate_key;
...
```



##### 5.11.2.3 限制

​		下面的限制适用于分区表：

* 分区表的唯一约束必须包含所有分区key的列。这个限制存在是因为构成约束的单个索引仅仅能在它们所在的分区内保证唯一性，因此，分区结构自身必须保证不同的分区之间不能存在重复的行。
* 在整个分区表上创建排除约束是可能的。允许的在每个叶子分区设置单个的这种约束。再说一次，这个限制起源于不能强制跨分区约束。
* 在 `INSERT` 上的  `BEFORE ROW` 触发器，不能改变修改作为新插入行的最终存储的分区。
* 在同一分区树上的固定的临时或永久关系是不被允许的。因此，如果分区表是永久的，so must be its partitions and likewise if the partitioned table is temporary. 当使用临时表，该分区树的所有成员必须来自同一回话。



​		单个分区被使用幕后继承来和他们的分区表连接在一起。然而，However, it is not possible to use all of the generic features of  inheritance with declaratively partitioned tables or their partitions,  as discussed below。显而易见，除了所属的分区表，一个分区不能拥有其他父级，一个表也不能同时从一个普通表和一个分区表继承。这意味着分区表不会于普通表共享继承后代。

​		因为分区表和它的分区组成的分区层级仍旧是一个继承层级，[Section 5.10](https://www.postgresql.org/docs/13/ddl-inherit.html)  描述的关于继承的所有一般规则都是适用的，出了一些例外：

* 分区不能拥有当前不在父级的列。用 `CREATE TABLE` 创建分区时不能指定列，事后使用 `ALTER TABLE` 也不能添加列。只有表的列与父级是匹配的时候，才可以用 `ALTER TABLE ... ATTACH PARTITION` 将一个表添加为分区。
* 分区表的 check 约束和 not-null 约束被其所有分区所继承。分区表上不允许创建标记为 `NO INHERIT` 的 check 约束。如果父表中某个列上存在 not-null 约束，你不能删除该分区上这个列的 not-null 约束。
* 使用 `ONLY` 关键字在分区表上添加或删除约束被支持地像没有分区一样。一旦分区存在，使用 `ONLY` 会报错。取而代之，只在分区上的约束可以被删除或添加（如果当前父表中没有）。



#### 5.11.3 使用继承的分区

​		内置的声明式分区适用大多数使用场景，对于一些其他情况，使用更复杂的方式可能更有用。分区可以别实现使用表继承，这允许几个不被声明式分区支持的特性，例如：

* 对于声明式分区，分区必须拥有和父表一样的列集合，对于表继承，子表可以拥有相对于父表额外的列。
* 表继承支持多继承。
* 声明式分区仅支持 range 分区、list 分区、hash 分区，表继承允许数据被一个符合用户需求的方式来划分。(然而，要注意，如果排除约束不能有效的修剪子表，查询性能可能会很差)
* 相较于使用表继承，使用声明式分区在一些操作上需要更大的锁。例如，从一个分区表中删除一个分区，需要持有父表的 `ACCESS EXCLUSIVE` 锁，而在表继承中，仅需要 `SHARE UPDATE EXCLUSIVE` 锁。



##### 5.11.3.1 例子

​		这个例子构建一个等价于上述的声明式分区例子的分区结构。使用如下步骤：

1. 创建 master 表，所有的子表将从这个表中继承。这个表没有数据。不要在这个表上定义任何check约束，除非你想要它们应用于所有子表。在表上定义索引或唯一约束也是无意义的。对于我们的例子，master 表是 `measurement`：

   ```sql
   CREATE TABLE measurement (
       city_id         int not null,
       logdate         date not null,
       peaktemp        int,
       unitsales       int
   );
   ```

2. 创建几个子表，每个都继承于 master 表。正常情况下，这些子表相对于 master 表不会新增列。Just as with declarative partitioning, 这些表在任何意义上都是 pg 一般表(或外部表)。

   ```sql
   CREATE TABLE measurement_y2006m02 () INHERITS (measurement);
   CREATE TABLE measurement_y2006m03 () INHERITS (measurement);
   ...
   CREATE TABLE measurement_y2007m11 () INHERITS (measurement);
   CREATE TABLE measurement_y2007m12 () INHERITS (measurement);
   CREATE TABLE measurement_y2008m01 () INHERITS (measurement);
   ```

3. 向子表添加非重叠约束，为每个定义允许的 key-value。

   典型的例子：

   ```sql
   CHECK ( x = 1 )
   CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
   CHECK ( outletID >= 100 AND outletID < 200 )
   ```

   确保约束能保证不同子表的 key-value 没有重叠。常见的错误操作是定义像下面这样的范围约束：

   ```sql
   CHECK ( outletID BETWEEN 100 AND 200 )
   CHECK ( outletID BETWEEN 200 AND 300 )
   ```

   上面的是错的，因为没有明确说明 200 属于哪个子表。取而代之，范围应该被定义为类似如下风格：

   ```sql
   CREATE TABLE measurement_y2006m02 (
       CHECK ( logdate >= DATE '2006-02-01' AND logdate < DATE '2006-03-01' )
   ) INHERITS (measurement);
   
   CREATE TABLE measurement_y2006m03 (
       CHECK ( logdate >= DATE '2006-03-01' AND logdate < DATE '2006-04-01' )
   ) INHERITS (measurement);
   
   ...
   CREATE TABLE measurement_y2007m11 (
       CHECK ( logdate >= DATE '2007-11-01' AND logdate < DATE '2007-12-01' )
   ) INHERITS (measurement);
   
   CREATE TABLE measurement_y2007m12 (
       CHECK ( logdate >= DATE '2007-12-01' AND logdate < DATE '2008-01-01' )
   ) INHERITS (measurement);
   
   CREATE TABLE measurement_y2008m01 (
       CHECK ( logdate >= DATE '2008-01-01' AND logdate < DATE '2008-02-01' )
   ) INHERITS (measurement);
   ```

4. 对于每个子表，为 key 列建立索引，也要建其他的你需要的索引：

   ```sql
   CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
   CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
   CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);
   CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);
   CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);
   ```

5. 我们想要应用程序执行 `INSERT INTO measurement ...` 命令时数据被影射到合适的子表中。我们可以通过向 master 表添加一个触发器函数来完成这个目标。如果数据仅仅被添加到最近的子表中，用一个简单的触发器函数就能做到：

   ```sql
   CREATE OR REPLACE FUNCTION measurement_insert_trigger()
   RETURNS TRIGGER AS $$
   BEGIN
       INSERT INTO measurement_y2008m01 VALUES (NEW.*);
       RETURN NULL;
   END;
   $$
   LANGUAGE plpgsql;
   ```

   创建完函数后，再创建一个触发器来调用这个触发器函数：

   ```sql
   CREATE TRIGGER insert_measurement_trigger
       BEFORE INSERT ON measurement
       FOR EACH ROW EXECUTE FUNCTION measurement_insert_trigger();
   ```

   我们必须每个月重新定义触发器函数，因此它才能将数据插入到当前的子表。触发器定义不需要被更新。

   我们可能想要服务器自动确定数据该添加到哪个子表。可以用更复杂的触发器函数来做到这个，例如：

   ```sql
   CREATE OR REPLACE FUNCTION measurement_insert_trigger()
   RETURNS TRIGGER AS $$
   BEGIN
       IF ( NEW.logdate >= DATE '2006-02-01' AND
            NEW.logdate < DATE '2006-03-01' ) THEN
           INSERT INTO measurement_y2006m02 VALUES (NEW.*);
       ELSIF ( NEW.logdate >= DATE '2006-03-01' AND
               NEW.logdate < DATE '2006-04-01' ) THEN
           INSERT INTO measurement_y2006m03 VALUES (NEW.*);
       ...
       ELSIF ( NEW.logdate >= DATE '2008-01-01' AND
               NEW.logdate < DATE '2008-02-01' ) THEN
           INSERT INTO measurement_y2008m01 VALUES (NEW.*);
       ELSE
           RAISE EXCEPTION 'Date out of range.  Fix the measurement_insert_trigger() function!';
       END IF;
       RETURN NULL;
   END;
   $$
   LANGUAGE plpgsql;
   ```

   触发器定义跟前面的相同。注意每个 IF 必须确实匹配每个子表的 check 约束。

   当这个函数比单月函数更加复杂时，就不需要更频繁的更新，因为需要的话可以增加分支。

   > **Note**
   >
   > ​		在实践上，更高的方案可能是首先检查最新子表，如果大量的行要被插入那个子表。为了简便起见，我们在这例子的其他部分以同样的顺序展示了触发器的测试。

   另一个将插入行映射到合适的子表的方案是设置规则，来代替触发器，在 master 表上，例如：

   ```sql
   CREATE RULE measurement_insert_y2006m02 AS
   ON INSERT TO measurement WHERE
       ( logdate >= DATE '2006-02-01' AND logdate < DATE '2006-03-01' )
   DO INSTEAD
       INSERT INTO measurement_y2006m02 VALUES (NEW.*);
   ...
   CREATE RULE measurement_insert_y2008m01 AS
   ON INSERT TO measurement WHERE
       ( logdate >= DATE '2008-01-01' AND logdate < DATE '2008-02-01' )
   DO INSTEAD
       INSERT INTO measurement_y2008m01 VALUES (NEW.*);
   ```

   规则相比于触发器，有明显更高的维护消耗，但这个消耗是每个查询一次，而不是每个行一次，所以这个方法对于大块插入数据可能是有益的。然而，在大多数场景下，触发器方案会有更高的性能。



