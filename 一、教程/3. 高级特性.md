#### 3.1 简介

​		英文文档：https://www.postgresql.org/docs/13/tutorial-advanced-intro.html



​		前面的章节里，我们讲述了如何使用 SQL 在 pg 中存储、访问数据。现在我们要讨论一些更加高级的 SQL 特性，这些特性可以帮助你简化管理，防止数据丢失或损坏。最后，我们将讨论一些 pg 自己的扩展。

​		这一章节将会在适当的时机引用第二章节中的例子并加以改变或改进，所以，预先读过第二章节是非常必要的。这一章的一些例子也可以在教程目录中的 **advanced.sql** 中被找到，这份文件中包好了一些可以加载的数据，这里就不再重复了（如何使用请参考[Section 2.1](https://www.postgresql.org/docs/13/tutorial-sql-intro.html)）。



#### 3.2 视图(Views)

​		英文文档：https://www.postgresql.org/docs/13/tutorial-views.html



​		回看 [Section 2.6](https://www.postgresql.org/docs/13/tutorial-join.html) 的 SQL。假设结合的天气记录和城市位置对你的应用程序有特殊的意义，但你不想每次都输入 SQL。你可以基于这个 SQL 建一个视图，给这个 SQL 一个名字，这样你可以像查询一个表一样来查询这个视图：

```sql
CREATE VIEW myview AS
    SELECT city, temp_lo, temp_hi, prcp, date, location
        FROM weather, cities
        WHERE city = name;

SELECT * FROM myview;
```



​		自由的使用视图对于好的数据库设计是关键的方面。视图允许你将表的细节封装起来，这可能变成你的应用程序的进化，在一致性的接口后面。

​		视图几乎可以被应用在任何表被应用的地方。在其他视图上建立视图也是非常普遍的。



#### 3.3 外键(Foreign Keys)

​		英文文档：https://www.postgresql.org/docs/13/tutorial-fk.html



​		让我们回到第二章节的 weather 和 cities 表。考虑如下问题：你想保证没有能向 weather 表中插入在 cities 表中不存在的城市的天气记录。这种行为被称为 “维护数据的**引用一致性**”。在非常简单的数据库系统中要实现前述目标，需要你先查看 cities 表中的数据，然后决定是否向 weather 表中插入数据。这种方式存在一些问题而且是不方便的，所以 pg 为你把这一切都做好了。

​		新的表声明(declaration)如下：

```sql
CREATE TABLE cities (
        city     varchar(80) primary key,
        location point
);

CREATE TABLE weather (
        city      varchar(80) references cities(city),
        temp_lo   int,
        temp_hi   int,
        prcp      real,
        date      date
);
```



​		现在，尝试插入一条非法数据：

```sql
INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');

ERROR:  insert or update on table "weather" violates foreign key constraint "weather_city_fkey"
DETAIL:  Key (city)=(Berkeley) is not present in table "cities".
```



​		外键的行为能自然的溶于你的应用程序的逻辑。这个教程中不会再讲比上述例子更复杂的情况，如欲了解更多信息请查看 [Chapter 5](https://www.postgresql.org/docs/13/ddl.html)。正确地使用外键会提升你的应用程序的质量，所以强烈建议学习外键的知识。
