​		pg 有丰富的原生数据类型。用户可以使用 [CREATE TYPE](https://www.postgresql.org/docs/13/sql-createtype.html) 命令来给 pg 添加数据类型。

​		Table 8.1 展示了所有的内置通用目的数据类型。大部分被列在 `Aliases` 列的备选名字是 pg 因为历史原因内部使用的名字。额外的，一些内部使用的或已经废弃的类型是可以使用的，但是没列在这里。



**Table 8.1**

| Name                                    | Aliases            | Description                                    |
| --------------------------------------- | ------------------ | ---------------------------------------------- |
| bigint                                  | int8               | 有符号8字节整型                                |
| bigserial                               | serial8            | 自增8字节整型                                  |
| bit [ (n) ]                             |                    | 定长比特字符串                                 |
| bit varying [ (n) ]                     | varbit [ (n) ]     | 变长比特字符串                                 |
| boolean                                 | bool               | 逻辑布尔(true/false)                           |
| box                                     |                    |                                                |
| bytea                                   |                    | 二进制数据("byte array")                       |
| character [ (n) ]                       | char [ (n) ]       | 定长字符串                                     |
| character varying [ (n) ]               | varchar [ (n) ]    | 变长字符串                                     |
| cidr                                    |                    | IPv4 或 IPv6 网络地址                          |
| circle                                  |                    | 平面上的环                                     |
| date                                    |                    | 日历日期(年，月，日)                           |
| double precision                        | float8             | 双精度浮点型(8字节)                            |
| inet                                    |                    | IPv4 或 IPv6 主机地址                          |
| integer                                 | int, int4          | 有符号4字节整形                                |
| interval [ fields ] [ (p) ]             |                    | 时间跨度                                       |
| json                                    |                    | 文本格式的 JSON 数据                           |
| jsonb                                   |                    | 二进制格式的 JSON 数据，分解的                 |
| line                                    |                    | 平面上的无限长度的线                           |
| lseg                                    |                    | 平面上的线段                                   |
| macaddr                                 |                    | MAC(媒体控制访问)地址                          |
| macaddr8                                |                    | MAC(媒体控制访问)地址(EUI-64 格式)             |
| money                                   |                    | 现金数量                                       |
| numeric [ (p, s) ]                      | decimal [ (p, s) ] | 可选精度的精确数字                             |
| path                                    |                    | 平面上的地理路径                               |
| pg_lsn                                  |                    | pg log 的序列号                                |
| pg_snapshot                             |                    | 用户级别的事务 ID 快照                         |
| point                                   |                    | 平面上的地理点                                 |
| polygon                                 |                    | 平面上封闭的地理路径                           |
| real                                    | float4             | 单精度浮点型(4字节)                            |
| smallint                                | int2               | 有符号两字节整形                               |
| smallserial                             | serial2            | 自增的两字节整形                               |
| serial                                  | serial4            | 自增的四字节整形                               |
| text                                    |                    | 变长字符串类型                                 |
| time [ (p) ] [ without time zone ]      |                    | 一天内的时刻(没有时区)                         |
| time [ (p) ] with time zone             | timetz             | 一天内的时刻，包括时区                         |
| timestamp [ (p) ] [ without time zone ] |                    | 日期与时间(没有时区)                           |
| timestamp [ (p) ] with time zone        | timestamptz        | 日期与时间，包括时区                           |
| tsquery                                 |                    | 文本查找查询                                   |
| tsvector                                |                    | 文本查找文档                                   |
| txid_snapshot                           |                    | 用户级别的事务 ID 快照(废弃的；看 pg_snapshot) |
| uuid                                    |                    | 全局唯一标识符                                 |
| xml                                     |                    | XML 数据                                       |



> **兼容性**
>
> ​		下面的数据类型(或者) 被 SQL 指定：bigint, bit, bit varying, boolean, char, character varing, character, varchar, date, double precision, integer, interval, numeric, decimal, real, smallint, time(带或不带时区)，timestamp(带或不带时区)，xml。

​		每个数据类型拥有一个由它的输入和输出函数决定的外部的表示。大部分内置类型拥有明显的外部形式。然而，几个类型要么是对于 pg 是唯一的，像地理路径，要么拥有几个可能的形式，例如日期和时间类型。一些输入和输出函数不是可逆的，例如，输出函数的结果可能丢失精度，当相对于原始输入。



## 8.1 数字类型

​		数字类型由 2字节、4字节、8字节 整数，4字节、8字节 浮点型数字，可选精度的小数 组成。Table 8.2 列出了类型。

**Table 8.2**

| Name             | Storage | Description          | Range                                               |
| ---------------- | ------- | -------------------- | --------------------------------------------------- |
| smallint         | 2字节   | 小范围整数           | -32768 到 32767                                     |
| integer          | 4字节   | 整数的典型选择       | -2147483648 到 +2147483647                          |
| bigint           | 8字节   | 大范围整数           | -9223372036854775808 到+9223372036854775807         |
| decimal          | 变长    | 用户指定精度，精确的 | 小数点前上限 131072 个数字；小数点后上限16383个数字 |
| numeric          | 变长    | 用户指定精度，精确的 | 小数点前上限 131072 个数字；小数点后上限16383个数字 |
| real             | 4字节   | 变精度，不精确的     | 6个小数精度                                         |
| double precision | 8字节   | 变精度，不精确的     | 15个小数精度                                        |
| smallserial      | 2字节   | 小自增整数           | 1 到 32767                                          |
| serial           | 4字节   | 自增整数             | 1 到 2147483647                                     |
| bigserial        | 8字节   | 大自增整数           | 1 到 9223372036854775807                            |



​		数字类型的常量被描述在 [Section 4.1.2](https://www.postgresql.org/docs/13/sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS) 。数字类型拥有很多算数运算符和函数。引用 [Chapter 9](https://www.postgresql.org/docs/13/functions.html) 看更多信息。接下来的小节描述了类型的细节。



### 8.1.1 整数类型

​		数据类型 `smallint`、`integer`、`bigint` 存储了整个数字，这是说，小数部分，各种范围的。尝试存储超过范围的值将会导致错误。

​		`integer` 类型是一般选择，它提供了对于表示范围、存储大小、和性能之间最好的平衡。`smallint` 类型一般只在次盘空间小时使用。`bigint` 被设计用来针对需要很大表示范围的场景。

​		SQL 仅指定了整数类型 `integer` (or `int`)、`smallint`、`bigint` 。数据类型名 `int2`、`int4`、`int8` 是扩展的，这也被应用在其他的数据库系统中。



### 8.1.2 任意精度数字

​		类型 `numeric` 可以存储具有很多位数字的数。特别推荐它用来存储金钱数量和其他精度有要求的量。

​		用 `numeric` 值来计算可能产生更精确的值，例如，加法，减法、乘法。然而，`numeric` 值的计算相对于整数类型或下个小节将要讨论的浮点数来说是非常慢的。

​		我们使用这样的说法：`numeric` 的 ***精度(precision)*** 是整个数字的有效数字的总数，这是说，小数点两边的数字的数量。`numeric` 的 ***刻度(scale)*** 是指小数部分的数字的数量。所以数字 23.5141 的精度的是 6 ，刻度是 4。可以认为整数的刻度是 零。

​		`numeric` 列的精度和刻度都是可以配置的。使用下列语法来声明一个 `numeric` 列：

```sql
NUMERIC(precision, scale)
```

​		精度必须是正数，刻度是零或者正数。还有种语法：

```sql
NUMERIC(precision)
```

​		上述语法默认指定刻度为零。如果这样写：

```sql
NUMERIC
```

​		不指定精度和刻度，这将会创建一个精度和刻度是实际实现的最大值的列。这种列将不会把输入值强制转换为某种特定的精度，而声明了精度的列会把输入值强制转换为指定的精度。(SQL 标准要求默认刻度为零，这是说，默认为整数刻度。我们发现这有点没用。如果你需要兼容性，要一直指定 `numeric` 的精度和刻度。)

> **Note**
>
> ​		显式指定时允许的最大精度是 1000；没有声明精度的 `NUMERIC` 遵循 Table 8.2 描述精度

​		如果实际数字的刻度大于声明列时的刻度，系统将会把实际数字四舍五入到指定的刻度。这时，如果实际的数字超过了指定的精度(数字的总数超过声明的精度，会报错。)

​		`numeric` 值物理存储时，没有任何额外的前导或后缀的零。因此，列声明的精度和刻度是最大值(在这种意义上，`numeric` 类型相较于 `char(n)` 更像 `varchar(n)`)。对于每个4个小数数字的组，实际存储需求是两字节，加3个数字是8字节。

​		除了原始的数的值，`numeric` 类型允许特殊的值 `NaN`，意思是 "不是一个数字"。任何对于 `NaN` 的操作产生另一个 `NaN`。当把这个值作为一个常量写在一个 SQL 命令中时，你必须把用单引号把它括起来，例如 `UPDATE table SET x = 'NaN'`。在输入的时候，字符串 'NaN' 被以大小写不敏感的方式识别。

>**Note**
>
>​		在大部分 "不是一个数字" 概念的实现中，NaN 被认为与任何其他数值不相等(包括 NaN)。为了允许数值被排序、被用在基于树的索引，pg 认为 NaN 值与 NaN 值是相等的，认为 NaN 值比其他非 NaN 值打。

​		数据类型 `decimal` 和 `numeric` 是相同的。这俩都是 SQL 标准的一部分。

​		当进行四舍五入操作时，`numeric` 类型会远离零，而(在大部分机器上) `real` 和 `double precision` 类型甚至会靠近零。例如：

```sql
SELECT x,
  round(x::numeric) AS num_round,
  round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
  x   | num_round | dbl_round
------+-----------+-----------
 -3.5 |        -4 |        -4
 -2.5 |        -3 |        -2
 -1.5 |        -2 |        -2
 -0.5 |        -1 |        -0
  0.5 |         1 |         0
  1.5 |         2 |         2
  2.5 |         3 |         2
  3.5 |         4 |         4
(8 rows)
```



### 8.1.3 浮点类型

​		数据类型 `real` 和 `double precision` 精度不高的、变精度的数字类型。在所有当前支持的平台，这些类型被以 IEEE 754 标准，这个标准是对于二进制浮点算术的(单精度和双精度，分别地)，面向更下层的处理器、操作系统、编译器，这些都支持它。

​		精度不高意味着，一些值不能被确切地转换为内部格式并且被存储近似值，所以存储或获取一个值将会显得有少许差异。管理这些错误并且怎么通过计算传递它们是数学与计算机科学的一个完整分支的主题，这里不会讨论，除了以下几点：

* 如果你需要精确的存储和计算（例如对于金钱数量），使用 `numeric` 代替。
* 如果你要为了一些重要的事物使用这些类型做复杂的运算，特别是你依赖于确切的边界行为(无限，下溢)，你应该仔细地评估具体实现。
* 比较两个浮点数是否相等，你可能不会得到预期的结果。



​		当前在所有支持的平台上，`real` 类型的表示范围是 1E-37 到 1E+37，精度是至少6个小数数字。`double precision` 类型的表示范围是 1E-307 到 1E+308，精度是至少15个小数数字。太大或太小的值将会造成错误。当输入的数值精度太高时，可能会发生四舍五入。太接近零的数字以至于不能与零分开表示的数值会造成下溢错误。

​		默认，浮点值以文本的形式输出它们的最短的精确的小数表示形式；产生的小数值比其他任何以同样二进制精度表示的值更接近真实存储的二进制值。（然而，输出值当前不确切地中途的，在两个可表示的值之间，为了避免广泛分布的bug：输入例程没有合适地遵循四舍五入规则。）这个值将会使用最多17个有效的小数数字对于 `float8` 值，至多9个对于 `float4` 值。

> **Note**
>
> ​		这种最短精度输出形式比传统的舍入规则计算更快。

​		为了与老版本的 pg 产生的输出兼容，允许输出精度被削减，参数 [extra_float_digits](https://www.postgresql.org/docs/13/runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS) 可能被用来选择四舍五入后的小数输出来代替。设置一个零重新存储当前的默认的四舍五入值到 6(对于`float4`) 或 15(对于`float8`) 个有效的小数数字。设置一个负值减少更多的数字数量；例如 -2 将会四舍五入输出 4 或 13 个数字单独地。

​		extra_float_digits 的任何大于零的值会选出最短精度的形式。

>**Note**
>
>​		需要精确值的应用程序，因为历史原因，不得不设置  extra_float_digits 到 3 来获取他们。为了版本之间的最大兼容性，他们应该继续这样做。

​		除了原始的数值，浮点数类型有几种特别的值：

```sql
Infinity
-Infinity
NaN
```

​		这些分别表示了 IEEE 754 的特殊值 "infinity"、"negative infinity"、和 "not-a-number"。当把这个值作为一个常量写在一个 SQL 命令中时，必须带上单引号，例如：'UPDATE table SET x = '-Infinity'。在输入上，这些字符串被以大小写不敏感的习惯处理。

>**Note**
>
>​		IEEE 754 指定 NaN 进行比较操作时不应该与其他任何浮点值(包括 NaN)。为了允许浮点值被排序和被用在树形索引中，pg 认为 NaN 值等于 NaN 值，而且比其他所有非 NaN 值相等。

​		pg 也支持 SQL 标准的语法 `float` 和 `float(p)` 来指定非精确数字类型。这里，***p*** 指定了可接受的以二进制形式表示的最小精度。对于 `real`，pg 接受 `float(1)` 到 `float(24)`，对于 `double precision` ，pg 接受 `float(25)` 到 `float(53)` 。***p*** 的值超过这个范围会报错。不指定精度的 `float` 被视为 `double precision`。



### 8.1.4 序列类型(5200)

> **Note**
>
> ​		这个小节描述了 pg 原生的创建自增列的方法。另一个方法是使用 SQL 标准提供的身份列方法，在 [CREATE TABLE](https://www.postgresql.org/docs/13/sql-createtable.html) 中描述。

​		数据类型 `smallserial, serial, bigserial` 不是真的类型，但仅对于创建唯一的身份列是一个方便的工具(类似于其他数据库提供的 `AUTO_INCREMENT` 特性)。在当前的实现中，指定：

```sql
CREATE TABLE tablename (
    colname SERIAL
);
```

 		等价于指定：

```sql
CREATE SEQUENCE tablename_colname_seq AS integer;
CREATE TABLE tablename (
    colname integer NOT NULL DEFAULT nextval('tablename_colname_seq')
);
ALTER SEQUENCE tablename_colname_seq OWNED BY tablename.colname;
```

​		因此，我们创建了一个整数列并且用一个序列生成器来管理默认值。一个 `NOT NULL` 约束被应用于保证无法插入 null 值。(在大多数情况下，你也想用 `UNIQUE` 或 `PRIMARY KEY` 约束来防止意外的插入重复值，但这不是自动的行为。) 最后，这个序列被标记为被这个列拥有，所以它在列删除的时候也会被删除。

>**Note**
>
>​		因为  `smallserial, serial, bigserial` 是以序列来实现的，列的序列值可能会出现空洞或沟，即使曾经没有删除过行。一个从序列中申请的值，在没有成功插入表的情况下也会被视为 “已使用”。这确实可能发生，例如，如果插入事务会滚了。看 [Section 9.17](https://www.postgresql.org/docs/13/functions-sequence.html) 的`nextval()` 。

​		要插入序列地下一个值到 `serial` 列中，指定 `serial` 列应该被赋予它的默认值。这可以通过在 `INSERT` 命令中不写 `serial` 列的名字，或使用 `DEFAULT` 关键字来赋值。

​		类型名 `serial` 与 `serial4` 是等价的：它俩都会创建 `integer` 列。类型名 `bigserial` 与 `serial8` 类似，但他们创建一个 `bigint` 列。当你期待在表的整个生命周期中使用超过 2^31 次方个标识符的时候。类型名 `smallserial` 和 `serial2` 也类似，但他们创建 `smallint` 列。

​		一个序列会随着所属 `serial` 列的删除而自动被删除。你可以在不删除所属 `serial` 列的情况下，删除序列，但这会强制删除列的默认表达式。



## 8.2 金钱类型

​		数据类型 `money` 存储一个现金数量，小数位的精度是固定的；看Table 8.3。小数位的精度取决于数据库的 [lc_monetary](https://www.postgresql.org/docs/13/runtime-config-client.html#GUC-LC-MONETARY) 设置。表中展示的范围假设小数位的精度是两位。输入可以接受丰富的格式，包括整数和浮点数的字面值，典型的现金格式也可以，例如 `$1,000.00`。输出一般是后一种形式，但取决于本地设置。

**Table 8.3**

| Name  | Storage Size | Description     | Range                                          |
| ----- | ------------ | --------------- | ---------------------------------------------- |
| money | 8 bytes      | currency amount | -92233720368547758.08 到 +92233720368547758.07 |

​		因为这个数据类型的输出是地区敏感的，将与当前 `lc_monetary` 不同的数据加载到数据库可能不会成功。为了避免问题，在重新加载一份 dump 到新数据库的时候，确认 `lc_monetary` 的值与 dump 来源的数据库相同或等价。

​		数据类型 `numeric, int, bigint` 的值可以转换为 `money` 类型。从 `real` 和 `double precision` 的转换，可以先转换为 `numeric`，例如：

```sql
SELECT '12.34'::float8::numeric::money;
```

​		然而，并不推荐这么做。浮点型不应该被应用处理金钱，由于四舍五入潜在的问题。

​		一个 `money` 类型的值可以无损精度的转换为 `numeric` 类型的值。转换为其他类型可能会损失精度，且必须用两步做：

```sql
SELECT '52093.89'::money::numeric::float8;
```

​		`money` 值被整数除，执行的时候会把小数部分截断为零。要得到四舍五入的值，用浮点数来除，或者在除之前和转换回 `money` 类型之前先将 `money` 转换为 `numeric`。(后一种更能避免精度损失) 当一个 `money` 值被另一个 `money` 值除的时候，结果类型是 `double precision` (是一个纯数字，不是 `money`)；在除的过程中现金的单位别除掉了。



## 8.3 字符类型

**Table 8.4**

| Name                             | Description      |
| -------------------------------- | ---------------- |
| character varying(n), varchar(n) | 有限制的变长     |
| character (n), char(n)           | 定长，空白填充   |
| text                             | 变化的无限的长度 |

​		Table 8.4 展示了 pg 中的通用目的字符类型。

​		SQL 定义了两种主要字符类型：`character varying(n)` 和 `character(n)`，***n*** 是一个正数。这俩类型可以存储至多 ***n*** 个字符(不是字节)的字符串。尝试存储更长的字符串将会导致错误，除非超过的字符都是空格，这种情况下字符串会被截断到最大长度。(这个有点奇怪的例外是 SQL 标准要求的。) 如果要被存储的字符串被声明的最大长度短，`character` 会用空格填充；`character varying` 会原模原样的存储这个字符串。

​		如果将一个值显式的转换为 `character(n)` 或 `character varying(n)` ，这时超过长度的值会被截断到 ***n*** 个字符而不回抛出一个错误。(这也是 SQL 标准要求的。)

​		记法 `varchar(n)` 和 `char(n)` 分别是是对`character varying(n)` 和 `character(n)`的别名。未指定长度的写法 `character` 等价于 `character(1)`。如果 `character varying` 没有指定长度，它接受任意长度的字符串。后一种是 pg 的扩展。

​		额外，pg 提供了 `text` 类型，它存储任意长度的字符串。虽然类型 `text` 不在 SQL 标准之中，其他几个数据库管理系统也提供这个类型。

​		`character` 类型的值被物理性用空格来扩展到最大长度 ***n***，并且以这种形式存储和显示。然而，尾巴上的空格被视为在语法上无关紧要并且被忽视当比较两个 `character` 类型的值时。在空白字符显得重要的排序规则中，这个行为会产生无法预期的结果；例如，`SELECT 'a'::CHAR(2) collate "C" < E'a\n'::CHAR(2)` 返回 true，即使 C 的本地设置认为空格被新行大。将 `character` 转换为其他某种字符串类型时，尾部的空白会被删除。注意，对于 `character varying` 和 `text` 值，尾部的空白在语义上是重要的，当使用模式匹配时，这说的是 `LIKE` 和 正则表达式。

​		