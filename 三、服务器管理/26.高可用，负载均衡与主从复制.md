

​		数据库服务器可以协同工作，允许第二个服务器接管服务，在第一个服务器宕机的时候(高可用)，或者允许几个计算机用同一份数据提供服务（负载均衡）。理想情况下，数据库服务器可以无缝地协作。以静态网页提供服务的 web 服务器可以十分简单地将 web 请求发送给多个服务器来进行负载均衡。实际上，只读数据库服务器也可以被简单的关联起来。不幸的是，大部分数据库服务器的请求都是读写混合的，读写服务器很难关联到一起。这是因为只读的数据需要被放置在每个服务器上只一次，一个对任何服务器的写需要被每个服务器执行，这样未来的读取请求才能返回一致的结果。

​		这些同步问题对于服务器协同工作是基础的难题。因为没有一个单独的解决方案可以消除所有场景中同步问题的影响，存在多种解决方案。每个解决方案以不同的方法来定位这个问题，最小化特殊负载的影响。

​		一些解决方案通过只允许一个服务器修改数据来处理同步问题。可以修改数据的服务器称为 ***read/write***、***master*** 或 ***primary servers***。跟踪 master 的变化的服务器称为 ***standby*** 或 ***secondary*** 服务器。一个无法连接，只能等到它被 promote 为 master 服务器才能被连接的 standby 服务器称为 ***warm standby*** 服务器，一个接受连接，仅提供只读服务的 standby 服务器叫做 ***hot standby*** 服务器。

​		一些解决方案是同步的，意味着一个数据修改事务不被认为提交，直到所有的服务器提交了这个事务。这保证了，如果发生 master 服务器宕机，不会丢失任何数据，并且所有负载均衡的机器将会返回一致的结果，无论请求的是哪个服务器。与此相反，异步的解决方案允许它的提交和传播到其他服务器之间存在一些延迟，这可能会在切换到备份服务器时丢失一些数据，并且负载均衡的服务器可能返回轻微不同的结果。异步的通信被使用，在同步方案太慢的时候。

​		解决方案也可以根据粒度来分类。一些解决方案可以仅处理一整个数据库服务器，当其他的服务器允许在每个表或每个数据库级别的控制。

​		任何解决方案都要考虑性能。一般在基础功能和性能之间存在一个权衡。例如，一个基础慢的网络的全同步的解决方案可能会比半同步降低性能，而异步的同步方案可能只有一点最小的性能影响。



## 26.1 比较不同的解决方案

##### Shared Disk Failover

​		共享磁盘故障切换通过只有一份数据库避免了同步的开销。它用一个被多个机器共享的磁盘阵列。如果主服务器宕机，后备服务器可能挂载磁盘并启动数据库，就像从数据库 crash 中恢复一样。这允许急速的故障切换，没有数据损失。

​		共享硬件功能在网络存储设备中非常普遍。使用一个网络文件系统也是可能的，虽然必须注意文件系统必须拥有完整的 POSIX 行为(看 [Section 18.2.2.1](https://www.postgresql.org/docs/13/creating-cluster.html#CREATING-CLUSTER-NFS)) 。这个方案的一个明显的限制是如果共享磁盘阵列坏掉或被打断，主服务器和后备服务器都无法正常使用。另一个问题是，后备服务器在主服务器运行的时候不应该访问共享存储。



##### File System (Block Device) Replication

​		硬件共享功能的一个版本是文件系统主从复制，对于文件系统的任何改变都会被镜像到另一个计算机的文件系统。唯一的限制是镜像操作必须以一种可以保证 standby 服务器拥有一个与 primary 服务器一致的文件系统方法来执行 - 特别的，向 standby 写操作的顺序必须与 master 一致。DRBD 是一个流行的文件系统主从复制解决方案对于 Linux。



##### Write-Ahead Log Shipping

​		warm standby 和 hot standby 可以通过读取 write-ahead log (WAL)记录的流来保持与 master 的一致。如果 master 服务器宕机，standby 服务器保存了 master 服务器几乎所有的数据，并且可以很快地变成 master 服务器。这可以是同步的，也可以是异步的，并且只可以对整个数据库来进行。

​		一个 standby 服务器可以用基于文件传送的方法实现([Section 26.2](https://www.postgresql.org/docs/13/warm-standby.html)) 或 流复制([Section 26.2.5](https://www.postgresql.org/docs/13/warm-standby.html#STREAMING-REPLICATION))，或者两者并存。关于 hot standby 的信息，看 [Section 26.5](https://www.postgresql.org/docs/13/hot-standby.html)。



##### Logical Replication

​		逻辑复制允许一个数据库服务器发送数据修改的流到另一个服务器。PostgreSQL 逻辑复制由来自 WAL 的逻辑的数据修改的流构成。逻辑复制允许来自单个表的数据修改被复制。逻辑复制不要求一个特定的服务器被标记为 master 或 replica ，但允许数据流向不同的方向。要获取更多关于逻辑复制的信息，看 [Chapter 30](https://www.postgresql.org/docs/13/logical-replication.html) 。通过逻辑解码接口([Chapter 48](https://www.postgresql.org/docs/13/logicaldecoding.html)) ，第三方插件也可以提供相似的功能。



##### Trigger-Based Master-Standby Replication

​		一个主从复制程序将所有的数据修改查询发送到 master 服务器。master 服务器异步地将数据修改发送给 standby 服务器。当 master 服务器运行的时候，standby 服务器可以应答只读查询。standby 服务器对于数据仓库查询是理想的。

​		Slony-I 是这种类型的主从复制的一个例子，以单表的粒度，并且支持多个 standby 服务器。因为它异步地（分批处理）更新了 standby 服务器，在故障切换时可能发生数据丢失。



##### SQL-Based Replication Middleware

​		使用基于 SQL 进行主从复制的中间件，程序监听每个 SQL 查询并且把它发送给一个或多个服务器。每个服务器互相依赖地操作。读/写 查询必须被发送给所有的服务器，这样每个服务器收到相同的改变。但是只读查询可以仅发送给一个服务器，允许读负载被分发给这些服务器。

​		如果查询仅仅被简单地无修改的广播，函数像 `random()`，`CURRENT_TIMESTAMP`，并且 sequence 在不同服务器上也会有不同的值。这是因为每个服务器都是单独地处理，并且因为 SQL 被广播（不是实际修改的行）。如果这是不可接受的，无论是中间件还是应用程序必须在单个服务器上查询这样的值，然后使用这些值在写查询上。另一个选项是使用这种复制和一种传统的主从复制程序，例如，数据修改查询只发送到 master 服务器上并传播到其他 standby 服务器通过主从复制，而不是通过主从复制中间件。必须小心所有的事务在所有服务器上，无论是提交或打断，获取使用了两段提交([PREPARE TRANSACTION](https://www.postgresql.org/docs/13/sql-prepare-transaction.html) 和 [COMMIT PREPARED](https://www.postgresql.org/docs/13/sql-commit-prepared.html)) 。pgpool-II 和 Continuent Tungsten 是这种主从复制的例子。



##### Asynchronous Multimaster Replication

​		对于不是一般的连接或通信比较慢的服务器，像笔记本或远程服务器，保持服务器间的数据一致是一个挑战。使用异步多 master 主从复制，每个服务器独立的工作，并且与其他服务器进行周期性的通信，来定位冲突的事务。冲突可以被用户或冲突解决规则解决。Bucardo 是这种类型的主从复制的例子。



##### Synchronous Multimaster Replication

​		在同步多 master 主从复制，每个服务器可以接受写请求，并且修改的数据被从原始服务器传送到每个其他的服务器，在每个事务提交前。沉重的写活动会造成过度的锁和提交延迟，导致性能低下。读请求可以被发送给任何服务器。一些实现使用共享磁盘来减少通信负载。同步多 master 主从复制对于很多读负载是最好的方案，它的巨大的优点是：任何服务器可以接受写请求 - 没有必要在 master 和 standby 之间进行负载均衡，因为数据改变被从一个服务器发送到另一个服务器，对于非确定性的函数像 `random()`，这是没有问题的。

​		PostgreSQL 没有提供这种类型的主从复制，但 PostgreSQL 的两段提交可以被用来实现这个，在应用程序代码或中间件。



## 26.2 基于日志传送的后备服务器



### 26.2.5  基于流复制的主从备份

​		基于流复制的主从同步让从服务器比基于日志传送的延迟更小。从服务器连接到主服务器，主服务器在 WAL 生成后立刻用流发送给从服务器，不用等待 WAL Segment 文件被填充满。

​		默认情况下，流复制是异步的，异步的情况下，事务在主服务器被提交 和 从服务器可以看到这个改变 之间存在一点延迟。这个延迟无论如何是比基于日志传送方式更小的，典型情况下，延迟在一秒以下，就假定从服务器足够有能力应对负载。在流式复制情况下，`archive_timeout` 对于减少数据丢失窗口不是必须的。

​		如果你用流式复制，而没有持续的基于文件的归档，服务器可能循环旧的 WAL Segment 文件，在从服务器接收到它们之前。如果出现了这种情况，从服务器需要从一个基础备份重新初始化。你可以避免这种情况的发生，通过设置 `wal_keep_segments` 到一个足够大的值，来保证 WAL Segments 不会太早的进行循环，或者为从服务器配置一个复制槽。如果你设置了可以从后备服务器上访问的 WAL 归档，这些解决方案就不需要了，因为从服务器可以一致使用归档来赶上它，保持足够的 WAL Segments。

​		要使用流复制，设置一个基于日志文件传送的从服务器（在 Section 26.2 中描述）。将基于日志文件传送的从服务器转变为基于流复制从服务器，需要在 `recovery.conf` 设置指向主库的 `primary_conninfo` 。在主服务器上设置 `listen_address` 和 认证选项 （在 `pg_hba.conf` 中），这样从库可以连接到主库 `replication` 的伪 database。

​		在支持 keepalive socket 选项的 OS 上，配置项 `tcp_keepalives_idle` 、`tcp_keepalives_interval` 和 `tcp_keepalive_count` 帮助主库在命令行上提示一个损坏的连接。

​		设置来自从库的并发的连接最大数量(看 `max_wal_senders`)。

​		当从库启动，并且 `primary_conninfo` 被正确设置的时候，在归档中的所有 WAL 被 replay 之后，从库将会连接到主库。如果连接成功建立，你将会在从库机器上看到 walreceiver 进程，并在主库机器上看到 walsender 进程。

​		
